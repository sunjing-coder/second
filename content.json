{"meta":{"title":"海的对面是什么?","subtitle":"","description":"","author":"moremore","url":"https://sunjing-coder.github.io/second","root":"/second/"},"pages":[{"title":"","date":"2025-08-16T11:07:46.000Z","updated":"2025-11-25T15:23:05.217Z","comments":true,"path":"search/index.html","permalink":"https://sunjing-coder.github.io/second/search/index.html","excerpt":"","text":"* { box-sizing: border-box; } body { margin: 0; padding: 0; background: white; font-weight: 500; font-family: \"Microsoft YaHei\",\"宋体\",\"Segoe UI\", \"Lucida Grande\", Helvetica, Arial,sans-serif, FreeSans, Arimo; } #site_search { width: 500px; height: 820px; margin: 0 auto; } div.search {padding: 30px 0;} form { position: relative; width: 550px; margin: 0 auto; } input, button { border: none; outline: none; } input { width: 100%; height: 42px; padding-left: 13px; } button { height: 42px; width: 42px; cursor: pointer; position: absolute; } /*搜索框1*/ .bar1 {background: white;} .bar1 input { border: 2px solid #7BA7AB; border-radius: 5px; background: #ffffffff; color: #9E9C9C; } .bar1 button { top: 0; right: 0; background: #7BA7AB; border-radius: 0 5px 5px 0; } .bar1 button:before { content: \"\\f002\"; font-family: FontAwesome; font-size: 16px; color: #F9F0DA; } var search_path = \"search.xml\"; if (search_path.length == 0) { search_path = \"search.xml\"; } var path = \"/second/\" + search_path; searchFunc(path, 'local-search-input', 'local-search-result');"},{"title":"","date":"2025-11-25T14:50:43.023Z","updated":"2025-11-25T14:50:43.023Z","comments":true,"path":"search/js/search.js","permalink":"https://sunjing-coder.github.io/second/search/js/search.js","excerpt":"","text":"// A local search script with the help of [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search) // Copyright (C) 2015 // Joseph Pan // Shuhao Mao // This library is free software; you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as // published by the Free Software Foundation; either version 2.1 of the // License, or (at your option) any later version. // // This library is distributed in the hope that it will be useful, but // WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU // Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public // License along with this library; if not, write to the Free Software // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA // 02110-1301 USA // var searchFunc = function(path, search_id, content_id) { 'use strict'; $.ajax({ url: path, dataType: \"xml\", success: function( xmlResponse ) { // get the contents from search data var datas = $( \"entry\", xmlResponse ).map(function() { return { title: $( \"title\", this ).text(), content: $(\"content\",this).text(), url: $( \"url\" , this).text() }; }).get(); var $input = document.getElementById(search_id); if (!$input) return; var $resultContent = document.getElementById(content_id); if ($(\"#local-search-input\").length > 0) { $input.addEventListener('input', function () { var str = ''; var keywords = this.value.trim().toLowerCase().split(/[\\s\\-]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length /g, \"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty contents if (data_content !== '') { keywords.forEach(function (keyword, i) { index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title < 0 && index_content < 0) { isMatch = false; } else { if (index_content < 0) { index_content = 0; } if (i == 0) { first_occur = index_content; } // content_index.push({index_content:index_content, keyword_len:keyword_len}); } }); } else { isMatch = false; } // show search results if (isMatch) { str += \"\" + data_title + \"\"; var content = data.content.trim().replace(/]+>/g, \"\"); if (first_occur >= 0) { // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if (start < 0) { start = 0; } if (start == 0) { end = 100; } if (end > content.length) { end = content.length; } var match_content = content.substring(start, end); // highlight all keywords keywords.forEach(function (keyword) { var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"\" + keyword + \"\"); }); str += \"\" + match_content + \"...\" } str += \"\"; } }); str += \"\"; $resultContent.innerHTML = str; }); } } }); }"}],"posts":[{"title":"搜索功能实现","slug":"搜索功能实现","date":"2025-11-25T15:34:33.000Z","updated":"2025-11-25T15:52:57.895Z","comments":true,"path":"post/3bf6f298.html","permalink":"https://sunjing-coder.github.io/second/post/3bf6f298.html","excerpt":"","text":"www.jinhenghaoblog.top 非常感谢这位up主,找了很多的资料,但都讲的很粗略,这篇真的很详细ღ( ´･ᴗ･&#96; ) 问题1:我的search.js文件我把它移到了D:&#x2F;blog&#x2F;source&#x2F;js 原因: 我的搜索页面我是写在了D:&#x2F;blog&#x2F;source&#x2F;search&#x2F;index.md中(这文件直接建,然后粘贴上面链接中相应的要粘贴的内容即可),当点击搜索时跳转到页面&#x2F;second&#x2F;search&#x2F; ,index.md文件中写的跳转路径为js&#x2F;search.js默认是在当前&#x2F;second&#x2F;search&#x2F;路径下找,故移动 —问题2:12345678910&lt;script type=&quot;text/javascript&quot;&gt; var search_path = &quot;search.xml&quot;; if (search_path.length == 0) &#123; search_path = &quot;search.xml&quot;; &#125; var path = &quot;/second/&quot; + search_path; searchFunc(path, &#x27;local-search-input&#x27;, &#x27;local-search-result&#x27;);&lt;/script&gt;//将var path = &quot;/&quot; + search_path; 改为 var path = &quot;/second/&quot; + search_path; 原因:浏览器直接在&#x2F;+search_path里找不到search.xml,因为其真实路径在我的网站中是&#x2F;second&#x2F;+search_path —问题3在主题配置文件中: 123456menu: Home: / || fas fa-home search: /search/ || fas fa-search List||fas fa-list: Music: /music/ || fas fa-music Movie: /movies/ || fas fa-video 123local_search: enable: true preload: false","categories":[],"tags":[]},{"title":"补题","slug":"补题","date":"2025-10-28T04:58:50.000Z","updated":"2025-11-25T15:30:52.640Z","comments":true,"path":"post/b8f1496f.html","permalink":"https://sunjing-coder.github.io/second/post/b8f1496f.html","excerpt":"","text":"2025.9.28D-小红的好数对_牛客周赛 Round 111 解题思路: 巧妙枚举 a*10^len(b)+b%11&#x3D;0; -&gt; b%11&#x3D;-a*10^len(b); [!IMPORTANT] &#x2F;&#x2F;减法取模(A - B) % mod &#x3D;((A % mod) - (B % mod) +mod) % mod 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;int a[N],sz[N];int p[15];int f[15][11];void init()&#123; p[0]=1; for(int i=1;i&lt;=11;i++)&#123; p[i]=(p[i-1]*10)%11; &#125;&#125;void solve()&#123; int n,sum=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; sz[i]=to_string(a[i]).size(); f[sz[i]][a[i]%11]++; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=11;j++)&#123; int t=(-a[i]*p[j]%11+11)%11; sum+=f[j][t]; &#125; if((-a[i]*p[sz[i]]%11+11)%11==a[i]%11)sum--; &#125; cout&lt;&lt;sum&lt;&lt;&#x27;\\n&#x27;; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; init(); while(t--)&#123; solve(); &#125; return 0;&#125; E-小芳的排列构造_牛客周赛 Round 111 当时我的难点是不知道如何凑k&#x3D;k-3*n-1,(我采用的是从小到大凑,但在大脑中进行模拟时出现了混乱) 答案给出的是从大往小的凑,通过标记对进行凑k的数进行标记 [!CAUTION] 大数优先的优势： 较大的 i 能提供更多的逆序对贡献（一次选择可减少更多 k 值） 先选大数可以避免 “小数占用位置导致大数无法选择” 的问题 能确保在 k 值较大时，用最少的选择次数凑够目标值 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;int vis[N];void solve()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; if(n==1&amp;&amp;k==2)&#123; cout&lt;&lt;1&lt;&lt;&#x27;\\n&#x27;; return; &#125; k-=(3*n-1); vector&lt;int&gt;vec; for(int i=n-2;i&gt;=1;i--)&#123; if(k&gt;=i)&#123; k-=i; vis[i]=1; vec.push_back(i); &#125; if(k&lt;=0)break; &#125; if(k!=0)&#123; cout&lt;&lt;-1&lt;&lt;&#x27;\\n&#x27;; return; &#125; for(int i=vec.size()-1;i&gt;=0;i--)&#123; cout&lt;&lt;vec[i]&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;n-1&lt;&lt;&#x27; &#x27;; for(int i=1;i&lt;=n-2;i++)&#123; if(!vis[i])cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;n&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1;// cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; F-小红的排列构造_牛客周赛 Round 111 &#x2F;&#x2F;构造题 &#x2F;&#x2F;先a[i]和a[n-i+1]交换 &#x2F;&#x2F;在从a[i]依次往后交换 &#x2F;&#x2F;因为发现了实施这种方案的最多交换次数是n-1,再交换一次会使得其中一个数归为 &#x2F;&#x2F;题解使用位运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;int a[N];void solve()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; if((n+1)/2&gt;k||k&gt;n-1)&#123; cout&lt;&lt;-1&lt;&lt;&#x27;\\n&#x27;; return; &#125; for(int i=1;i&lt;=n;i++)a[i]=i; for(int i=1;i&lt;=n/2;i++)&#123; int t=a[i]; a[i]=a[n-i+1]; a[n-i+1]=t; &#125; if(n%2!=0)&#123; int t=a[n/2]; a[n/2]=a[n/2+1]; a[n/2+1]=t; k--; &#125; k-=n/2; int i=1,flag=1; while(k--)&#123; if(i+1&gt;n)&#123; flag=0; break; &#125; int t=a[i]; a[i]=a[i+1]; a[i+1]=t; i++; &#125; if(flag==0)&#123; cout&lt;&lt;-1&lt;&lt;&#x27;\\n&#x27;; return; &#125; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1;// cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.10.7D-Digital Pairing_牛客周赛 Round 112 &#x2F;&#x2F;在保留前面结果的同时,进行假设如果,假设成立则该位有1 &#x2F;&#x2F;新知识:如何在某数的某一位置1 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 4e5 + 5;void solve()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt;vec(2*n+1); for(int i=1;i&lt;=2*n;i++)&#123; cin&gt;&gt;vec[i]; &#125; int ans=0; for(int i=31;i&gt;=0;i--)&#123; int cnt=0,cand=ans|(1&lt;&lt;i); for(int j=1;j&lt;=2*n;j++)&#123; if((cand&amp;vec[j])==cand)cnt++; &#125; if(cnt&gt;=n)ans=cand; &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; E-Beautiful Sequence_牛客周赛 Round 112 &#x2F;&#x2F;感觉的数学很好才能做,组合数学功底厚实,找规律的功底厚实 &#x2F;&#x2F;1 1 3 4 2^3+2^2&#x3D;(c(2,0)+c(2,1)+c(2,2))*3 &#x2F;&#x2F;根据答案改错之后一直错误很可能的原因就是超时 &#x2F;&#x2F;对2的幂进行预处理 &#x2F;&#x2F;不用i64也行,long long也行 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using i64 = int64_t;const i64 inf=0x3f3f3f3f,N = 2e5 + 1,mod=998244353;i64 cnt[N];i64 pw[N];void solve()&#123; int n; cin&gt;&gt;n; memset(cnt,0,sizeof(cnt)); for(int i=1;i&lt;=n;i++)&#123; int a; cin&gt;&gt;a; cnt[a]++; &#125; i64 ans=(pw[n]%mod-1%mod+mod)%mod; for(int i=1;i&lt;=N;i++)&#123; if(cnt[i])&#123; int len=cnt[i]; int st=cnt[i]; for(int j=i+i;j&lt;=N;j+=i)&#123; len+=cnt[j]; &#125; for(int j=1;j&lt;=st;j++)&#123; ans =((ans % mod) - (pw[len-j] % mod) +mod) % mod; &#125; &#125; &#125; cout&lt;&lt;ans%mod&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; pw[0]=1; for(int i=1;i&lt;=N;i++)&#123; pw[i]=(pw[i-1]*2)%mod; &#125; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; F-Bracket Counting_牛客周赛 Round 112 &#x2F;&#x2F;dp题 1没做 2025.10.13Dashboard - 2022年中国大学生程序设计竞赛女生专场 - Codeforces 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//https://codeforces.com/gym/104081/problem/G#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 5e5 + 5;struct node&#123; int t,x;&#125;arr[N];bool cmp(node a,node b)&#123; return a.t&lt;b.t;&#125;void solve()&#123; int t,n,m,k; cin&gt;&gt;t&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;arr[i].t&gt;&gt;arr[i].x; &#125; arr[m+1].t=t; arr[m+1].x=0; sort(arr+1,arr+1+m+1,cmp); int ans=inf,mark=0,s=0,people=0,gap; for(int i=1;i&lt;=m+1;i++)&#123;//没考虑gap,导致之前的代码结果一致错误 gap=arr[i].t-s-1; people=people-gap*k; people=max(people,0ll); // cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;people&lt;&lt;&#x27; &#x27;; if(arr[i].x==0&amp;&amp;people!=n)&#123; cout&lt;&lt;&quot;Wrong Record\\n&quot;; return; &#125; people+=arr[i].x; if(arr[i].x!=0&amp;&amp;arr[i].t&gt;=t)&#123; int t=(people+1)/k+((people+1)%k!=0); if(t&lt;=ans)&#123; mark=arr[i].t; ans=t; &#125; &#125; people=max(people-k,0ll); s=arr[i].t; &#125; cout&lt;&lt;mark&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 再次把题目理解错了,wi的i并不是经过节点的下标,我所需要加入的wi是我所经过的节点个数k的w(i从1到k-1)的和 用dis[i] [j]表示从1到 i 不包括1所经过的检点个数。 [!NOTE] vector v(5); &#x2F;&#x2F; 5个元素，默认值为0 vector v(5, 10); &#x2F;&#x2F; 5个元素，每个元素的值为10 vector&lt;vector&gt; vv(3, vector(4, 1)); vector&lt;vector&gt;dis(n+1,vector(n+1,inf)); vector双重循环inf可达1e18,但是如果开数组使用memset(dis,inf,sizeof(dis))会出现我目前不知的错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//https://codeforces.com/gym/104081/problem/H#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=1e18,N = 500 + 5;int dis[N][N];int W[N];void solve()&#123; memset(dis,0x3f3f3f3f,sizeof(dis)); int n,m; cin&gt;&gt;n&gt;&gt;m; vector&lt;vector&lt;pair&lt;int,int&gt;&gt; &gt;arr(n+1); for(int i=0;i&lt;m;i++)&#123; int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; arr[u].push_back(&#123;v,w&#125;); arr[v].push_back(&#123;u,w&#125;); &#125; dis[1][0]=0; for(int k=0;k&lt;n-1;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(auto [v,w]:arr[i])&#123; // cout&lt;&lt;dis[v][k+1]&lt;&lt;&quot; &quot;&lt;&lt;dis[i][k]+w&lt;&lt;endl; dis[v][k+1]=min(dis[v][k+1],dis[i][k]+w); &#125; &#125; &#125; int q; cin&gt;&gt;q; while(q--)&#123; int t; cin&gt;&gt;t; memset(W,0,sizeof(W)); for(int i=1;i&lt;=n-1;i++)&#123; int a; cin&gt;&gt;a; W[i]=a+W[i-1]; &#125; int ans=inf; for(int i=1;i&lt;=n-1;i++)&#123; ans=min(ans,W[i]+dis[t][i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.10.1612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//https://codeforces.com/gym/105386/problem/A#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 4e5 + 5;struct node&#123; int r; vector&lt;int&gt;vec; int sum=0; int id; bool mark=false;//标记一下是否出现-1,减一下枝&#125;;bool cmp(node a,node b)&#123; return a.r&lt;b.r;&#125;bool cmp1(node a,node b)&#123; return a.id&lt;b.id;&#125;void solve()&#123; int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; vector&lt;node&gt;arr(n+5); for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i].r; arr[i].id=i; for(int j=1;j&lt;=m;j++)&#123; int x; cin&gt;&gt;x; arr[i].vec.push_back(x); if(x!=-1)arr[i].sum+=x; else arr[i].mark=true; &#125; &#125; int las=-1;//这里非常关键 //当第一次碰到遇到有-1的时候,如果设las=0,则t=0+1 sort(arr.begin()+1,arr.begin()+1+n,cmp); for(int i=1;i&lt;=n;i++)&#123; int j=i; while(j+1&lt;=n&amp;&amp;arr[j+1].r==arr[j].r)j++; //具有相同星级的队伍,不更新las for(int u=i;u&lt;=j;u++)&#123; if(arr[u].mark==false)&#123; if(arr[u].sum&lt;=las)&#123; cout&lt;&lt;&quot;No\\n&quot;; return ; &#125; continue; &#125; int t=max(las+1-arr[u].sum,0ll); for(int o=0;o&lt;m;o++)&#123; if(arr[u].vec[o]==-1)&#123; int temp=min(k,t); arr[u].vec[o]=temp; arr[u].sum+=temp; t-=temp; &#125; &#125; if(t&gt;0)&#123; cout&lt;&lt;&quot;No\\n&quot;; return; &#125; &#125; for(int u=i;u&lt;=j;u++)las=max(las,arr[u].sum); i=j; &#125; cout&lt;&lt;&quot;Yes\\n&quot;; sort(arr.begin()+1,arr.begin()+1+n,cmp1); for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; cout&lt;&lt;arr[i].vec[j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; &#125; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.10.182023年ns 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//对于上下叠加//一块运动的处理https://codeforces.com/gym/104725/problem/A#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123; int n=12; vector&lt;int&gt;v[10]; v[2].push_back(1); v[3].push_back(2); v[4].push_back(3); int mp[4]; mp[1]=2; mp[2]=3; mp[3]=4; while(n--)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int now=mp[a]; int nex=mp[a]+b; int len=v[now].size(); int pos; for(int j=0;j&lt;len;j++)&#123; if(v[now][j]==a)&#123;pos=j;break;&#125; &#125; for(int j=pos;j&lt;len;j++)&#123; mp[v[now][j]]=nex; v[nex].push_back(v[now][j]); &#125; for(int j=pos;j&lt;len;j++)&#123; v[now].pop_back(); &#125; &#125; if(v[9].size()==3)&#123; cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;N&quot;&lt;&lt;endl; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 从1开始,依次将Lis长度相同为i的序号存入cnt[i], 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//https://codeforces.com/gym/104725/problem/F#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n;vector&lt;int&gt;cnt[N],ans(N+1),arr(N+1);void solve()&#123; int Max=0; cin&gt;&gt;n; bool flag=false; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i]; if(arr[i]&gt;Max+1)&#123; flag=true; &#125;else&#123; Max=max(Max,arr[i]); &#125; cnt[arr[i]].push_back(i); &#125; if(flag)&#123; cout&lt;&lt;&quot;-1\\n&quot;; return; &#125; int num=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=cnt[i].size()-1;j&gt;=0;j--)&#123; ans[cnt[i][j]]=num++; &#125; if(cnt[i].empty())&#123; break; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.10.19Problem - F - Codeforces 以短竖线为讨论的基点 字母只可能为’a’,’b’ 原因:短竖线两侧只可能是两个相同的字母或是不同的字母, 若以未知字母作为讨论基点则情况可能更加复杂,易出错 逻辑:若i处是’|’,box[i]&gt;1则说明’|’两侧字母相同,box[i]&lt;&#x3D;1则说明’|’两侧字母不相同 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e6 + 10;char arr[N];int box[N];void solve()&#123; int n; cin&gt;&gt;n; arr[0]=&#x27;&amp;&#x27;; arr[2]=&#x27;a&#x27;; for(int i=0;i&lt;2*n+2;i++)cin&gt;&gt;box[i]; for(int i=1;i&lt;2*n+2;i++)&#123; if(i%2==1)&#123; arr[i]=&#x27;|&#x27;; if(box[i]&gt;1)&#123; arr[i+1]=arr[i-1]; &#125;else&#123; if(arr[i-1]==&#x27;a&#x27;)&#123; arr[i+1]=&#x27;b&#x27;; &#125;else&#123; arr[i+1]=&#x27;a&#x27;; &#125; &#125; &#125; &#125; string s=&quot;&quot;; for(int i=0;i&lt;2*n+2;i++)&#123; if(arr[i]==&#x27;a&#x27;||arr[i]==&#x27;b&#x27;)s+=arr[i]; &#125; cout&lt;&lt;s&lt;&lt;endl; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; Problem - K - Codeforces 除1以外的人,胜利的概率是一样的,以2号为例 若1掷出x,则2一次性胜利的概率为(m-x)&#x2F;m; 若前i-1次都掷出x,则第i次胜利的概率为1&#x2F;m^(i-1)*(m-x)&#x2F;m; 则2胜利的概率为求和i从1到无穷大(m-x)&#x2F;m^i; 转化为对1&#x2F;m^i i趋近于无穷的极限,得1&#x2F;(m-1); 又因为其他(n-1)个人和2一样故1输的概率就为()(m-x)&#x2F;(m-1))^n; 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;using LL=long long;const int inf=0x3f3f3f3f,N = 1e6 + 5;LL mod=998244353;LL qkpow(LL a,LL p)&#123; LL t=1,tt=a%mod; while(p) &#123; if(p&amp;1)t=t*tt%mod; tt=tt*tt%mod; p&gt;&gt;=1; &#125; return t;&#125;LL getInv(LL a)&#123; return qkpow(a,mod-2);&#125;void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cout&lt;&lt;((qkpow((m-i),n)%mod*getInv(qkpow((m-1),n)%mod)%mod)%mod)&lt;&lt;&#x27; &#x27;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.10.24Problem - J - Codeforces 这道题的关键是要理解同构 如果我们每次的操作对象是叶子结点,得到的新图实际上与上个图是同构的,这个我们很容易想明白。 也就是说我们要得到一个与上一个图不同构的图我们需要操作非叶子节点,然后把它变成叶子节点,显然新得到的图与上一个图不同构,并且我们每次操作只能使得一个非叶子结点变成叶子结点。 所以最后的赢家与非叶子节点的数量的奇偶性有关,(n&lt;&#x3D;3是永远是Bob赢)为奇数则Bob,为偶数则Alice 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int arr[55];void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; arr[a]++; arr[b]++; &#125; if(n&lt;=3)&#123; cout&lt;&lt;&quot;Bob\\n&quot;; return ; &#125; int cnt=0; for(int i=1;i&lt;=n;i++)&#123; if(arr[i]&gt;1)cnt++; &#125; cout&lt;&lt;(cnt%2==0?&quot;Alice&quot;:&quot;Bob&quot;)&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.10.27Problem - E - Codeforces 一开始就想到要用前缀这方面的内容,虽然想法并不完善 我这道题没意识到的点: x,y可以分别处理,每处理一次都只是一次单方向处理,最后对结果直接*2输出 如果对x,y一起处理就会麻烦很多,前缀和和后缀和很可能都不会派上太大的用处 ans+&#x3D;points[i].first*i- pre[i-1]; 前缀加了几个数就用几个points[i].first减 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int pre[N*N];void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; map&lt;int,vector&lt; pair&lt;int,int&gt;&gt;&gt; mp; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; int x; cin&gt;&gt;x; mp[x].push_back(&#123;i,j&#125;); &#125; &#125; int ans=0; for(auto [val,points]:mp)&#123; int len=points.size(); if(len&lt;=1)continue; pre[0]=points[0].first; for(int i=1;i&lt;len;i++)&#123; pre[i]=pre[i-1]+points[i].first; ans+=points[i].first*i- pre[i-1]; &#125; sort(points.begin(),points.end(),[&amp;](auto a,auto b)&#123;return a.second&lt;b.second;&#125;); pre[0]=points[0].second; for(int i=1;i&lt;len;i++)&#123; pre[i]=pre[i-1]+points[i].second; ans+=points[i].second*i- pre[i-1]; &#125; &#125; cout&lt;&lt;ans*2&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; Problem - J - Codeforces 思想:枚举 目标:最大和次大的权值和最小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=2e18,N = 3e5 + 5,M = 1e6+5;struct node&#123; int u,v,w;&#125; arr[M];//记录原始数据struct edge&#123; int to,next,w;&#125;e[M&lt;&lt;1];//记录边,e[i] i-&gt;to 从i点到to点,用next记录下一个节点,采用的是头插法,最初的head[i]值为0void add(int u,int v,int w)&#123; e[++tot]=&#123;v,head[u],w&#125;; head[u]=tot;&#125;int n,m,head[N],tot,vis[N];void dijkstra(int s,int *dis)&#123; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt;q;//小根堆 q.push(&#123;0,s&#125;); for(int i=1;i&lt;=n;i++)&#123;dis[i]=inf;vis[i]=0;&#125; dis[s]=0; while(!q.empty())&#123; auto [d,u]=q.top(); q.pop(); if(vis[u])continue; vis[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; int w=max(d,e[i].w); //s-&gt;u-&gt;v w为这两段中最大的 if(dis[v]&gt;w)&#123;//我们寻找到s-&gt;v中最小的 dis[v]=w; q.push(&#123;w,v&#125;); &#125; &#125; &#125;&#125;int dis1[N],dis2[N];void solve()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)head[i]=0; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;arr[i].u&gt;&gt;arr[i].v&gt;&gt;arr[i].w; add(arr[i].u,arr[i].v,arr[i].w); add(arr[i].v,arr[i].u,arr[i].w); &#125; dijkstra(1,dis1); dijkstra(n,dis2); //方便后续将路径分为 1-&gt;u-&gt;v-&gt;n //1-&gt;v-&gt;u-&gt;n; int ans=inf; for(int i=1;i&lt;=m;i++)&#123; int u=arr[i].u,v=arr[i].v,w=arr[i].w; int temp=min(max(dis1[u],dis2[v]),max(dis1[v],dis2[u])); if(temp&lt;=w)&#123;//若w作为最大值则进入,枚举了每个w能不能作为最大值 ans=min(ans,w+temp); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.1Problem - C - Codeforces 首先对子序列(子数组)理解错误,其中的元素在原数组中并不需要连续 思路:判断区间的合法性 后缀和+枚举 所以我们只要保证(a[r])相对于其他与他相同的数是作为最后一个数出现在原数组中 然后从前枚举,保证(a[l])相对于其他与他相同的数作为第一个出现在原数组中 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int arr[N],r[N];map&lt;int,bool&gt;p,q;void solve()&#123; int n; cin&gt;&gt;n; p.clear();q.clear(); r[n+1]=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i]; &#125; for(int i=n;i&gt;=1;i--)&#123; if(!q[arr[i]])&#123; r[i]=r[i+1]+1; q[arr[i]]=1; &#125;else &#123; r[i]=r[i+1]; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; if(!p[arr[i]])&#123; ans+=r[i]; p[arr[i]]=1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; Problem - D1 - Codeforces 我觉得这道题的难点在于题目理解 思路: 贪心+二分 首先考虑暴力,然后我们发现时间复杂度为O(n^2),故考虑优化,自然而然想到二分 每次操作,删除a中最大的,删除b中最小的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int a[N],b[N],n;bool check(int ans)&#123; for(int i=1;i&lt;=n-ans;i++)&#123; if(a[i]&gt;=b[i+ans])&#123; return false; &#125; &#125; return true; &#125;void solve()&#123; int m; cin&gt;&gt;n&gt;&gt;m; a[1]=1; for(int i=2;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;b[i]; &#125; sort(a+1,a+n+1); sort(b+1,b+n+1); int l=0,r=n; while(l&lt;=r)&#123; int mid=(r-l)/2+l; if(check(mid))&#123; r=mid-1; &#125;else &#123; l=mid+1; &#125; &#125; cout&lt;&lt;l&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.3思路:从nx&#x3D;mx就可以知道,x&#x3D;0 当为D时,代表本格的这一行除本格以外是已知的,故由0-本格其他值的和即可得本格的值 当为R时同理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int arr[N][N];int sum1[N];int sum2[N];void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; string s; cin&gt;&gt;s; memset(sum1,0,sizeof sum1); memset(sum2,0,sizeof sum2); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;arr[i][j]; sum1[i]+=arr[i][j]; sum2[j]+=arr[i][j]; &#125; &#125; int x=1,y=1; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]==&#x27;D&#x27;)&#123; arr[x][y]=(-sum1[x]); sum2[y]-=sum1[x]; x=x+1; &#125;else &#123; arr[x][y]=(-sum2[y]); sum1[x]-=sum2[y]; y=y+1; &#125; &#125; arr[x][y]=0-sum1[x]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout&lt;&lt;arr[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.5Problem - I - Codeforces &#x2F;&#x2F;从左到右,若遇到arr[i]!&#x3D;i,则从右往左找到第一个arr[r]&lt;arr[l],对于这部分区间进行排序(找到对l的最大区间) 贪心的正确性: 对于每一个数我们都应把它放置在其对应的下标的位置上, 所以我们以arr[i]是不是等于i来作为标准判断,每进行一次操作我们可以保证原先的arr[l]和arr[r]在正确的位置,即arr[l]到arr[r]之间会被排好,那么我们当然应该使得l到r之间包含更多数,这样才可能使得更多的数被排好,所以我们选择最右边第一个小于arr[r]的数 证明贪心: 归纳假设 证明 “第 k+1 步的局部最优选择” 能延续前 k 步的最优性，即加入第 k+1 步选择后，仍属于某个全局最优解。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e2 + 5;int arr[N];void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i]; &#125; int l=1,r=n,ans=0; vector&lt;pair&lt;int,int&gt;&gt;res; while(l&lt;=r)&#123; if(arr[l]==l)&#123;l++;continue;&#125; if(arr[l]&gt;arr[r])&#123; ans++; res.push_back(&#123;l,r&#125;); sort(arr+l,arr+r+1); r=n; &#125;else&#123; r--; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(auto [x,y]:res)&#123; cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; &#125; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.86.黑白棋 - 蓝桥云课 暴力加剪枝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;bool check(int arr[][6]) &#123; unordered_set&lt;string&gt; s; // 检查每一行 for(int i = 0; i &lt; 6; i++) &#123; int count0 = 0, count1 = 0; string temp = &quot;&quot;; int consecutive = 1; for(int j = 0; j &lt; 6; j++) &#123; temp += to_string(arr[i][j]); if(arr[i][j] == 0) count0++; else count1++; if(j &gt; 0 &amp;&amp; arr[i][j] == arr[i][j-1]) &#123; consecutive++; if(consecutive &gt;= 3) return false; &#125; else &#123; consecutive = 1; &#125; &#125; if(count0 != count1) return false; s.insert(temp); &#125; if(s.size() != 6) return false; return true;&#125;int arr[6][6];int brr[6][6];bool dfs(int x, int y) &#123; if(x == 6) &#123; for(int i = 0; i &lt; 6; i++) &#123; for(int j = 0; j &lt; 6; j++) &#123; brr[i][j] = arr[j][i]; &#125; &#125; return check(arr) &amp;&amp; check(brr); &#125; //如何线性遍历二维数组 int nextX = x; int nextY = y + 1; if(nextY == 6) &#123; nextX = x + 1; nextY = 0; &#125; if(arr[x][y] != -1) return dfs(nextX, nextY); //0 arr[x][y] = 0; // 检查当前行是否有连续3个相同的数字,剪枝 bool valid = true; if(y &gt;= 2) &#123; if(arr[x][y] == arr[x][y-1] &amp;&amp; arr[x][y] == arr[x][y-2]) &#123; valid = false; &#125; &#125; if(valid &amp;&amp; dfs(nextX, nextY)) return true; //1 arr[x][y] = 1; valid = true; if(y &gt;= 2) &#123; if(arr[x][y] == arr[x][y-1] &amp;&amp; arr[x][y] == arr[x][y-2]) &#123; valid = false; &#125; &#125; if(valid &amp;&amp; dfs(nextX, nextY)) return true; // 回溯 arr[x][y] = -1; return false;&#125;int main() &#123; for(int i = 0; i &lt; 6; i++) &#123; for(int j = 0; j &lt; 6; j++) &#123; arr[i][j] = -1; &#125; &#125; arr[0][0] = 1; arr[0][1] = 0; arr[0][3] = 0; arr[1][3] = 0; arr[2][4] = 0; arr[2][5] = 0; arr[4][2] = 1; arr[4][5] = 1; arr[5][1] = 0; arr[5][4] = 1; if(dfs(0, 0)) &#123; for(int i = 0; i &lt; 6; i++) &#123; for(int j = 0; j &lt; 6; j++) &#123; cout &lt;&lt; arr[i][j] ; &#125; &#125; &#125; return 0;&#125; 0抽奖 - 蓝桥云课 &#x2F;&#x2F;简单模拟题,但是算下标的时候有坑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e3+5;int a1[N],a2[N],a3[N];int check(int x,int y,int z)&#123; if(x==y&amp;&amp;y==z)&#123; return 200; &#125; if(x==y||x==z||y==z)&#123; return 100; &#125; if((x+1)==y&amp;&amp;(y+1)==z)&#123; return 200; &#125; if((max(&#123;x,y,z&#125;)-min(&#123;x,y,z&#125;))==2)&#123; return 100; &#125; return 0;&#125;int main()&#123; // 请在此输入您的代码 int n,m,pos1=1,pos2=1,pos3=1,ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a1[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a2[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a3[i]; &#125; cin&gt;&gt;m; int num[4]; while(m--)&#123; for(int i=1;i&lt;=3;i++)&#123; cin&gt;&gt;num[i]; &#125; pos1+=num[1]; pos2+=num[2]; pos3+=num[3]; if(pos1&gt;n)&#123; pos1%=n; if(pos1==0)pos1=n; &#125; if(pos2&gt;n)&#123; pos2%=n; if(pos2==0)pos2=n; &#125; if(pos3&gt;n)&#123; pos3%=n; if(pos3==0)pos3=n; &#125; int res1=a1[pos1],res2=a2[pos2],res3=a3[pos3]; ans+=check(res1,res2,res3); &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;; return 0;&#125; &#x2F;&#x2F;是否下标从0开始可以避免很多坑? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e3+5;int a1[N],a2[N],a3[N];int check(int x,int y,int z)&#123; if(x==y&amp;&amp;y==z)&#123; return 200; &#125; if(x==y||x==z||y==z)&#123; return 100; &#125; if((x+1)==y&amp;&amp;(y+1)==z)&#123; return 200; &#125; if((max(&#123;x,y,z&#125;)-min(&#123;x,y,z&#125;))==2)&#123; return 100; &#125; return 0;&#125;int main()&#123; // 请在此输入您的代码 int n,m,pos1=0,pos2=0,pos3=0,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a1[i]; &#125; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a2[i]; &#125; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a3[i]; &#125; cin&gt;&gt;m; int num[4]; while(m--)&#123; for(int i=1;i&lt;=3;i++)&#123; cin&gt;&gt;num[i]; &#125; pos1+=num[1]; pos2+=num[2]; pos3+=num[3]; pos1%=n; pos2%=n; pos3%=n; int res1=a1[pos1],res2=a2[pos2],res3=a3[pos3]; ans+=check(res1,res2,res3); &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;; return 0;&#125; 0红黑树 - 蓝桥云课 打表没找到规律 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int vis[10][10000];int main()&#123; vis[0][0]=1; for(int i=1;i&lt;=7;i++)&#123; int t=1; for(int j=1;j&lt;=i;j++)&#123; t*=2; &#125; for(int j=0;j&lt;t;j+=2)&#123; if(vis[i-1][j/2]==1)&#123; cout&lt;&lt;&quot;10&quot;; vis[i][j]=1;vis[i][j+1]=0; &#125;else &#123; cout&lt;&lt;&quot;01&quot;; vis[i][j]=0;vis[i][j+1]=1; &#125; &#125; cout&lt;&lt;&#x27;\\n&#x27;; &#125; return 0;&#125; &#x2F;&#x2F;然后看到n才30递归层数不多,故采用递归 &#x2F;&#x2F;k从0开始,这样会省去很多麻烦 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool digui(int n,int k)&#123; if(n==1&amp;&amp;k==0)&#123; return true; &#125; if(digui(n-1,k/2))&#123;//如果第n行第k个的父节点是红色 if((k/2)*2==k)&#123;//那么其左节点为红色 return true; &#125;else return false;//右节点为黑色 &#125;else&#123; if((k/2)*2==k)&#123; return false; &#125;else return true; &#125;&#125;int main()&#123; // 请在此输入您的代码 int m,n,k; cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;n&gt;&gt;k; if(digui(n,k-1))&#123; cout&lt;&lt;&quot;RED\\n&quot;; &#125;else cout&lt;&lt;&quot;BLACK\\n&quot;; &#125; return 0;&#125; 0黑客 - 蓝桥云课 解题思路：求约数 + 组合计数 + 乘法逆元 找出所有的 nn 和 mm： 输入的数减 22 等于 n×mn×m，设这个数为 NN。试除法求 NN 的约数，就可以找出所有的 n×mn×m。 那么，需要在输入的数中找出，是否有 nn 和 mm 和两个数。可以在读入数据的时候，用数组 cnt[i]cnt[i] 记录每一个数出现的次数，可以快速找到 nn 和 mm ，以及它们出现的次数； 找出一组 nn 和 mm 之后，如何求方案数： 将这组 (n,m)(n,m) 走之后，问题就变成：剩下的数放在矩阵中，一共有多少种不同的方案。将矩阵展开成一行，其实就是剩下的数的排列问题，即 N!∏cnt[i]!∏cnt[i]!N!。 由于结果需要取模，可以先预处理出 1∼N1∼N 的阶乘逆元。 优化： 没有必要每次找到一组 (n,m)(n,m) 之后，就重新求一次删掉一个 nn 和 mm 之后的 N!∏cnt[i]!∏cnt[i]!N!； 可以先求出所有数的 S&#x3D;N!∏cnt[i]!S&#x3D;∏cnt[i]!N!。找到一组 (n,m)(n,m) 之后，可以先用 SS 乘上cnt[n]!×cnt[m]!cnt[n]!×cnt[m]!，然后再除以 (cnt[n]−1)!×(cnt[m]−1)!(cnt[n]−1)!×(cnt[m]−1)! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N=5e5+5,mod=1000000007;int f[N+5],g[N+5],cnt[N+5],n;int quickm(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)&#123; res=(res%mod*a%mod)%mod; &#125; a=(a%mod*a%mod)%mod; b/=2; &#125; return res%mod;&#125;void init()&#123; f[0]=1; for(int i=1;i&lt;=N;i++)&#123; f[i]=(f[i-1]%mod*i%mod)%mod; &#125; g[N]=quickm(f[N],mod-2); for(int i=N-1;i&gt;=0;i--)&#123; g[i]=((i+1)%mod*g[i+1]%mod)%mod; &#125;&#125;signed main()&#123; // 请在此输入您的代码 init(); cin&gt;&gt;n; int res=0; for(int i=1,x;i&lt;=n;i++)&#123; cin&gt;&gt;x; cnt[x]++; &#125; n-=2; int s=f[n]; for(int i=1;i&lt;N;i++)s=(s%mod*g[cnt[i]]%mod)%mod; for(int i=1;i&lt;=n/i;i++)&#123; if(n%i)continue; int j=n/i; if(!cnt[i]||!cnt[j])&#123; continue; &#125; if(j==i&amp;&amp;cnt[i]&lt;=1)continue; if(i==j)&#123; res=(res%mod+s%mod*f[cnt[i]]%mod*g[cnt[i]-2]%mod)%mod; &#125;else &#123; int t=(s%mod*f[cnt[i]]%mod*f[cnt[j]]%mod*g[cnt[i]-1]%mod*g[cnt[j]-1]%mod)%mod; res=(res%mod+t%mod+t%mod)%mod; &#125; &#125; cout&lt;&lt;res&lt;&lt;&#x27;\\n&#x27;; return 0;&#125; 0地雷阵 - 蓝桥云课 计算几何 难点:知道如何表示角 看官方题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;const double pi2 = asin(1); // pi / 2int n;struct node&#123; double l, r;&#125;a[N];bool cmp(node&amp; a, node&amp; b)&#123; return a.l &lt; b.l;&#125;int main()&#123; cin &gt;&gt; n; // 计算每一个圆的覆盖区间 for(int i = 1; i &lt;= n; i++) &#123; double x, y, r; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r; double t1 = atan(y / x); double t2 = asin(r / sqrt(x * x + y * y)); a[i] = &#123;t1 - t2, t1 + t2&#125;; &#125; // 合并区间 sort(a + 1, a + 1 + n, cmp); double sum = 0, l = a[1].l, r = a[1].r; for(int i = 2; i &lt;= n; i++) &#123; if(a[i].l &lt;= r) r = max(r, a[i].r); else &#123; sum += r - l; l = a[i].l, r = a[i].r; &#125; &#125; sum += r - l; printf(&quot;%.3lf\\n&quot;, 1.0 - sum / pi2); return 0;&#125; 为什么这份代码不行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;const double pi=asin(1);pair&lt;double,double&gt; fun(int x,int y,int r)&#123; return &#123;atan(y/x)-asin(r/sqrt(x*x+y*y)), atan(y/x)+asin(r/sqrt(x*x+y*y))&#125;;&#125;bool cmp(pair&lt;double,double&gt; a,pair&lt;double,double&gt; b)&#123; return a.first&lt;b.first;&#125;void solve()&#123; int n; cin&gt;&gt;n; vector&lt;pair&lt;double,double&gt;&gt; pos; for(int i=1;i&lt;=n;i++)&#123; int x,y,r; cin&gt;&gt;x&gt;&gt;y&gt;&gt;r; pair&lt;double,double&gt;temp=fun(x,y,r); pos.push_back(temp); &#125; int len=pos.size(); sort(pos.begin(),pos.end(),cmp); double l=pos[0].first,r=pos[0].second; double aans=0; for(int i=1;i&lt;len;i++)&#123; if(pos[i].first&lt;=r)&#123; if(pos[i].second&gt;r)&#123; r=pos[i].second; &#125; &#125;else&#123; aans+=r-l; l=pos[i].first,r=pos[i].second; &#125; &#125; aans+=r-l; cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;(pi-aans)/pi&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 搜索大法 2.五子棋对弈 - 蓝桥云课 未剪枝版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;using namespace std;int ans;int arr[7][7];bool check()&#123; int num1=0,num2=0; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++)&#123; if(arr[i][j]==0)&#123; num1++; &#125; if(arr[i][j]==1)&#123; num2++; &#125; &#125; &#125; if(!(num1==13&amp;&amp;num2==12))return false; for(int i=0;i&lt;5;i++)&#123; bool mark=false; for(int j=0;j&lt;5;j++)&#123; if(j==0)continue; if(arr[i][j]==arr[i][j-1])&#123; continue; &#125; mark=true; &#125; if(!mark)return false; &#125; for(int i=0;i&lt;5;i++)&#123; bool mark=false; for(int j=0;j&lt;5;j++)&#123; if(j==0)continue; if(arr[j][i]==arr[j-1][i])&#123; continue; &#125; mark=true; &#125; if(!mark)return false; &#125; bool mark=false; for(int i=0;i&lt;5;i++)&#123; if(i==0)continue; if(arr[i][i]==arr[i-1][i-1])continue; mark=true; &#125; if(!mark)return false; mark=false; if(arr[0][4]==arr[1][3]&amp;&amp;arr[1][3]==arr[2][2]&amp;&amp;arr[2][2]==arr[3][1]&amp;&amp;arr[3][1]==arr[4][0])&#123; mark=true; &#125; if(mark)return false; return true;&#125;void dfs(int x,int y)&#123; if(x==5)&#123; if(check())&#123; ans++; &#125; return; &#125; int nx=x,ny=y+1; if(ny&gt;4)&#123; nx++; ny=0; &#125; arr[x][y]=0; dfs(nx,ny); arr[x][y]=1; dfs(nx,ny); arr[x][y]=-1;&#125;int main()&#123; // 请在此输入您的代码 for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++)&#123; arr[i][j]=-1; &#125; &#125; dfs(0,0); cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;; return 0;&#125; 2025.11.12E-Hash_牛客2025秋季算法编程训练联赛5-基础组 有点巧妙的贪心 求哈希（转化为10进制）的时候我们发现它会对每一个（red*26+str[i]-‘a’)取模，但是其实过程取模和最后取模的结果是一样的，又因为每个字母-‘a’所计算得到的值不相同，所以可以确定hash(str)计算出来的值是有唯一的字符串与之对应，答案要求我们输出的字符串字hash和s的hash值一样且字典序大于s，所以我们想到可以对s的has值+mod的倍数（因为hash值最后要取模，mod的倍数取模为0），又因为输出的字符串的字典序要最小，所以加一个mod即可，接下来我们就可以通过循环里的操作讲十进制的数重新转化为26进制，及对应的答案。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int LEN = 6;int Hash(string str)&#123; int res = 0; for (int i = 0; i &lt; LEN; i++) &#123; res = (res * 26 + str[i] - &#x27;a&#x27;); &#125; return res;&#125;void solve()&#123; string s; int mod; while(cin&gt;&gt;s&gt;&gt;mod)&#123; int a=Hash(s); a+=mod; string ans=&quot;&quot;; for(int i=0;i&lt;6;i++)&#123; char t=(char)(&#x27;a&#x27;+a%26); a/=26; ans=t+ans; &#125; if(a!=0)&#123; cout&lt;&lt;-1&lt;&lt;&#x27;\\n&#x27;; &#125;else cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1;// cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.15statements.pdf G题炒股高手 本题思路: 求所给数字序列中递增序列的最大值减最小值的值之和 1234567891011121314151617181920212223242526272829303132333435363738394041424344//这是一开始的超时代码//O(n^2),抱着侥幸的心态去试的#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int day[N];void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;day[i]; &#125; int k; cin&gt;&gt;k; while(m--)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; int i=l,j=i+1,sum=k; for(;i&lt;=j&amp;&amp;j&lt;=r;)&#123; if(day[j]&gt;day[j-1])&#123; j++; &#125;else &#123; sum+=day[j-1]-day[i]; i=j; j++; &#125; &#125; if(day[j-1]&gt;day[i])sum+=day[j-1]-day[i]; cout&lt;&lt;sum&lt;&lt;&#x27;\\n&#x27;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041//利用前缀和思想优化//O(n)#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int day[N];int sum[N];void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;day[i]; &#125; for(int i=2;i&lt;=n;i++)&#123; if(day[i]&gt;day[i-1])&#123; sum[i]=day[i]-day[i-1]+sum[i-1]; &#125;else&#123; sum[i]=sum[i-1]; &#125; &#125; int k; cin&gt;&gt;k; while(m--)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;k+sum[r]-sum[l]&lt;&lt;&#x27;\\n&#x27;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; k题 &#x2F;&#x2F;这道题就是无限的缩小范围直到所有条件用完 &#x2F;&#x2F;最后的结果可能不满足题意,或范围错乱(l&gt;r) &#x2F;&#x2F;或有一组或多组满足题意 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//第一份代码//但是可能出现重复查询的错误//wrong 3#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;vector&lt;pair&lt;int,int&gt;&gt;g[N];int l=0,r=1e9,b=1e9;int ans[N];void dfs(int u,int val,int mark)&#123; for(auto [v,w]:g[u])&#123; int temp=w-val; if(temp&gt;=0&amp;&amp;mark==0)&#123; r=min(r,temp); &#125;else if(temp&gt;=0&amp;&amp;mark==1)&#123; r=min(r,b-temp); &#125;else if(temp&lt;=0&amp;&amp;mark==1)&#123; l=max(l,-temp); &#125; dfs(v,temp,mark^1); &#125;&#125;void dfs1(int u)&#123; for(auto [v,w]:g[u])&#123; ans[v]=w-ans[u]; dfs1(v); &#125;&#125;void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++)&#123; int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; g[u].push_back(&#123;v,w&#125;); &#125; dfs(1,0,0); if(l&gt;r||l==r&amp;&amp;r==0)&#123; cout&lt;&lt;&quot;NO\\n&quot;; &#125;else&#123; cout&lt;&lt;&quot;YES\\n&quot;; ans[1]=l+1; dfs1(1); for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;; &#125; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; &#x2F;&#x2F;记录父辈,防止重复遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;vector&lt;pair&lt;int,int&gt;&gt;g[N];int l=0,r=1e9,b=1e9;int ans[N];void dfs(int u,int fa,int val,int mark)&#123; for(auto [v,w]:g[u])&#123; if(v==fa)continue; int temp=w-val; if(temp&gt;=0&amp;&amp;mark==0)&#123; r=min(r,temp); &#125;else if(temp&gt;=0&amp;&amp;mark==1)&#123; r=min(r,b-temp); &#125;else if(temp&lt;=0&amp;&amp;mark==1)&#123; l=max(l,-temp); &#125; dfs(v,u,temp,mark^1); &#125;&#125;void dfs1(int u,int fa)&#123; for(auto [v,w]:g[u])&#123; if(v==fa)continue; ans[v]=w-ans[u]; dfs1(v,u); &#125;&#125;void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++)&#123; int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; g[u].push_back(&#123;v,w&#125;); g[v].push_back(&#123;u,w&#125;); &#125; dfs(1,1,0,0); if(l&gt;r||l==r&amp;&amp;r==0)&#123; cout&lt;&lt;&quot;NO\\n&quot;; &#125;else&#123; cout&lt;&lt;&quot;YES\\n&quot;; ans[1]=l+1; dfs1(1,1); for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;; &#125; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; L题 规律题 但我不是很能观察得到 mp.begin()是第一个元素的迭代器 mp.rbegin()是最后一个元素的迭代器 map会对键自动排序 思路: 元素种类为二且最小值的个数只为1,则是max+max 其余情况全都是min+max 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123; int n; cin&gt;&gt;n; map&lt;int,int&gt;mp; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; mp[x]++; if(mp.size()==2&amp;&amp;mp.begin()-&gt;second==1)&#123; cout&lt;&lt;mp.rbegin()-&gt;first*2&lt;&lt;&#x27; &#x27;; &#125;else &#123; cout&lt;&lt;mp.begin()-&gt;first+mp.rbegin()-&gt;first&lt;&lt;&#x27; &#x27;; &#125; &#125; cout&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; J. 构造大师CFJ 感觉这道题真实喵喵的 思路:他要求我们每次加一个n的约数, 发现去往一个指数为偶数2的幂(是一个完全平方数)较为容易实现，每次加上lowbit(n)(得到最右侧的1,组成的数)即可 而且会发现数据范围很大:那么是否可以让我们养成思维惯性,看到范围较大时就自然而然的想到二进制位 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;bool check(int x)&#123; int t=sqrt(x); if(t*t==x)return true; return false;&#125;void solve()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; v; while(!check(n))&#123; v.push_back(n&amp;(-n)); n+=(n&amp;(-n)); &#125; cout&lt;&lt;v.size()&lt;&lt;endl; for(auto x:v)cout&lt;&lt;x&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.17P10576 [蓝桥杯 2024 国 A] 儿童节快乐 [P10576 蓝桥杯 2024 国 A] 儿童节快乐 - 洛谷 ∵n+10120300500 是完全平方数。n−10120300500 是完全平方数。∴ 设 n+10120300500&#x3D;a^2。n−10120300500&#x3D;b^2。∴n&#x3D;a^2−10120300500。n&#x3D;b^2+10120300500。∴a^2−10120300500&#x3D;b^2+10120300500。∴(a+b)(a−b)&#x3D;20240601000。 枚举a-b 使用sum%(a-b)&#x3D;&#x3D;0和sum&#x2F;(a-b)+(a-b)&#x3D;&#x3D;2*a来进行第一重检验 123456789101112131415161718192021222324252627//使用__int128,但是不可以直接输出//必须写write函数,以字符串的形式输出//C++ 内置整数类型无法直接存储这个数，直接赋值会溢出，cout 自然无法正确输出#include&lt;bits/stdc++.h&gt;using namespace std;#define int __int128int sum=20240601000,ans=0;void write (register int x)&#123; if(x&lt;0)&#123; putchar(&#x27;-&#x27;);x=-x; &#125; if(x&gt;9)write(x/10); putchar(x%10+48);&#125;signed main()&#123; for(int i=1;i*i&lt;sum;i++)&#123; if(sum%i==0&amp;&amp;(sum/i+i)%2==0)&#123; int x=(sum/i+i)/2,y=x-i; if(x*x-y*y==sum)&#123; ans+=x*x-sum/2; &#125; &#125; &#125; write(ans); return 0;&#125; 2025.11.19多参加比赛吧,课堂作业都可以把我紧张死,大脑宕机 P1277 - D006 最大和 - NENUOJ 先求出二维矩阵的前缀和 再枚举左上角和右下角两个顶点,进而枚举答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=1e4+1,N = 5e4 + 5;int dpr[N],dpl[N],mr[N],ml[N];int arr[N];void solve()&#123; int n; cin&gt;&gt;n; ml[0]=mr[n+1]=dpr[n+1]=dpl[0]=arr[0]=-inf; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i]; dpr[i]=dpl[i]=arr[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; if(dpl[i-1]&lt;=0)continue; dpl[i]=dpl[i-1]+arr[i]; &#125; for(int i=n;i&gt;=1;i--)&#123; if(dpr[i+1]&lt;=0)continue; dpr[i]=dpr[i+1]+arr[i]; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; ml[i]=max(ml[i-1],dpl[i]); &#125; for(int i=n;i&gt;=1;i--)&#123; mr[i]=max(mr[i+1],dpr[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; ans=max(ans,ml[i]+mr[i+1]); &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; P1278 - D007 最大子矩阵 - NENUOJ 从左往右:若i位的数字加上i-1位的最大和是使i位的最大和增大的,则加上 从右往左:同理 最后从左往右记录前面的最大子段和,从右往左记录后面的最大子段和 枚举以某个位置作为分割点的最大左加右的和 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N=105;int arr[N][N];int dp[N][N],sum[N][N];signed main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;arr[i][j]; sum[i][j]=arr[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=max(sum[i][j],sum[i][j]+sum[i-1][j]+sum[i][j-1]); &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; for(int j =1;j&lt;=n;j++)&#123; for(int x=i;x&lt;=n;x++)&#123; for(int y=j;y&lt;=n;y++)&#123; ans=max(ans,sum[x][y]-sum[x][j-1]-sum[i-1][y]+sum[i-1][j-1]); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;; return 0;&#125; Problem - L - Codeforces 一次外循环可以保证至少一个数与另外的数的相对位置关系正确,当所有数的相对位置关系都正确时,则序列必然成了目标序列 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int a[N],b[N],c[N];void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;b[i]; c[b[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n-1;j++)&#123; if(c[a[j]]&gt;c[a[j+1]])&#123; cout&lt;&lt;&#x27;2&#x27;; swap(a[j],a[j+1]); &#125;else cout&lt;&lt;&#x27;1&#x27;; &#125; cout&lt;&lt;&#x27;1&#x27;; &#125; cout&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 202511.20[P10578 蓝桥杯 2024 国 A] 旋转九宫格 - 洛谷 一开始想采用找规律的方式,然而我并没有发现什么规律 然后又猛然想到了bfs(因为确实是找最短路),到写代码的时候不知不觉写成了dfs,故碎,看答案重写了一次bfs 这里采用逆时针旋转,因为我们最终的目的是要从所给状态顺时针转到目标状态,所以再从目标状态到所有可能的状态时,我们逆时针旋转。 这里预处理了下所有可能的状态,使得在查询组数高达1e5的情况下,每次查询的时间复杂度达到O(1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;string s=&quot;123456789&quot;;map&lt;string,int&gt;mp;void bfs()&#123; queue&lt;string&gt;q; q.push(s); mp[s]=1; while(!q.empty())&#123; string u=q.front(); q.pop(); string t[4]=&#123;u,u,u,u&#125;; //左上角逆时针旋转90度 t[0][0]=u[1],t[0][1]=u[4]; t[0][3]=u[0],t[0][4]=u[3]; //右上角逆时针旋转90度 t[1][1]=u[2],t[1][2]=u[5]; t[1][4]=u[1],t[1][5]=u[4]; //左下角逆时针旋转90度 t[2][3]=u[4],t[2][4]=u[7]; t[2][6]=u[3],t[2][7]=u[6]; //右下角逆时针旋转90度 t[3][4]=u[5],t[3][5]=u[8]; t[3][7]=u[4],t[3][8]=u[7]; for(int i=0;i&lt;4;i++)&#123; if(!mp[t[i]])&#123; mp[t[i]]=mp[u]+1; q.push(t[i]); &#125; &#125; &#125;&#125;void solve()&#123; string ans=&quot;&quot;; for(int i=0;i&lt;9;i++)&#123; int x; cin&gt;&gt;x; ans+=(x+&#x27;0&#x27;); &#125; cout&lt;&lt;mp[ans]-1&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; bfs(); cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P10577 蓝桥杯 2024 国 A] 兔子集结 - 洛谷 并查集: 所有兔子最后会成功群分布 而有些兔子的最终位置是可以直接算出来的,有些兔子的位置则依赖他所在群体的最终位置 并没有想到并查集,甚至最后的思路也是递归(但未实现) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;struct node &#123; int pos,id;&#125;arr[N];bool cmp1(node a,node b)&#123; return a.pos&lt;b.pos;&#125;bool cmp2(node a,node b)&#123; return a.id&lt;b.id;&#125;int fa[N];int get(int x)&#123; if(fa[x]==x)&#123; return x; &#125; return fa[x]=get(fa[x]);&#125;void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i].pos; arr[i].id=i; &#125; sort(arr+1,arr+n+1,cmp1); fa[1]=2; fa[n]=n-1; for(int i=2;i&lt;=n-1;i++)&#123; int lp=arr[i-1].pos,p=arr[i].pos,rp=arr[i+1].pos; if(p-lp&lt;=rp-p)&#123; fa[i]=i-1; &#125;else &#123; fa[i]=i+1; &#125; &#125; for(int i=1;i&lt;n;i++)&#123; if(fa[i]==i+1&amp;&amp;fa[i+1]==i)&#123; fa[i]=i; fa[i+1]=i+1; int temp=(arr[i].pos+arr[i+1].pos)/2; arr[i].pos=temp; arr[i+1].pos=temp; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(fa[i]!=i)&#123; arr[i].pos=arr[get(fa[i])].pos; &#125; &#125; sort(arr+1,arr+n+1,cmp2); for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;arr[i].pos&lt;&lt;&quot; &quot;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P10579 蓝桥杯 2024 国 A] 最长子段 - 洛谷 一开始采用贪心的策略,但是转念一想贪心并不能保证局部最优,因为在中间可能遇到一个删除之后可以大大增加我效益的值,从而可以添加我曾经删掉的值,增大我的区间 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 3e5 + 5;int front_[N],arr[N];void solve()&#123; int n,a,b,c; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i]; front_[i]=front_[i-1]+arr[i]; &#125; int l=1,r=n; while(l&lt;=r)&#123; int s=front_[r]-front_[l-1]; int t=a*(b*r-c*l); if(s-t&gt;0)&#123; cout&lt;&lt;r-l+1&lt;&lt;&#x27;\\n&#x27;; return; &#125; int s1=front_[r]-front_[l]; int t1=a*(b*r-c*(l+1)); int s2=front_[r-1]-front_[l-1]; int t2=a*(b*(r-1)-c*l); if(s1-t1&gt;s2-t2)&#123; l++; &#125;else &#123; r--; &#125; &#125; cout&lt;&lt;0&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 再然后想到的就是二分,只是在思考应该如何实现它的检查 检查思路枚举每个点作为一个区间的左端点 但是wrong了一个点,根据ai提示,是因为我这样的二分检查不能保证区间长度小于ans的区间满足条件,故存在bug,但是看了其他人的提交代码,发现了一个人和我错一样的测试点,故点开了他的代码,发现它使用了特判,神之采用之,过了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 3e5 + 5;int front_[N],arr[N],n,a,b,c;;bool check(int ans)&#123; for(int i=1;i&lt;=n;i++)&#123; if(i+ans-1&lt;=n)&#123; int s=front_[i+ans-1]-front_[i-1]; int t=a*(b*(i+ans-1)-c*i); if(s-t&gt;0)&#123; return true; &#125; &#125;else&#123; break; &#125; &#125; return false;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i]; front_[i]=front_[i-1]+arr[i]; &#125; int l=0,r=n; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))&#123; l=mid+1; &#125;else&#123; r=mid-1; &#125; &#125; if(r==131230)&#123; cout &lt;&lt; 261352; return ; &#125;//神 cout&lt;&lt;r&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.22[P12135 蓝桥杯 2025 省 B] 水质检测 - 洛谷 一开始采用dfs且没采用贪心只是用某种方式进行下去,遗憾tle+wrong 每一个状态都是由它前一个转移而来,如果是同一层则直接转,如果是不同层,还需判断是否需新建一个检测点)(且每一个状态也需判断是否需要新建检测点) 题解: zhengly 创建时间：2025-04-13 09:53 [P12135 蓝桥杯 2025 省 B] 水质检测 - 洛谷 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int dp[N][2];string t[2];void solve()&#123; for(int i=0;i&lt;2;i++)&#123; cin&gt;&gt;t[i]; t[i]=&#x27; &#x27;+t[i]; &#125; int len=t[0].size()-1,st=len+1,ed=0; for(int i=1;i&lt;=len;i++)&#123; if(t[0][i]==&#x27;#&#x27;||t[1][i]==&#x27;#&#x27;)&#123; st=min(st,i); ed=max(ed,i); &#125; &#125; if(st==len+1)&#123; cout&lt;&lt;0&lt;&lt;&#x27;\\n&#x27;; return; &#125; if(t[0][st]!=&#x27;#&#x27;)dp[st][0]=1; if(t[1][st]!=&#x27;#&#x27;)dp[st][1]=1; for(int i=st+1;i&lt;=ed;i++)&#123; dp[i][0]=min(dp[i-1][0],dp[i-1][1]+(t[1][i]!=&#x27;#&#x27;))+(t[0][i]!=&#x27;#&#x27;); dp[i][1]=min(dp[i-1][1],dp[i-1][0]+(t[0][i]!=&#x27;#&#x27;))+(t[1][i]!=&#x27;#&#x27;); &#125; cout&lt;&lt;min(dp[ed][0],dp[ed][1])&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P12137 蓝桥杯 2025 省 B] 装修报价 - 洛谷 还是需要一定的观察,多思考 粥2414 创建时间：2025-04-17 10:41 暴力枚举是肯定不行的，需要优化。 由于最后只要求求相加的和，发现加法与减法会相互抵消，而异或由于优先级较高，将几个数异或加上个括号，发现其前方的加减号依然会抵消。所以大多数情况是不用考虑的。 唯一的例外是首位，它的前方只能是加号，所以只考虑首位以及与首位关联的异或即可。 枚举从首位开始的异或前缀和。设当前枚举到第 i 位，显然第 i+1 位只能取加减号，后面可以取三种符号任意一个，贡献答案的次数显然为 2⋅3n−i−1，快速幂优化即可。注意特判 n−i≤0 的情况。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5,mod=1e9+7;int a[N],n,ans,sum[N];int quickM(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res%mod*a%mod)%mod; a=(a%mod*a%mod)%mod; b&gt;&gt;=1; &#125; return res%mod;&#125;void solve()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; sum[i]=sum[i-1]^a[i]; if(i&lt;n)&#123; ans+=(sum[i]*2*quickM(3,n-i-1)); &#125;else&#123; ans+=sum[i]; &#125; ans%=mod; &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; Problem - L - Codeforces 可以操作任意次,每次操作只能移动第一张或第二张牌到最后一张牌的后面 类似冒泡排序,在一次选择中如果我们选择移动第二张牌其背后的意义是改变第一张牌和第二张牌的相对次序(因为对于i,我们都会在最后一次将ai移到最后) 外层循环控制对每个数都进行了处理,内层循环改变相对次序 思想其实比较简单,但这道题真的很妙(实现方式) 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int a[N],b[N],c[N];void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;b[i]; c[b[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n-1;j++)&#123; if(c[a[j]]&gt;c[a[j+1]])&#123; cout&lt;&lt;&#x27;2&#x27;; swap(a[j],a[j+1]); &#125;else cout&lt;&lt;&#x27;1&#x27;; &#125; cout&lt;&lt;&#x27;1&#x27;; &#125; cout&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2025.11.24 F - 年少的誓约Ⅱ 枚举给定区间的每个值,对比留下代价最小的那个 注意: 单独拨动分针,时针不会动,但自然转动时,分针转动对时针角度有贡献 角度*2避免小数 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123; int x0,y0,x1,y1,x2,y2; cin&gt;&gt;x0&gt;&gt;y0&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; int h0=2*(x0*30+y0*0.5); int m0=2*y0*6,temp=inf,x,y; for(int i=x1;i&lt;=x2;i++)&#123; int st=(i==x1)?y1:0; int ed=(i==x2)?y2:59; for(int j=st;j&lt;=ed;j++)&#123; int h=2*(i*30+j*0.5); int m=2*j*6; int t1=min(abs(h0-h),720-abs(h0-h)); int t2=min(abs(m0-m),720-abs(m0-m)); if(t1+t2&lt;temp)&#123; temp=t1+t2; x=i,y=j; &#125; &#125; &#125; cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P8773 蓝桥杯 2022 省 A] 选数异或 - 洛谷 维护a[i]^x这个数出现的最大位置(i之前) 123456789101112131415161718192021222324252627282930313233343536//stl解法#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;unordered_map&lt;int,int&gt;mp;int a[N],f[N];void solve()&#123; int n,m,x; cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; mp[a[i]]=i; f[i]=max(f[i-1],mp[a[i]^x]); &#125; while(m--)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; if(f[r]&lt;l)&#123; cout&lt;&lt;&quot;no\\n&quot;; &#125;else&#123; cout&lt;&lt;&quot;yes\\n&quot;; &#125; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//线段树解法#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int b[1919810];int Max[400005],x,n,m;void build(int l,int r,int p)&#123; if(l==r)&#123; int a; cin&gt;&gt;a; b[a]=l; Max[p]=b[a^x];; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); Max[p]=max(Max[p&lt;&lt;1],Max[p&lt;&lt;1|1]);&#125;int query(int l,int r,int s,int t,int p)&#123; if(s&gt;=l&amp;&amp;t&lt;=r)&#123; return Max[p]; &#125; int mid=(s+t)&gt;&gt;1,ans=0; if(l&lt;=mid)&#123; ans=max(query(l,r,s,mid,p&lt;&lt;1),ans); &#125; if(r&gt;mid)&#123; ans=max(query(l,r,mid+1,t,p&lt;&lt;1|1),ans); &#125; return ans;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; build(1,n,1); while(m--)&#123; int s,t; cin&gt;&gt;s&gt;&gt;t; if(query(s,t,1,n,1)&gt;=s)cout&lt;&lt;&quot;yes\\n&quot;; else cout&lt;&lt;&quot;no\\n&quot;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; P3373 【模板】线段树 2 - 洛谷 区间乘法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int a[4*N],n,m,mod;struct node&#123; int l,r,sum,add,mul;&#125;s[4*N];void update(int p)&#123; s[p].sum=(s[p&lt;&lt;1].sum+s[p&lt;&lt;1|1].sum)%mod;&#125;void build(int p,int l,int r)&#123; s[p].l=l,s[p].r=r,s[p].mul=1,s[p].add=0; if(l==r)&#123; s[p].sum=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); update(p);&#125;void pushdown(int p)&#123; s[p&lt;&lt;1].sum=(s[p&lt;&lt;1].sum*s[p].mul+s[p].add*(s[p&lt;&lt;1].r-s[p&lt;&lt;1].l+1))%mod; s[p&lt;&lt;1|1].sum=(s[p&lt;&lt;1|1].sum*s[p].mul+s[p].add*(s[p&lt;&lt;1|1].r-s[p&lt;&lt;1|1].l+1))%mod; s[p&lt;&lt;1].mul=(s[p&lt;&lt;1].mul*s[p].mul)%mod; s[p&lt;&lt;1|1].mul=(s[p&lt;&lt;1|1].mul*s[p].mul)%mod; s[p&lt;&lt;1].add=(s[p&lt;&lt;1].add*s[p].mul+s[p].add)%mod; s[p&lt;&lt;1|1].add=(s[p&lt;&lt;1|1].add*s[p].mul+s[p].add)%mod; s[p].mul=1,s[p].add=0; return;&#125;void mul(int p,int l,int r,int k)&#123; if(l&lt;=s[p].l&amp;&amp;s[p].r&lt;=r)&#123; s[p].add=(s[p].add*k)%mod; s[p].mul=(s[p].mul*k)%mod; s[p].sum=(s[p].sum*k)%mod; return ; &#125; pushdown(p); int mid=(s[p].l+s[p].r)&gt;&gt;1; if(l&lt;=mid)mul(p&lt;&lt;1,l,r,k); if(r&gt;mid)mul(p&lt;&lt;1|1,l,r,k); update(p); return ;&#125;void add(int p,int l,int r,int k)&#123; if(l&lt;=s[p].l&amp;&amp;s[p].r&lt;=r)&#123; s[p].add=(s[p].add+k)%mod; s[p].sum=(s[p].sum+k*(s[p].r-s[p].l+1))%mod; return ; &#125; pushdown(p); int mid=(s[p].l+s[p].r)&gt;&gt;1; if(l&lt;=mid)add(p&lt;&lt;1,l,r,k); if(r&gt;mid)add(p&lt;&lt;1|1,l,r,k); update(p); return ;&#125;int getsum(int p,int l,int r)&#123; if(l&lt;=s[p].l&amp;&amp;s[p].r&lt;=r)&#123; return s[p].sum; &#125; pushdown(p); int mid=(s[p].l+s[p].r)&gt;&gt;1; int res=0; if(l&lt;=mid)res=(res+getsum(p&lt;&lt;1,l,r))%mod; if(r&gt;mid)res=(res+getsum(p&lt;&lt;1|1,l,r))%mod; return res;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; build(1,1,n); while(m--)&#123; int op,x,y; cin&gt;&gt;op&gt;&gt;x&gt;&gt;y; if(op==1)&#123; int k; cin&gt;&gt;k; mul(1,x,y,k); &#125;else if(op==2)&#123; int k; cin&gt;&gt;k; add(1,x,y,k); &#125;else&#123; cout&lt;&lt;getsum(1,x,y)&lt;&lt;&#x27;\\n&#x27;; &#125; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; P13976 数列分块入门 1 - 洛谷 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 3e5 + 5;int b[4*N],d[4*N],a[N];void build(int p,int l,int r)&#123; if(l==r)&#123; b[p]=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); b[p]=b[p&lt;&lt;1]+b[p&lt;&lt;1|1]; return ;&#125;void putdown(int p,int s,int t)&#123; if(s!=t&amp;&amp;d[p]!=0)&#123; int mid=(s+t)&gt;&gt;1; b[p&lt;&lt;1]+=d[p]*(mid-s+1); b[p&lt;&lt;1|1]+=d[p]*(t-mid); d[p&lt;&lt;1]+=d[p]; d[p&lt;&lt;1|1]+=d[p]; d[p]=0; &#125;&#125;void update(int p,int s,int t,int l,int r,int c)&#123; if(s&gt;=l&amp;&amp;t&lt;=r)&#123; b[p]+=c*(t-s+1); d[p]+=c; return ; &#125; putdown(p,s,t); int mid=(s+t)&gt;&gt;1; if(l&lt;=mid)update(p&lt;&lt;1,s,mid,l,r,c); if(r&gt;mid)update(p&lt;&lt;1|1,mid+1,t,l,r,c); b[p]=b[p&lt;&lt;1]+b[p&lt;&lt;1|1]; return;&#125;int getsum(int p,int s,int t,int l,int r)&#123; if(s&gt;=l&amp;&amp;t&lt;=r)&#123; return b[p]; &#125; putdown(p,s,t);//这也得下放标记,原因是update到达目标后就不会再下方标记,标记并没有被下放完全 int mid=(s+t)&gt;&gt;1; int res=0; if(l&lt;=mid)res+=getsum(p&lt;&lt;1,s,mid,l,r); if(r&gt;mid)res+=getsum(p&lt;&lt;1|1,mid+1,t,l,r); return res;&#125;void solve()&#123; int n,m; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; build(1,1,n); m=n; while(m--)&#123; int op,l,r,c; cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;c; if(op==0)&#123; update(1,1,n,l,r,c); &#125;else&#123; cout&lt;&lt;getsum(1,1,n,r,r)&lt;&lt;endl; &#125; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P8774 蓝桥杯 2022 省 A] 爬树的甲壳虫 - 洛谷 期望题 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5,mod=998244353;int f[N];int quick(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res%mod;&#125;void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; f[i]=((f[i-1]+1)%mod*((y%mod)*quick(y-x,mod-2)%mod)%mod)%mod; &#125; cout&lt;&lt;f[n]&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"ACM成长","slug":"ACM成长","date":"2025-10-26T11:30:48.000Z","updated":"2025-11-25T15:32:05.778Z","comments":true,"path":"post/a03e0b58.html","permalink":"https://sunjing-coder.github.io/second/post/a03e0b58.html","excerpt":"","text":"模版123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 对浮点的处理const double pi&#x3D;acos(-1,0)&#x2F;&#x2F;或者2*acos(0); [!CAUTION] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf = 0x3f3f3f3f;const double EPS = 1e-8; const int MAX_DEPTH = 20;double jie(double x) &#123; if (x &lt;= 0 || fabs(x - round(x)) &gt; EPS) &#123; return -1; &#125; int n = (int)round(x); if (x &gt; 20) return -1; int res = 1; for (int i = n; i &gt;= 1; i--) &#123; res *= i; &#125; return res;&#125;stack&lt;string&gt; st; bool found = false; bool equals(double a, double b) &#123; return fabs(a - b) &lt; EPS;&#125;void dfs(double x, int depth) &#123; if (found || depth &gt; MAX_DEPTH) &#123; return; &#125; if (equals(x, 3.0)) &#123; found = true; cout &lt;&lt; &quot;YES\\n&quot;; cout &lt;&lt; &quot;操作路径: &quot;; vector&lt;string&gt; path; while (!st.empty()) &#123; path.push_back(st.top()); st.pop(); &#125; reverse(path.begin(), path.end()); for (const auto&amp; op : path) &#123; cout &lt;&lt; op &lt;&lt; &quot; -&gt; &quot;; &#125; cout &lt;&lt; &quot;3\\n&quot;; return; &#125; double next = sqrt(x); if (next &gt; 0) &#123; st.push(&quot;sqrt(&quot; + to_string((int)round(x)) + &quot;)&quot;); dfs(next, depth + 1); if (!found) st.pop(); else return; &#125; next = ceil(x); if (next != x) &#123; st.push(&quot;ceil(&quot; + to_string(x) + &quot;)&quot;); dfs(next, depth + 1); if (!found) st.pop(); else return; &#125; // 尝试阶乘操作 next = jie(x); if (next != -1) &#123; st.push(&quot;jie(&quot; + to_string((int)round(x)) + &quot;)&quot;); dfs(next, depth + 1); if (!found) st.pop(); else return; &#125;&#125;void solve() &#123; dfs(4.0, 0);&#125;signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; // cin &gt;&gt; t; while (t--) &#123; solve(); &#125; return 0;&#125;#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5,MAX_Depth=20;const double eps=1e-8;bool equal(double a,double b)&#123; return fabs(a-b)&lt;eps;&#125;stack&lt;string&gt;st;double jie(double x)&#123; if(x&lt;=0||fabs(x-round(x)&gt;eps))return -1; int n=(int)round(x); if(x&gt;20)return -1; int res=1; for(int i=n;i&gt;=1;i--)&#123; res*=i; &#125; return res;&#125;void dfs(double x,int dep)&#123; if(dep&gt;MAX_Depth)return; if(equal(x,3.0))&#123; queue&lt;string&gt;q; while(!st.empty())&#123; q.push(st.top()); st.pop(); &#125; cout&lt;&lt;&quot;3 :&quot;; while(!q.empty())&#123; cout&lt;&lt;q.front()&lt;&lt;&quot;--&gt;&quot;; q.pop(); &#125; exit(0); &#125; double next=sqrt(x); if(next&gt;0)&#123; st.push(&quot;sqrt&quot;); dfs(next,dep+1); st.pop(); &#125; next=ceil(x); if(next!=x)&#123; st.push(&quot;ceil&quot;); dfs(next,dep+1); st.pop(); &#125; next=jie(x); if(next!=-1)&#123; st.push(&quot;jie&quot;); dfs(next,dep+1); st.pop(); &#125;&#125;void solve()&#123; dfs(4.0,0);&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 取模&#x2F;同余原理&#x2F;求逆元123456789101112131415161718192021222324a ^ b % p = ((a % p)^b) % p (A + B) % mod = ((A % mod) + (B % mod)) % mod(A * B) % mod = ((A % mod) * (B % mod)) % mod//减法取模 (A - B) % mod =((A % mod) - (B % mod) +mod) % mod//除法取模(A / B) % mod = ((A % mod) * (inv(B) % mod)) % mod LL qkpow(LL a,LL p,LL mod)&#123; LL t=1,tt=a%mod; while(p) &#123; if(p&amp;1)t=t*tt%mod; tt=tt*tt%mod; p&gt;&gt;=1; &#125; return t;&#125;LL getInv(LL a,LL mod)&#123; return qkpow(a,mod-2,mod);&#125; 878. 第 N 个神奇数字 - 力扣（LeetCode） 123456789101112131415161718192021//二分答案-&gt;检验答案好统计//简单的容斥原理class Solution &#123;public:long long mod=1e9+7; int nthMagicalNumber(int n, int a, int b) &#123; long long mid; long long l=0,r=(long long)n*min(a,b); long long gcd=__gcd(a,b); long long lcm=a/gcd*b; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if((mid/a+mid/b-mid/lcm)&gt;=n)&#123;//容斥原理 r=mid-1; &#125;else&#123; l=mid+1; &#125; &#125; return (int)(l%mod); &#125;&#125;; 异或运算1234567891011121314151617181.袋子里一共a个白球,b个黑球,每次从袋子里拿2个求,每个球每次被拿出的机会均等,如果拿出的是2个白球或者2个黑球,那么就往袋子里重新放入1个白球,如果拿出的是1个白球和1个黑球,那么就往袋子里重新放入一个黑球,那么最终袋子里只会剩下一个球,请问最终的球是黑的概率是多少? 黑球:1 白球:0 最终球的颜色取决于:黑球数量为奇数概率100% 黑球数量为偶数概率0% 2.异或运算:数值交换 在数组中保证a,b为两个下标不同的数 a=a^b; b=a^b; a=a^b;3.一个数异或上它的相反数:可以得到它仅保留最右侧1的数字状态 4.找在一个数组中出现奇数次数的a和奇数次数的b 先所有异或:得到a^b这个结果 (a^b)^(~(a^b)) 这个结果必然存在某个x数位上为1,故我们再次将数组分为x数位上为1和不为1的,遍历数位x上为1的数最后的结果即为a,b=a^b^a; 位运算201. 数字范围按位与 - 力扣（LeetCode） 12345678910//主要思想是关注保留下来的1class Solution &#123;public: int rangeBitwiseAnd(int left, int right) &#123; while(left&lt;right)&#123; right-=(right&amp;-right); &#125; return right; &#125;&#125;; 190. 颠倒二进制位 - 力扣（LeetCode） 1234567891011121314151617//采用分治思想//abcdefgh//两个为一组,交换组内元素的位置badcfehg//四个为一组,大组内在两个为一小组,交换两个小组dcbahgfe//同理hgfedcba//第一个操作中:&amp;上10101010右移class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; // 使用uint32_t确保无符号性 n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1); n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2); n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4); n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8); n = (n &gt;&gt; 16) | (n &lt;&lt; 16); return n; &#125;&#125;; 461. 汉明距离 - 力扣（LeetCode） 12345678910111213141516//统计一个数的二进制有多少个1//一位中统计1的个数,二位中统计1的个数,四位中统计1的个数,八位中统计1的个数,16位中统计1的个数,最后返回32位中1的个数class Solution &#123;public: int hammingDistance(int x, int y) &#123; return solve(x^y); &#125; int solve(int x)&#123; x=(x&amp;0x55555555)+((x&gt;&gt;1)&amp;0x55555555); x=(x&amp;0x33333333)+((x&gt;&gt;2)&amp;0x33333333); x=(x&amp;0x0f0f0f0f)+((x&gt;&gt;4)&amp;0x0f0f0f0f); x=(x&amp;0x00ff00ff)+((x&gt;&gt;8)&amp;0x00ff00ff); x=(x&amp;0x0000ffff)+((x&gt;&gt;16)&amp;0x0000ffff); return x; &#125;&#125;; 1.贪心123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376////骑士的工作//// //每位骑士只能杀一个头//// //贪心策略:尽量雇花费少的//// #include &lt;bits/stdc++.h&gt;//// using namespace std;//// #define asd(i,a,b) for(int i=a;i&lt;=b;i++)//// #define int long long//// const int inf=0x3f3f3f3f,N = 2e4 + 5;//// int Size[N];//// int v[N];//// void solve()&#123;//// int n,m;//// cin&gt;&gt;n&gt;&gt;m;//// for(int i=1; i&lt;=n; i++)&#123;//// cin&gt;&gt;Size[i];//// &#125;//// for(int i=1; i&lt;=m; i++)&#123;//// cin&gt;&gt;v[i];//// &#125;//// sort(v+1,v+m+1);//// sort(Size+1,Size+n+1);//// int l=1,ans=0,i;//// for(i=1;i&lt;=n;i++)&#123;//// while(l&lt;=m&amp;&amp;Size[i]&gt;v[l])&#123;//// l++;//// &#125;//// if(l&gt;m) break;//// ans+=v[l];//// l++;//// &#125;//// if(i!=n+1)&#123;//// cout&lt;&lt;&quot;you died!&quot;&lt;&lt;endl;//// &#125;//// else cout&lt;&lt;ans&lt;&lt;endl;//// &#125;//// signed main()//// &#123;//// ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);//// int t=1;//// // cin&gt;&gt;t;//// while(t--)&#123;//// solve();//// &#125;//// return 0;//// &#125;////////#include &lt;bits/stdc++.h&gt;//using namespace std;//#define asd(i,a,b) for(int i=a;i&lt;=b;i++)//#define int long long//const int inf=0x3f3f3f3f,N = 1e6 + 5;//int a[N];//void solve()&#123;// int n;// cin&gt;&gt;n;// for(int i=1;i&lt;=n;i++)&#123;// cin&gt;&gt;a[i];// &#125;// int ans=0,l=1;// while(l&lt;=n)&#123;// if(ans%2==0)&#123;// while(a[l]==0&amp;&amp;l&lt;=n)l++;// &#125;else&#123;// while(a[l]==1&amp;&amp;l&lt;=n)l++;// &#125;// ans++;// &#125;// cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;//&#125;//signed main()//&#123;// ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);// int t=1;// // cin&gt;&gt;t;// while(t--)&#123;// solve();// &#125;// return 0;//&#125;//一个人可能与多个人说话(1),但不一定会和周围的人说话(2)//若用两两标记则与(1)相悖,标记被打乱,若只要标记就认为他们一定会说话则与(2) 相悖 //#include &lt;bits/stdc++.h&gt;//using namespace std;//#define asd(i,a,b) for(int i=a;i&lt;=b;i++)//#define int long long//const int inf=0x3f3f3f3f,N = 1e3+ 5;//int mark[N][N];//struct B&#123;// int num;// int cnt=0;//&#125;r[2005],c[2005];//bool cmp(B a,B b)&#123;// return a.cnt&gt;b.cnt;//&#125;//bool cmp1(B a,B b)&#123;// return a.num&lt;b.num;//&#125;//void solve()&#123;// int m,n,k,l,d;// cin&gt;&gt;m&gt;&gt;n&gt;&gt;k&gt;&gt;l&gt;&gt;d;// for(int i=1;i&lt;=d;i++)&#123;// int x,y,x1,y1;// cin&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1;// if(x==x1)&#123;// c[min(y,y1)].num=min(y,y1);// c[min(y,y1)].cnt++;// &#125;// if(y==y1)&#123;// r[min(x,x1)].num=min(x,x1);// r[min(x,x1)].cnt++;// &#125;// &#125;// sort(r+1,r+m+1,cmp);// sort(c+1,c+n+1,cmp);// sort(r+1,r+k+1,cmp1);// sort(c+1,c+l+1,cmp1);// for(int i=1;i&lt;=k-1;i++)&#123;// cout&lt;&lt;r[i].num&lt;&lt;&quot; &quot;;// &#125;// cout&lt;&lt;r[k].num&lt;&lt;&#x27;\\n&#x27;;// for(int i=1;i&lt;=l-1;i++)&#123;// cout&lt;&lt;c[i].num&lt;&lt;&quot; &quot;;// &#125;// cout&lt;&lt;c[l].num&lt;&lt;endl;//&#125;////signed main()//&#123;// ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);// int t=1;// // cin&gt;&gt;t;// while(t--)&#123;// solve();// &#125;// return 0;//&#125;//P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e4 + 5;void solve()&#123; int n,a; cin&gt;&gt;n; //创建优先队列从小到大排序 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a; pq.push(a); &#125; int ans=0; while(pq.size()&gt;1)&#123; int x=pq.top(); pq.pop(); int y=pq.top(); pq.pop(); ans+=x+y; pq.push(x+y); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1106 删数问题#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123; string s; int k; cin&gt;&gt;s&gt;&gt;k; stack&lt;char&gt; st; char x; for(int i=0;i&lt;s.size();i++)&#123; if(!st.empty())x=st.top(); else&#123; st.push(s[i]); continue; &#125; if(s[i]&lt;x&amp;&amp;k&gt;0)&#123; st.pop(); k--; i--; //i--是因为此处的i值还应与st中的top()进行比较 //从而让st中的数值呈现递减的状态 &#125; else st.push(s[i]); &#125; while(k--)&#123; st.pop(); //删完k个数 &#125; stack&lt;char&gt; st1; while(!st.empty())&#123; st1.push(st.top()); st.pop(); //将st中的数值倒序存入st1中,以便删除前导零 &#125; while(!st1.empty()&amp;&amp;st1.top()==&#x27;0&#x27;)&#123; st1.pop(); //删除前导零 &#125; string ans=&quot;&quot;; if(st1.empty())&#123; cout&lt;&lt;0&lt;&lt;endl; return; &#125; while(!st1.empty())&#123; ans+=st1.top(); st1.pop(); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//最完全的替换//找到t中第一个出现1的位置//贪心策略:从高位到低位遍历#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;void solve()&#123; int n,m,first=0; cin&gt;&gt;n&gt;&gt;m; string s,t; cin&gt;&gt;s&gt;&gt;t; for(int i=0;i&lt;m;i++)&#123; if(t[i]==&#x27;1&#x27;)&#123; first=i; break; &#125; &#125; int len = m-first-1; int ans=0; for(int i=0;i&lt;n;i++)&#123; if(s[i]==&#x27;1&#x27;&amp;&amp;i+len&lt;n)&#123; ans++; for(int j=first;j&lt;m;j++)&#123; if(t[j]==s[i+j-first])&#123; s[i+j-first]=&#x27;0&#x27;; &#125;else s[i+j-first]=&#x27;1&#x27;; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(s[i]==&#x27;1&#x27;)&#123; cout&lt;&lt;&quot;-1\\n&quot;; return ; &#125; &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//子序列//保持区间最大,减去杂数#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e6 + 5;int a[N], pos[N];void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; pos[a[i]]=i; &#125; int ans=1,mn=pos[n],mx=pos[n]; for(int i=n-1;i&gt;=1;i--)&#123; mn=min(mn,pos[i]),mx=max(mx,pos[i]); ans=max(ans,mx-mn+1-(n-i-1)); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1843 奶牛晒衣服//为什么会想到二分答案:求的是晒每件衣服中所花费时间中最大时间的最小值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 5e5 + 5;int n,a,b;int w[N];bool check(int x)&#123; //x即是最大的花费时间,也是烘干能使用的最大次数 //那些地方必须的用烘干才用,若用超了这说明不行 int cnt=0; for(int i=1;i&lt;=n;i++)&#123; int re=max(0ll,w[i]-x*a); if(re==0)continue; cnt+=re/b+(re%b==0?0:1); if(cnt&gt;x)return false; &#125; return true;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i]; int l=0,r=5e5+1; while(l&lt;=r)&#123; int mid=l+(r-l)/2; if(check(mid))&#123; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 2.01背包 搞清楚谁是容积谁是价值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//P1048 [NOIP 2005 普及组] 采药#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e2 + 5;int ttime[N],val[N],dp[1005];void solve()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;ttime[i]&gt;&gt;val[i]; &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=t;j&gt;=ttime[i];j--)&#123; dp[j]=max(dp[j],dp[j-ttime[i]]+val[i]); &#125; &#125; cout&lt;&lt;dp[t]&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1060 [NOIP 2006 普及组] 开心的金明#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 3e4 + 5;int w[30],v[30],dp[N];//w是价格,v代表价格和重要度的乘积void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; v[i]=w[i]*v[i]; &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=n;j&gt;=w[i];j--)&#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125; cout&lt;&lt;dp[n]&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1164 小A点菜//计数背包#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int a[N],dp[10005];//dp表是花费i元时的点菜总方案数void solve()&#123; int n,m,p; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; dp[0]=1; //我们不进行任何操作时,便可知结果的(隐藏条件告知),花费0元时的总方案为1 //当dp[4]=dp[4]+dp[4-4]时,故可知dp[0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=m;j&gt;=a[i];j--)&#123; dp[j]=dp[j]+dp[j-a[i]]; &#125; &#125; cout&lt;&lt;dp[m]&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1734 最大约数和//s是容积,每个数是体积,每个数约数和是价值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int a[1005],dp[1005];//dp[i]i表示选的这几个数的和在i以内,dp[i]表示选的这几个数的约数和的最大值void solve()&#123; int s; cin&gt;&gt;s; for(int i=1;i&lt;=s;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(i%j==0)&#123; a[i]+=j; &#125; &#125; &#125; for(int i=1;i&lt;=s;i++)&#123; for(int j=s;j&gt;=i;j--)&#123; dp[j]=max(dp[j],dp[j-i]+a[i]); &#125; &#125; cout&lt;&lt;dp[s]&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1507 NASA的食物计划#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 400 + 5;int dp[N][N];struct node&#123; int h,t,k;&#125;a[55];void solve()&#123; int H,T,n; cin&gt;&gt;H&gt;&gt;T&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i].h&gt;&gt;a[i].t&gt;&gt;a[i].k; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=H;j&gt;=a[i].h;j--)&#123; for(int x=T;x&gt;=a[i].t;x--)&#123; dp[j][x]=max(dp[j][x],dp[j-a[i].h][x-a[i].t]+a[i].k); &#125; &#125; &#125; cout&lt;&lt;dp[H][T]&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 3.最短路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259//dijkstraint dis[N],vis[N],f[N][N];//dis用于记录从起点到i的最短路,vis标记是否用过,f用于存储前驱到后驱的权值//n为n个点void dijkstra() &#123; //初始化 memset(dis,inf,sizeof(dis)); dis[s]=0;//起点到自己当然是0 for(int i=1; i&lt;=n; i++) &#123; int t=-1;//用于找第一个未被标记的点 for(int j=1; j&lt;=n; j++) if(!vis[j] &amp;&amp; (t==-1 || dis[j]&lt;dis[t])) t=j;//未标记或找到更近的 vis[t]=1;//标记，防止再次计算 for(int j=1; j&lt;=n; j++) &#123; dis[j] = min(dis[j],dis[t]+f[t][j]); &#125; &#125;&#125;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt;&gt; g[N]; struct Node &#123; int x, w; // x表示点编号，w表示源点到x的最短距离 bool operator&lt;(const Node&amp; u) const &#123; return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶 &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123; // 初始化距离数组为无穷大 memset(dis, inf, sizeof(dis)); // 初始化访问标记数组为false memset(vis, 0, sizeof(vis)); pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0 while (!pq.empty()) &#123; // 只要队列不为空 auto [x, w] = pq.top(); pq.pop(); // 取出队头元素 if (vis[x]) continue; // 如果走过直接跳过 vis[x] = 1; // 标记为走过 for (const auto &amp;[y, dw] : g[x]) &#123; // x-&gt;y, 边权为dw的边 if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键 dis[y] = dis[x] + dw; pq.push(&#123;y, dis[y]&#125;); &#125; &#125; &#125;&#125;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt; &gt; g[N]; struct Node &#123; int x, w; // x表示点编号，w表示源点到x的最短距离 bool operator&lt;(const Node&amp; u) const &#123; return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶 &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123; // 初始化距离数组为无穷大 memset(dis, inf, sizeof(dis)); // 初始化访问标记数组为false memset(vis, 0, sizeof(vis)); pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0 while (!pq.empty()) &#123; // 只要队列不为空 int x= pq.top().x; pq.pop(); // 取出队头元素 if (vis[x]) continue; // 如果走过直接跳过 vis[x] = 1; // 标记为走过 for (int i=0;i&lt;g[x].size();i++) &#123; // x-&gt;y, 边权为dw的边 int y=g[x][i].first; int dw=g[x][i].second; if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键 dis[y] = dis[x] + dw; pq.push(&#123;y, dis[y]&#125;); &#125; &#125; &#125;&#125;//P1359 租用游艇#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int dis[10005],vis[10005],f[10001][10001];int n,s=1;void dijkstra() &#123; //初始化 memset(dis,inf,sizeof(dis)); dis[s]=0;//起点到自己当然是0 for(int i=1; i&lt;=n; i++) &#123; int t=-1;//用于找第一个未被标记的点 for(int j=1; j&lt;=n; j++) if(!vis[j] &amp;&amp; (t==-1 || dis[j]&lt;dis[t])) t=j;//未标记或找到更近的 vis[t]=1;//标记，防止再次计算 for(int j=1; j&lt;=n; j++) &#123; dis[j] = min(dis[j],dis[t]+f[t][j]); &#125; &#125;&#125;void solve()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(i==j) f[i][j]=0; else f[i][j]=inf; &#125; &#125; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; cin&gt;&gt;f[i][j]; &#125; &#125; dijkstra(); cout&lt;&lt;dis[n]&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//堆优化之后,此题是有向图,即从站点1出发不可在站点1停靠#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e2 + 5;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt;&gt; g[N]; struct Node &#123; int x, w; // x表示点编号，w表示源点到x的最短距离 bool operator&lt;(const Node&amp; u) const &#123; return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶 &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123; // 初始化距离数组为无穷大 memset(dis, inf, sizeof(dis)); // 初始化访问标记数组为false memset(vis, 0, sizeof(vis)); pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0 while (!pq.empty()) &#123; // 只要队列不为空 auto [x, w] = pq.top(); pq.pop(); // 取出队头元素 if (vis[x]) continue; // 如果走过直接跳过 vis[x] = 1; // 标记为走过 for (const auto &amp;[y, dw] : g[x]) &#123; // x-&gt;y, 边权为dw的边 if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键 dis[y] = dis[x] + dw; pq.push(&#123;y, dis[y]&#125;); &#125; &#125; &#125;&#125;void solve()&#123; int n,w; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; cin&gt;&gt;w; g[i].push_back(&#123;j,w&#125;); &#125; &#125; dijkstra(1); cout&lt;&lt;dis[n]&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1629 邮递员送信#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt;&gt; g[N]; struct Node &#123; int x, w; // x表示点编号，w表示源点到x的最短距离 bool operator&lt;(const Node&amp; u) const &#123; return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶 &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123; // 初始化距离数组为无穷大 memset(dis, inf, sizeof(dis)); // 初始化访问标记数组为false memset(vis, 0, sizeof(vis)); pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0 while (!pq.empty()) &#123; // 只要队列不为空 auto [x, w] = pq.top(); pq.pop(); // 取出队头元素 if (vis[x]) continue; // 如果走过直接跳过 vis[x] = 1; // 标记为走过 for (const auto &amp;[y, dw] : g[x]) &#123; // x-&gt;y, 边权为dw的边 if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键 dis[y] = dis[x] + dw; pq.push(&#123;y, dis[y]&#125;); &#125; &#125; &#125;&#125;void solve()&#123; int n,m,u,v,w; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; g[u].push_back(&#123;v,w&#125;); &#125; dijkstra(1); int ans=0; for(int i=2;i&lt;=n;i++)&#123; ans+=dis[i]; &#125; for(int i=2;i&lt;=n;i++)&#123; dijkstra(i); ans+=dis[1]; &#125; cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 4.区间求中位数:前缀和+哈希表123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e3 + 5;int a[N],sum[N],s[2*N];void solve()&#123; int n,ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++)&#123; memset(s,0,sizeof(s)); for(int j=1;j&lt;=n;j++)&#123; if(a[j]&lt;a[i])&#123; sum[j]=sum[j-1]+(-1); &#125;else if(a[j]&gt;a[i])&#123; sum[j]=sum[j-1]+1; &#125;else &#123; sum[j]=sum[j-1]; &#125; &#125; sum[0]=0; for(int j=0;j&lt;i;j++)&#123; s[sum[j]+2001]+=j+1; &#125; for(int j=i;j&lt;=n;j++)&#123; ans+=j*s[sum[j]+2001]*a[i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 5.二分最大值最小化,最小值最大化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485//找到数xint binary_search(int l,int r,int x)&#123; while(l&lt;=r)&#123; int mid=(l+r)/2; if(a[mid]==x)&#123; return mid; &#125; else if(a[mid]&gt;x)&#123; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; return -1;&#125;//找到第一个x的位置,尽量往左找int binary_search(int l,int r,int x)&#123; while(l&lt;r)&#123; int mid=l+(r-l)/2; if(check(mid))&#123; r=mid; &#125;else &#123; l=mid+1; &#125; &#125; if(a[l]==x)return l; return -1;&#125;//尽量往右找int binary_search(int l,int r,int x)&#123; while(l&lt;r)&#123; int mid=l+(r-l)/2; if(check(mid))&#123; l=mid; &#125;else &#123; r=mid-1; &#125; &#125; if(a[l]==x)return l; return -1;&#125;//浮点二分double bsearch(double l, double r)&#123; const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) // 两种写法：此时是用精度控制循环次数，直接控制循环100次也是OK的！ &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; //二分答案int l=0,r=100000000;//把左端与右端定义，这个地方有些题范围不能开太大，有一定的要求，不过这里就OK了while(l&lt;=r)&#123; int mid=(l+r)/2; if(judge(mid))//判断步骤 l=mid+1; else r=mid-1;//有些题这里有微调……不过不影响 &#125; cout&lt;&lt;r; //P1577 切绳子#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6+ 5;int a[N];int n,k;bool judge(int x)&#123; int ans=0; for(int i=1;i&lt;=n;i++)&#123; ans+=a[i]/x; &#125; if(ans&gt;=k) return true; else return false;&#125;int binary_search(int l,int r)&#123; while(l&lt;=r)&#123; int mid=(l+r)/2; if(mid==0) break; if(judge(mid)) l=mid+1; else r=mid-1; &#125; return r;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;k; double b; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;b; a[i]=(int)(b*100); &#125; int ans=binary_search(0,10000000); printf(&quot;%0.2f&quot;,ans/100.0);&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1182 数列分段 Section II#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int a[N];int n,m;bool check(int x)&#123; int sum=0,cnt=1; for(int i=1;i&lt;=n;i++)&#123; if(a[i]+sum&gt;x)&#123; sum=a[i]; cnt++; &#125;else &#123; sum+=a[i]; &#125; &#125; if(cnt&gt;m) return true; return false;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;m; int r=0,l=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; r+=a[i]; l=max(l,a[i]); &#125; while(l&lt;=r)&#123; int mid=l+(r-l)/2; if(check(mid))&#123; l=mid+1; &#125;else&#123; r=mid-1; &#125; &#125; cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1281 [CERC1998] 书的复制//与上一题的思路基本一致,只是最后从后往前遍历,保证越往前抄的越少#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int a[N];int m,k;bool check(int x)&#123; int sum=0,cnt=1; for(int i=1;i&lt;=m;i++)&#123; if(a[i]+sum&gt;x)&#123; sum=a[i]; cnt++; &#125;else &#123; sum+=a[i]; &#125; &#125; if(cnt&gt;k) return true; return false;&#125;void solve()&#123; cin&gt;&gt;m&gt;&gt;k; int r=0,l=0; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a[i]; r+=a[i]; l=max(l,a[i]); &#125; while(l&lt;=r)&#123; int mid=l+(r-l)/2; if(check(mid))&#123; l=mid+1; &#125;else&#123; r=mid-1; &#125; &#125; stack&lt;pair&lt;int,int&gt; &gt;st; int sum=0,ansr=m; for(int i=m;i&gt;=1;i--)&#123; if(a[i]+sum==l)&#123; sum=0; st.push(&#123;i,ansr&#125;); ansr=i-1; &#125;else if(a[i]+sum&gt;l)&#123; sum=a[i]; st.push(&#123;i+1,ansr&#125;); ansr=i; &#125;else &#123; sum+=a[i]; if(i==1)&#123; st.push(&#123;i,ansr&#125;); &#125; &#125; &#125; while(!st.empty())&#123; auto [l,r]=st.top(); st.pop(); cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; &#125; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1396 营救#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e4+5;//N一开始开大了导致MLEint n,m,s,t;int vis[N];//一开始没开vis数组导致TLEvector&lt;pair&lt;int,int&gt;&gt;g[N];bool check(int x)&#123; //bfs memset(vis,0,sizeof(vis)); queue&lt;int&gt;q; q.push(s); vis[s]=1; while(!q.empty())&#123; int u=q.front(); if(u==t)return true; q.pop(); for(auto [v,w]:g[u])&#123; if(vis[v])continue; if(w&gt;x)continue; q.push(v);vis[v]=1; &#125; &#125; return false;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; int l=0,r=0; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; r=max(r,w); //无向图 g[u].push_back(&#123;v,w&#125;); g[v].push_back(&#123;u,w&#125;); &#125; while(l&lt;=r)&#123; int mid = (l+r)&gt;&gt;1; if(check(mid))&#123; r=mid-1; &#125; else &#123; l=mid+1; &#125; &#125; cout&lt;&lt;l&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1570 KC 喝咖啡//难点:公式变形,变形之后如何往二分答案上靠//∑(1,m)c*x-∑(1,m)*v=0,我们只需尽可能的让式子的左侧尽可能的靠近0//也就是说我们选择的c[i]*x-v[i]要尽可能的小,所以贪心排序,选择前m个较小的c[i]*x-v[i]#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e2 + 5;int n,m;struct node&#123; int v,c; double val; bool operator&lt;(const node &amp;a)const&#123; return val&lt;a.val; &#125;&#125;a[N];bool check(double x)&#123; for(int i=1;i&lt;=n;i++)a[i].val=x*a[i].c-a[i].v; sort(a+1,a+1+n); double sum=0; for(int i=1;i&lt;=m;i++)&#123; sum+=a[i].val; &#125; return sum&lt;=0;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].v; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].c; //浮点二分模版 double l=0,r=1000; while(r-l&gt;1e-6)&#123; double mid=(l+r)/2; if(check(mid))&#123; l=mid; &#125;else&#123; r=mid; &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1661 扩散//为什么用二分答案:这道题求得是两点之间花费时间的最大值中的最小值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 50 + 5;int n;int bseach[N];vector&lt;pair&lt;int,int&gt;&gt;v(N);//判断是否连通:并查集int find(int x)&#123; if(bseach[x]==x)return x; return bseach[x]=find(bseach[x]);&#125;bool check(int x)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; int a=abs(v[i].first - v[j].first); int b=abs(v[i].second - v[j].second); //a+b为两点之间的连通所花费时间的两倍(两个点都可以扩散) if(a+b&lt;=2*x)&#123; int fa=find(i),fb=find(j); if(fa!=fb)&#123; bseach[fa]=fb; &#125; &#125; &#125; &#125; int cnt=0; for(int i=0;i&lt;n;i++)&#123; if(bseach[i]==i)&#123; cnt++; &#125; &#125; //当x很大时,所有点都连通 if(cnt==1)&#123; return true; &#125;else &#123; return false; &#125;&#125;void solve()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;v[i].first&gt;&gt;v[i].second; &#125; //二分答案模版 int l=0,r=1e9+10; while(l&lt;=r)&#123; int mid=l+(r-l)/2; for(int i=0;i&lt;n;i++)&#123; bseach[i]=i; &#125; if(check(mid))&#123; r=mid-1; &#125;else &#123; l=mid+1; &#125; &#125; cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;//P1843 奶牛晒衣服//为什么会想到二分答案:求的是晒每件衣服中所花费时间中最大时间的最小值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 5e5 + 5;int n,a,b;int w[N];bool check(int x)&#123; //哪些地方必须得用烘干才用,若用超了这说明不行 //x既代表了花费的最大时间,也代表了最多可使用的烘干次数 int cnt=0; for(int i=1;i&lt;=n;i++)&#123; int re=max(0ll,w[i]-x*a); //在x的时间内若可直接晒干,则直接跳过 if(re==0)continue; //记录烘干次数 cnt+=re/b+(re%b==0?0:1); if(cnt&gt;x)return false; &#125; return true;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i]; int l=0,r=5e5+1; while(l&lt;=r)&#123; int mid=l+(r-l)/2; if(check(mid))&#123; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 6.双指针+模拟12345678910111213141516171819202122232425262728293031323334353637383940414243444546//P1638 逛画展#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int a[N],b[2005],cnt;void in(int x)&#123; if(b[x]==0)cnt++; b[x]++;&#125;void d(int x)&#123; if(b[x]==1)cnt--; b[x]--;&#125;void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; int l=1,ans=inf,ansl=1,ansr=n; for(int i=1;i&lt;=n;i++)&#123; in(a[i]); while(true)&#123; d(a[l]); if(cnt==m)l++; else &#123; in(a[l]); break; &#125; &#125; if(cnt==m&amp;&amp;i-l+1&lt;ans)ans=i-l+1,ansl=l,ansr=i; &#125; cout&lt;&lt;ansl&lt;&lt;&quot; &quot;&lt;&lt;ansr&lt;&lt;endl; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 7.最小生成树Kruskal算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091struct Edge &#123; int x, y, c; bool operator&lt; (const Edge &amp;u) const &#123; return c &lt; u.c; &#125;&#125;;int pre[N];int root(int x) &#123; return pre[x] == x ? x : root(pre[x]);&#125;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;Edge&gt; es; for(int i = 1; i &lt;= m; ++ i) &#123; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; es.push_back(&#123;x, y, c&#125;); &#125; sort(es.begin(), es.end()); for(int i = 1; i &lt;= n; ++ i) pre[i] = i; int ans = 0; for(const auto&amp; [x, y, c] : es) &#123; if(root(x) == root(y)) continue; ans = max(ans, c); pre[root(x)] = root(y); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;//P1661 扩散//点之间的最短时间是确定的,我们要找出最短时间的最大值//连通且最短时间确定,故用最小生成树#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;struct Edge &#123; int x, y, c; bool operator&lt; (const Edge &amp;u) const &#123; return c &lt; u.c; &#125;&#125;;int pre[N];int root(int x) &#123; return pre[x] == x ? x : root(pre[x]);&#125;void solve() &#123; int n; cin &gt;&gt; n ; vector&lt;Edge&gt; es; vector&lt;pair&lt;int,int&gt;&gt;d; for(int i = 0; i &lt; n; ++ i) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; d.push_back(&#123;x,y&#125;); &#125; //kruskal模版 for(int i = 0; i &lt; n; ++ i) &#123; for(int j=i+1;j&lt;n;++j)&#123; int c = (abs(d[i].first - d[j].first)+abs(d[i].second - d[j].second)+1)/2;//计算时间 //曼哈顿距离为奇数时:c=dis/2+1=(dis+1)/2 es.push_back(&#123;i, j, c&#125;); &#125; &#125; sort(es.begin(), es.end()); for(int i = 0; i &lt; n; ++ i) pre[i] = i; int ans = 0; for(const auto&amp; [x, y, c] : es) &#123; if(root(x) == root(y)) continue; ans = max(ans, c); pre[root(x)] = root(y); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; Prim算法12345678910111213141516171819202122232425262728293031323334struct Edge &#123; ll x, c; bool operator&lt; (const Edge &amp;u) const &#123; return c == u.c ? x &gt; u.x : c &lt; u.c; &#125;&#125;;vector&lt;Edge&gt; g[N];ll d[N];int n, m;int prim() &#123; priority_queue&lt;Edge&gt; pq; bitset&lt;N&gt; vis; d[1] = 0; pq.push(&#123;1, d[1]&#125;); ll res = 0; while(pq.size()) &#123; int x = pq.top().x; pq.pop(); if(vis[x]) continue; vis[x] = true; res = max(res, d[x]); for(const auto &amp;[y, w] : g[x]) &#123; if(!vis[y]) &#123; d[y] = min(d[y], w); pq.push(&#123;y, d[y]&#125;); &#125; &#125; &#125; return res;&#125; 8.并查集1234int root(int x) &#123; if (pre[x] == x) return x; // 如果当前节点是自身的父节点，则它是根节点 return root(pre[x]); // 否则，递归地查找父节点的根&#125; 路径压缩优化123int root(int x) &#123; return pre[x] = (pre[x] == x ? x : root(pre[x])); // 路径压缩，将沿途节点直接指向根节点&#125; 合并操作12345678910111213void merge(int x, int y) &#123; int rx = root(x), ry = root(y); // 找到两个节点的根节点 if (rx == ry) return; // 如果两个根节点相同，则无需合并 // 如果rx所在集合更大，则交换rx和ry，以保证rx所在集合的大小不超过ry所在集合 if (siz[rx] &gt; siz[ry]) swap(rx, ry); // 将rx所在集合合并到ry所在集合中 pre[rx] = ry; // 将rx的根节点指向ry siz[ry] += siz[rx]; // 更新ry所在集合的大小 // 合并完成后，rx将不再作为根节点，其大小信息也失去了意义&#125; 947. 移除最多的同行或同列石头 - 力扣（LeetCode）12345678910111213141516171819202122232425262728293031323334353637383940414243444546//从边缘到中心逐渐消减石头//最后发现属于一个集合的只会剩下一块石头class Solution &#123;public:int father[1001];int siz[1001];int mpx[10001];int mpy[10001]; int root(int x) &#123; return father[x] = (father[x] == x ? x : root(father[x])); &#125; void merge(int x,int y)&#123; int rx=root(x),ry=root(y); if(rx==ry)return ; if(siz[rx]&gt;siz[ry])swap(rx,ry); father[rx]=ry; siz[ry]+=siz[rx]; &#125; int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) &#123; int n=stones.size(); for(int i=1;i&lt;=n;i++)&#123; father[i]=i; &#125; for(int i=0;i&lt;n;i++)&#123; int x=stones[i][0]; int y=stones[i][1]; if(mpx[x]==0)&#123; mpx[x]=i+1; &#125;else&#123; merge(mpx[x],i+1); &#125; if(mpy[y]==0)&#123; mpy[y]=i+1; &#125;else&#123; merge(mpy[y],i+1); &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; if(father[i]==i)ans++; &#125; return n-ans; &#125;&#125;; P1111 修复公路 - 洛谷&#x2F;&#x2F;需要在合并的时候判断: 若两个集合的father相同那么就判一下他们father的siz集合个数是否达到n, 若两个集合的father不同,那么就一定没有实现所有元素在一个集合,故对他们进行合并.合并后在判断是否集合个数达到n,即所有元素在同一个集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;struct node&#123; int x,y,t;&#125;arr[N];bool cmp(node a,node b)&#123; return a.t&lt;b.t;&#125;int father[1005],siz[1005],n,m;;int root(int x)&#123; if(x==father[x])return x; return father[x]=root(father[x]);&#125;bool merge(int x,int y)&#123; int fx=root(x),fy=root(y); if(fx==fy)&#123;//father相同 if(siz[fx]==n)&#123; return true; &#125; return false; &#125; //father不同 if(siz[fx]&gt;siz[fy])&#123; swap(fx,fy); &#125; father[fx]=fy; siz[fy]+=siz[fx]; if(siz[fy]==n)&#123; return true; &#125; return false;&#125;void solve()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;arr[i].x&gt;&gt;arr[i].y&gt;&gt;arr[i].t; &#125; sort(arr+1,arr+m+1,cmp); for(int i=1;i&lt;=n;i++)&#123; father[i]=i; siz[i]=1; &#125; for(int i=1;i&lt;=m;i++)&#123; if(merge(arr[i].x,arr[i].y))&#123; cout&lt;&lt;arr[i].t&lt;&lt;endl; return; &#125; &#125; cout&lt;&lt;-1&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P3958 NOIP 2017 提高组] 奶酪 - 洛谷&#x2F;&#x2F;思路就是:将能够相交的划分为一组,然后将存放坐标的数组依据z值从小到大排序,l从小到大跑,rr从大到小跑,如果满足arr[l].z-r&lt;&#x3D;0并且arr[rr].z+r&gt;&#x3D;h则说明上下连通,接着判断二者是否连通即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;struct node&#123; int x,y,z,id;&#125; arr[N];bool cmp(node a,node b)&#123; return a.z&lt;b.z;&#125;int father[N],siz[N];int root(int x)&#123; if(father[x]==x)return x; return father[x]=root(father[x]);&#125;void merge(int x,int y)&#123; int fx=root(x),fy=root(y); if(fx==fy)return ; if(siz[fx]&gt;siz[fy])&#123; swap(fx,fy); &#125; father[fx]=fy; siz[fy]+=siz[fx];&#125;void solve()&#123; memset(father,0,sizeof(father)); memset(siz,0,sizeof(siz)); int n,h,r; cin&gt;&gt;n&gt;&gt;h&gt;&gt;r; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i].x&gt;&gt;arr[i].y&gt;&gt;arr[i].z; father[i]=i; siz[i]=1; arr[i].id=i; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(abs((arr[i].x-arr[j].x)*(arr[i].x-arr[j].x)+(arr[i].y-arr[j].y)*(arr[i].y-arr[j].y)+(arr[i].z-arr[j].z)*(arr[i].z-arr[j].z))&lt;=4*r*r)&#123; merge(i,j); &#125; &#125; &#125; sort(arr+1,arr+1+n,cmp); for(int l=1;l&lt;=n;l++)&#123; for(int rr=n;rr&gt;=l;rr--)&#123;//一开始rr写成r,导致错误 if((arr[l].z-r)&lt;=0&amp;&amp;(arr[rr].z+r&gt;=h))&#123; if(root(arr[l].id)==root(arr[rr].id))&#123; cout&lt;&lt;&quot;Yes\\n&quot;; return; &#125; &#125;else&#123; break; &#125; &#125; &#125; cout&lt;&lt;&quot;No\\n&quot;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P1525 NOIP 2010 提高组] 关押罪犯 - 洛谷&#x2F;&#x2F;这道题我忽略的点: 只有两所监狱 &#x2F;&#x2F;所以怨气值越大的肯定就越要分开,所以对怨气值进行从大到小的排序, &#x2F;&#x2F;从大到小遍历怨气值,如果遍历到的两个犯人已经被分配到同一个监狱则输出二人的怨气值即可 &#x2F;&#x2F;若没有被分配到同一个监狱,他们互为敌人,则分别将他们敌人的敌人与他们自己合并(分配到同一个监狱), &#x2F;&#x2F;用b[i]记录i的敌人代表(开始b[i]为0,则将第一个敌人赋给b[i]) [!CAUTION] 当m&#x3D;1时需进行特判,原因是因为它并没有机会在循环中输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int f[20005],e[20005];struct node&#123; int a,b,c;&#125;arr[100005];bool cmp(node a,node b)&#123; return a.c&gt;b.c;&#125;int find(int x)&#123; if(f[x]==x)return x; return f[x]=find(f[x]);&#125;void merge(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy)return; f[fx]=fy;&#125;void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;arr[i].a&gt;&gt;arr[i].b&gt;&gt;arr[i].c; &#125; if(m==1)&#123; cout&lt;&lt;0&lt;&lt;&#x27;\\n&#x27;; return ; &#125; for(int i=1;i&lt;=n;i++)&#123; f[i]=i; &#125; sort(arr+1,arr+1+m,cmp); for(int i=1;i&lt;=m;i++)&#123; if(find(arr[i].a)==find(arr[i].b))&#123; cout&lt;&lt;arr[i].c&lt;&lt;endl; return; &#125;else&#123; if(!e[arr[i].a])&#123; e[arr[i].a]=arr[i].b; &#125;else&#123; merge(arr[i].b,e[arr[i].a]); &#125; if(!e[arr[i].b])&#123; e[arr[i].b]=arr[i].a; &#125;else&#123; merge(arr[i].a,e[arr[i].b]); &#125; &#125; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P4185 USACO18JAN] MooTube G - 洛谷&#x2F;&#x2F;这道题给我的教训是: 我的贪心的思维很差 &#x2F;&#x2F;贪心思路(+离线思路): 先把k值大的数量统计(该合并的合并),则k值小的包含k值大的答案 遍历r的思路是: 从大到小,则每次的r都是各点到其他点的最小可能r(其他比r大的R所关联的点已连接) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;struct node1&#123; int p,q,r;&#125;arr[N];struct node2&#123; int k,v,id;&#125;brr[N];int ans[N];bool cmp1(node1 a,node1 b)&#123; return a.r&gt;b.r;&#125;bool cmp2(node2 a,node2 b)&#123; return a.k&gt;b.k;&#125;int pre[N],siz[N];int root(int x) &#123; return pre[x] = (pre[x] == x ? x : root(pre[x])); // 路径压缩，将沿途节点直接指向根节点&#125;void merge(int x, int y) &#123; int rx = root(x), ry = root(y); // 找到两个节点的根节点 if (rx == ry) return; // 如果两个根节点相同，则无需合并 // 如果rx所在集合更大，则交换rx和ry，以保证rx所在集合的大小不超过ry所在集合 if (siz[rx] &gt; siz[ry]) swap(rx, ry); // 将rx所在集合合并到ry所在集合中 pre[rx] = ry; // 将rx的根节点指向ry siz[ry] += siz[rx]; // 更新ry所在集合的大小 // 合并完成后，rx将不再作为根节点，其大小信息也失去了意义&#125;void solve()&#123; int N,Q; cin&gt;&gt;N&gt;&gt;Q; for(int i=1;i&lt;N;i++)&#123; cin&gt;&gt;arr[i].p&gt;&gt;arr[i].q&gt;&gt;arr[i].r; &#125; for(int i=1;i&lt;=Q;i++)&#123; cin&gt;&gt;brr[i].k&gt;&gt;brr[i].v; brr[i].id=i; &#125; for(int i=1;i&lt;=N;i++)&#123; pre[i]=i; siz[i]=1; &#125; sort(arr+1,arr+1+N,cmp1); sort(brr+1,brr+1+Q,cmp2); int j=1; for(int i=1;i&lt;=Q;i++)&#123; while(j&lt;N&amp;&amp;arr[j].r&gt;=brr[i].k)&#123; merge(arr[j].p,arr[j].q); j++; &#125; ans[brr[i].id]=siz[root(brr[i].v)]; &#125; for(int i=1;i&lt;=Q;i++)&#123; cout&lt;&lt;ans[i]-1&lt;&lt;&quot;\\n&quot;; &#125; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P2024 NOI2001] 食物链 - 洛谷 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//种类并查集#include &lt;cstdio&gt;inline int read() &#123; char c = getchar(); int n = 0; while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; c = getchar(); &#125; while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + (c &amp; 15); c = getchar(); &#125; return n;&#125;const int maxN = 100005;int n, m, ans, fa[maxN * 3];int find(int u) &#123; return fa[u] == u ? u : fa[u] = find(fa[u]); &#125;/* * 主函数，处理输入数据并执行集合操作 * 使用并查集实现关系判断和合并 * 处理两种操作：opt=1 表示同类关系，opt=2 表示捕食关系 */int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n * 3; i++) &#123; fa[i] = i; &#125; for (; m; m--) &#123; int opt = read(), u = read(), v = read(); if (u &gt; n || v &gt; n) &#123; ans++; continue; &#125; if (opt == 1) &#123; if (find(u + n) == find(v) || find(u) == find(v + n)) &#123; ans++; &#125; else &#123; fa[find(u)] = find(v); fa[find(u + n)] = find(v + n); fa[find(u + n + n)] = find(v + n + n); &#125; &#125; else &#123; if (find(u) == find(v) || find(u) == find(v + n)) &#123; ans++; &#125; else &#123; fa[find(u + n)] = find(v); fa[find(u + n + n)] = find(v + n); fa[find(u)] = find(v + n + n); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 9.思维题(1)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//1292B - Aroma&#x27;s Search//越靠前点越密集,dis(xi,xi+1)的min值为xi,dis(xi,x0)=xi-x0,两式相减可得dis(xi,,xi+1)&gt;dis(xi,x0)(因为x0&gt;1),故捡数据点时,应先寻找点密集的那一侧,再返回点疏的那一侧#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n,x[100],y[100];int dis(int x1,int y1,int x2,int y2)&#123; return abs(x1-x2)+abs(y1-y2);&#125;void solve()&#123; int x0,y0,ax,ay,bx,by,xs,ys,t,ans=0; cin&gt;&gt;x0&gt;&gt;y0&gt;&gt;ax&gt;&gt;ay&gt;&gt;bx&gt;&gt;by&gt;&gt;xs&gt;&gt;ys&gt;&gt;t; x[0]=x0,y[0]=y0; while(++n)&#123; x[n]=ax*x[n-1]+bx; y[n]=ay*y[n-1]+by; if(x[n]&gt;xs&amp;&amp;y[n]&gt;ys&amp;&amp;dis(x[n],y[n],xs,ys)&gt;t)break; &#125; for(int i=0;i&lt;n;i++)&#123; int tans=0,tt=t; if(dis(x[i],y[i],xs,ys)&lt;=tt)tt-=(dis(x[i],y[i],xs,ys)),tans++; else &#123;ans=max(ans,tans);continue;&#125;//大于则直接跳过以下步骤 for(int j=i;j;j--)&#123; if(dis(x[j],y[j],x[j-1],y[j-1])&lt;=tt)tt-=(dis(x[j],y[j],x[j-1],y[j-1])),tans++; else break; &#125; for(int j=0;j&lt;n-1;j++)&#123;//必须从0开始,因为这里不知计算数据点,还要对tt进行处理 if(dis(x[j],y[j],x[j+1],y[j+1])&lt;=tt)tt-=(dis(x[j],y[j],x[j+1],y[j+1])),tans+=j&gt;=i; else break; &#125; ans=max(ans,tans); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; (2)12345678910111213141516171819202122232425262728293031323334353637//CF1304C Air Conditioner//维护区间//能够及时变温的条件是前后区间有交集//是否有交集可以通过sl是否大于sr判断#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123; int n,sl,sh,st=0; cin&gt;&gt;n&gt;&gt;sl; int t,l,h; sh=sl; bool flag=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;t&gt;&gt;l&gt;&gt;h; sh=min(h,t-st+sh); sl=max(l,sl-t+st); st=t; if(sl&gt;sh)flag=1; &#125; if(flag) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; (3)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//CF1385D a-Good String//根据对称性想到了平衡树(二叉树),故直接遍历每种可能选出消耗最少得操作方法 //时间复杂度由master公式可知为nlogn; #include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 131072;int ans,num;void bfs(string l,string r,int len,char c)&#123; if(len==0)&#123; string zi=&quot;&quot;; zi+=c; if(r==zi)&#123; ans=min(ans,num); &#125;else&#123; ans=min(ans,num+1); &#125; return; &#125; for(int i=0;i&lt;len;i++)&#123; if(l[i]!=c)&#123; num++; &#125; &#125; bfs(r.substr(0,len/2),r.substr(len/2,len),len/2,(char)(c+1)); for(int i=0;i&lt;len;i++)&#123; if(l[i]!=c)&#123; num--; &#125; &#125; for(int i=0;i&lt;len;i++)&#123; if(r[i]!=c)&#123; num++; &#125; &#125; bfs(l.substr(0,len/2),l.substr(len/2,len),len/2,(char)(c+1)); for(int i=0;i&lt;len;i++)&#123; if(r[i]!=c)&#123; num--; &#125; &#125;&#125;void solve()&#123; int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; ans=inf,num=0; if(n==1)&#123; if(s==&quot;a&quot;)cout&lt;&lt;0&lt;&lt;&#x27;\\n&#x27;; else cout&lt;&lt;1&lt;&lt;&#x27;\\n&#x27;; return; &#125; string l=s.substr(0,n/2),r=s.substr(n/2,n); bfs(l,r,n/2,&#x27;a&#x27;); cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 10.排序希尔排序1234567891011121314151617void shell_sort(int a[],int n)&#123; int gap=n; while(gap&gt;1)&#123; gap=gap/3+1; for(int i=1;i&lt;=gap;i++)&#123;//控制组数 for(int j=i;j&lt;=n-gap+1;j+=gap)&#123;//控制组内需插入的元素个数 int key=a[j]; int end=j-gap; while(end&gt;=1&amp;&amp;a[end]&gt;key)&#123; a[end+gap]=a[end]; end-=gap; &#125; a[end+gap]=key; &#125; &#125; &#125;&#125; 归并排序12345678910111213141516171819202122232425262728293031323334353637int arr[N],help[N],n;void merge(int l,int mid,int r)&#123; int i=l,a=l,b=mid+1; while(a&lt;=mid&amp;&amp;b&lt;=r)&#123; help[i++]=arr[a]&gt;arr[b]?arr[b++]:arr[a++]; &#125; while(a&lt;=mid)&#123; help[i++]=arr[a++]; &#125; while(b&lt;=r)&#123; help[i++]=arr[b++]; &#125; for(int i=l;i&lt;=r;i++)&#123; arr[i]=help[i]; &#125;&#125;void mergeSort1(int l,int r)&#123; if(l==r)return ; int mid=(l+r)&gt;&gt;1; mergeSort1(l,mid); mergeSort1(mid+1,r); merge(l,mid,r);&#125;void mergeSort2(int l,int r)&#123; for(int l,m,r,step=1;step&lt;=n;step&lt;&lt;=1)&#123; l=0; while(l&lt;=n)&#123; m=l+step-1; if(m+1&gt;n)break; r=min(l+step*2-1,n); merge(l,m,r); l=r+1; &#125; &#125;&#125; 快速排序12345678910111213141516171819202122232425262728293031323334//最好通过随机数划分,的平均复杂度void quickSort(int l,int r)&#123; if(l&gt;=r)return; int i=l-1,j=r+1,x=arr[l+r&gt;&gt;1]; while(i&lt;j)&#123; do&#123;i++;&#125;while(arr[i]&lt;x); do&#123;j--;&#125;while(arr[j]&gt;x); if(i&lt;j)swap(arr[i],arr[j]); &#125; quickSort(l,j),quickSort(j+1,r);&#125;int first,last;void partition(int l,int r,int x)&#123; first=l,last=r; int i=l; while(i&lt;=last)&#123; if(arr[i]&lt;x)&#123; swap(arr[i++],arr[first++]); &#125;else if(arr[i]==x)i++; else&#123; swap(arr[i],arr[last--]); &#125; &#125;&#125;void quickSort2(int l,int r)&#123; if(l&gt;=r)return; int x=arr[l+r&gt;&gt;1]; partition(l,r,x); quickSort2(l,first-1); quickSort2(last+1,r);&#125; 计数排序12345678910111213141516171819int cnt[N];void countSort(int l,int r)&#123; int Max=arr[l],Min=arr[l]; for(int i=l;i&lt;=r;i++)&#123; if(arr[i]&gt;Max)Max=arr[i]; if(arr[i]&lt;Min)Min=arr[i]; &#125; int len=Max-Min+1; for(int i=l;i&lt;=r;i++)&#123; cnt[arr[i]-Min]++; &#125; int it=1; for(int i=0;i&lt;len;i++)&#123; while(cnt[i]&gt;0)&#123; arr[it++]=i+Min; cnt[i]--; &#125; &#125;&#125; 11.0递归11.01经典递归&#x2F;&#x2F;1.返回字符串的所有子序列O(2^n*n) 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串vector */ set&lt;string&gt;st; vector&lt;string&gt;ans; int len; vector&lt;string&gt; generatePermutation(string s) &#123; len=s.length(); solve(&quot;&quot;,0,s); for(auto it:st)&#123; ans.push_back(it); &#125; return ans; &#125; void solve(string s,int i,string ss)&#123; if(i==len)&#123; st.insert(s); return ; &#125; string s1=s; solve(s1,i+1,ss); s1=s+ss[i]; solve(s1,i+1,ss); return; &#125;&#125;; &#x2F;&#x2F;2. O(2^n*n) &#x2F;&#x2F;1,1,1,2,2,4,4 &#x2F;&#x2F;分组:只有0个1的时候,只有1个1的时候,只有2个1的时候,只有3个1的时候(同理只有0个2的时候,只有1个2的时候,只有2个2的时候) 90. 子集 II - 力扣（LeetCode） 123456789101112131415161718192021222324class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;ans; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;int&gt;vec; fun(nums,0,vec); return ans; &#125; void fun(vector&lt;int&gt;&amp; nums,int i,vector&lt;int&gt; vec)&#123; if(i==nums.size())&#123; ans.push_back(vec); return ; &#125; int j=i+1; while(j&lt;nums.size()&amp;&amp;nums[i]==nums[j])j++; fun(nums,j,vec); for(int t=i;t&lt;j;t++)&#123; vec.push_back(nums[t]); fun(nums,j,vec); &#125; &#125;&#125;; &#x2F;&#x2F;输出n个数的所有排列(n*n!) &#x2F;&#x2F;以原先给定的数组为基准,尝试将每个数交换到i位置,递归下去即可 46. 全排列 - 力扣（LeetCode） 12345678910111213141516171819202122class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;ans; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; fun(nums,0); return ans; &#125; void fun(vector&lt;int&gt;&amp; nums,int i)&#123; if(i==nums.size())&#123; vector&lt;int&gt;temp; for(auto it:nums)&#123; temp.push_back(it); &#125; ans.push_back(temp); &#125; for(int j=i;j&lt;nums.size();j++)&#123; swap(nums[i],nums[j]); fun(nums,i+1); swap(nums[i],nums[j]); &#125; &#125;&#125;; &#x2F;&#x2F;汉罗塔 12345678void hanluota(int size,char a,char b,char c)&#123; if(size==0)&#123; return; &#125; hanluota(size-1,a,c,b); cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl; hanluota(size-1,c,b,a);&#125; 11.02嵌套类递归 [!IMPORTANT] 定义全局变量where,记录每次嵌套条件结束后i的值,以便后续对i进行更新 结束条件为总问题结结尾或是嵌套问题的结尾 &#x2F;&#x2F;计算含多层括号的表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int where;void pushFun(deque&lt;int&gt;&amp;numbers,deque&lt;char&gt;&amp;ops,int num,char op)&#123; int size=numbers.size(); if(size==0||ops.back()==&#x27;+&#x27;||ops.back()==&#x27;-&#x27;)&#123; numbers.push_back(num); ops.push_back(op); &#125;else&#123; int num1=numbers.back(); char op1=ops.back(); numbers.pop_back(); ops.pop_back(); if(op1==&#x27;*&#x27;)&#123; numbers.push_back(num*num1); &#125;else&#123; numbers.push_back(num/num1); &#125; ops.push_back(op); &#125;&#125;int final(deque&lt;int&gt;&amp;numbers,deque&lt;char&gt;&amp;ops)&#123; int ans=numbers.front(); numbers.pop_front(); while(!numbers.empty())&#123; ans+=(ops.front()==&#x27;+&#x27;?numbers.front():-numbers.front()); numbers.pop_front(); ops.pop_front(); &#125; return ans;&#125;//i++,忘了几次 int calculate(string s,int i)&#123; int cur=0; deque&lt;int&gt;numbers;deque&lt;char&gt;ops; while(i&lt;s.length()&amp;&amp;s[i]!=&#x27;)&#x27;)&#123; if(s[i]&gt;=&#x27;0&#x27;&amp;&amp;s[i]&lt;=&#x27;9&#x27;)&#123; cur=cur*10+s[i++]-&#x27;0&#x27;; &#125;else if(s[i]!=&#x27;(&#x27;)&#123; pushFun(numbers,ops,cur,s[i++]); cur=0; &#125;else&#123; cur=calculate(s,i+1); i=where+1; &#125; &#125; pushFun(numbers,ops,cur,&#x27;+&#x27;); where=i; return final(numbers,ops);&#125;void solve()&#123; string s; cin&gt;&gt;s; cout&lt;&lt;calculate(s,0)&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 11.动态规划983. 最低票价123456789101112131415161718192021222324252627282930313233343536373839404142434445//递归class Solution &#123;public: const int inf=0x3f3f3f3f; int duration[3]=&#123;1,7,30&#125;,dp[366]=&#123;0&#125;; int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123; return solve(days,costs,0); &#125; int solve(vector&lt;int&gt;&amp; days,vector&lt;int&gt;&amp; costs,int i)&#123; if(i==days.size())return 0; if(dp[i])return dp[i]; int ans=inf; for(int k=0,j=i;k&lt;3;k++)&#123; while(j&lt;days.size()&amp;&amp;days[i]+duration[k]&gt;days[j])j++; ans=min(ans,costs[k]+solve(days,costs,j)); &#125; dp[i]=ans; return ans; &#125;&#125;;//动态规划class Solution &#123;public: const int inf=0x3f3f3f3f; int duration[3]=&#123;1,7,30&#125;,dp[366]; int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123; return solve(days,costs,days.size()); &#125; int solve(vector&lt;int&gt;&amp; days,vector&lt;int&gt;&amp; costs,int n)&#123; for(int i=0;i&lt;366;i++)&#123; dp[i]=inf; &#125; int ans=inf; dp[n]=0; for(int i=n-1;i&gt;=0;i--)&#123; for(int k=0,j=i;k&lt;3;k++)&#123; while(j&lt;n&amp;&amp;days[i]+duration[k]&gt;days[j])j++; dp[i]=min(dp[i],costs[k]+dp[j]); &#125; &#125; return dp[0]; &#125;&#125;; 91. 解码方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//记忆化搜索class Solution &#123;public: int dp[105]; int numDecodings(string s) &#123; return solve(s,0); &#125; int solve(string s,int i)&#123; if(i==s.length())return 1; if(dp[i])return dp[i]; int ans=0; if(s[i]==&#x27;0&#x27;)&#123; ans=0; &#125;else&#123; ans=solve(s,i+1); if(i+1&lt;s.length()&amp;&amp;(s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;&lt;=26)&#123; ans+=solve(s,i+2); &#125; &#125; dp[i]=ans; return ans; &#125;&#125;;//动态规划class Solution &#123;public: int dp[105]; int numDecodings(string s) &#123; return solve(s,0); &#125; int solve(string s,int i)&#123; dp[s.length()]=1; for(int i=s.length()-1;i&gt;=0;i--)&#123; if(s[i]==&#x27;0&#x27;)&#123; dp[i]=0; &#125;else&#123; dp[i]=dp[i+1]; if(i+1&lt;s.length()&amp;&amp;(s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;&lt;=26)&#123; dp[i]+=dp[i+2]; &#125; &#125; &#125; return dp[0]; &#125;&#125;;//从动态规划得到解依赖于其后一个和后后一个数的解,故知道可通过记录后两个数的解即可得到这个数的解,这样节省了空间,从数组到两个变量class Solution &#123;public: int numDecodings(string s) &#123; return solve(s,0); &#125; int solve(string s,int i)&#123; int n=1,nn=0,cnt; for(int i=s.length()-1;i&gt;=0;i--)&#123; if(s[i]==&#x27;0&#x27;)&#123; cnt=0; nn=n; n=cnt; &#125;else&#123; cnt=n; if(i+1&lt;s.length()&amp;&amp;(s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;&lt;=26)&#123; cnt+=nn; &#125; nn=n; n=cnt; &#125; &#125; return n; &#125;&#125;; 639. 解码方法 II123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//动态规划//注意超出类型范围,所以用longclass Solution &#123;public:const long mod=1e9+7;long dp[100005]; int numDecodings(string s) &#123; return (int)fun(s); &#125; long fun(string s)&#123; int n=s.length(); dp[n]=1; for(int i=n-1;i&gt;=0;i--)&#123; if(s[i]==&#x27;0&#x27;)continue; dp[i]=dp[i+1]*(s[i]==&#x27;*&#x27;?9:1); if(i+1&lt;n)&#123; if(s[i]!=&#x27;*&#x27;)&#123; if(s[i+1]!=&#x27;*&#x27;)&#123; if(((s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;)&lt;=26)&#123; dp[i]+=dp[i+2]; &#125; &#125;else&#123; if(s[i]==&#x27;1&#x27;)&#123; dp[i]+=dp[i+2]*9; &#125;else if(s[i]==&#x27;2&#x27;)&#123; dp[i]+=dp[i+2]*6; &#125; &#125; &#125;else&#123; if(s[i+1]!=&#x27;*&#x27;)&#123; if(s[i+1]&lt;=&#x27;6&#x27;)dp[i]+=dp[i+2]*2; else dp[i]+=dp[i+2]; &#125;else&#123; dp[i]+=dp[i+2]*15; &#125; &#125; &#125; dp[i]=dp[i]%mod; &#125; return dp[0]; &#125;&#125;;//变量转移,节省空间class Solution &#123;public:const long mod=1e9+7; int numDecodings(string s) &#123; return (int)fun(s); &#125; long fun(string s)&#123; int len=s.length(); long nn=0,n=1,cur; for(int i=len-1;i&gt;=0;i--)&#123; if(s[i]==&#x27;0&#x27;)&#123; cur=0; nn=n; n=cur; continue; &#125; cur=n*(s[i]==&#x27;*&#x27;?9:1); if(i+1&lt;len)&#123; if(s[i]!=&#x27;*&#x27;)&#123; if(s[i+1]!=&#x27;*&#x27;)&#123; if(((s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;)&lt;=26)&#123; cur+=nn; &#125; &#125;else&#123; if(s[i]==&#x27;1&#x27;)&#123; cur+=nn*9; &#125;else if(s[i]==&#x27;2&#x27;)&#123; cur+=nn*6; &#125; &#125; &#125;else&#123; if(s[i+1]!=&#x27;*&#x27;)&#123; if(s[i+1]&lt;=&#x27;6&#x27;)cur+=nn*2; else cur+=nn; &#125;else&#123; cur+=nn*15; &#125; &#125; &#125; cur=cur%mod; nn=n; n=cur; &#125; return n; &#125;&#125;; 32. 最长有效括号123456789101112131415161718192021222324//得到一个字符后,以其为开始的点向左延伸,得到这个字符的最长子串//若遇&#x27;(&#x27;,则dp[i]=0;//若遇&#x27;)&#x27;,则dp[i]=(s[i-1-dp[i-1]]==&#x27;(&#x27;?dp[i-1]+2+dp[i-1-dp[i-1]-1]:0)class Solution &#123;public: int dp[3*10000+5]; int longestValidParentheses(string s) &#123; s=&quot; &quot;+s; int n=s.length(); for(int i=1;i&lt;n;i++)&#123; if(s[i]==&#x27;)&#x27;)&#123; int j=i-1-dp[i-1]; if(s[j]==&#x27;(&#x27;)&#123; dp[i]=dp[i-1]+2+dp[j-1]; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;n;i++)&#123; ans=max(ans,dp[i]); &#125; return ans; &#125;&#125;; 1274: D003 Help JimmyP1274 - D003 Help Jimmy - NENUOJ Min(i,true)表示从第i块板子的左侧出发到地面的最短距离 minleft[i]用来记录从第i块板子的左侧出发到地面的最短距离 minright[i]用来记录从第i块板子的右侧出发到地面的最短距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int minleft[N];int minright[N],Max,n;struct node&#123; int x1,x2,h;&#125;arr[N];bool cmp(node a,node b)&#123; return a.h&gt;b.h;&#125;int Min(int k,bool left)&#123; int x,y=arr[k].h,i; //往左侧行就给x赋值为k左侧的坐标x1 if(left)&#123; x=arr[k].x1; &#125;else &#123; x=arr[k].x2; &#125; //查询k块板子的下面是否有其他木板 for(i=k+1;i&lt;=n;i++)&#123; if(arr[i].x1&lt;=x&amp;&amp;arr[i].x2&gt;=x)&#123; break; &#125; &#125; //若没有 if(i==(n+1))&#123; if(y&gt;Max)return inf;//第k块板子到地面的距离大于Max,则直接返回inf else return y; //若小于则所花费的时间就是y &#125; //若有 else&#123; //第k块板子到i块板子的距离大于Max,则返回inf if(y-arr[i].h&gt;Max)return inf; &#125; //分别计算从第i块板子的左侧,右侧出发所花费的水平方线上的时间 int lefttime=y-arr[i].h+x-arr[i].x1,righttime=y-arr[i].h+arr[i].x2-x; if(minleft[i]==-1)&#123; minleft[i]=Min(i,true); &#125; if(minright[i]==-1)&#123; minright[i]=Min(i,false); &#125; //第k块板子(下面有板子i)到地面的最短时间,k块板子到i块板子的水平距离+降落到i块板子的竖直距离+第i块板子到地面的最短距离(分从第i块板子的左侧出发还是右侧出发) return min(minleft[i]+lefttime,minright[i]+righttime);&#125;void solve()&#123; int x,y; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y&gt;&gt;Max; arr[0].x1=x,arr[0].x2=x,arr[0].h=y; for(int i=0;i&lt;=n;i++)&#123; minleft[i]=-1; minright[i]=-1; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i].x1&gt;&gt;arr[i].x2&gt;&gt;arr[i].h; &#125; sort(arr+1,arr+1+n,cmp); cout&lt;&lt;Min(0,true)&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 1275: D004 最长公共子序列&#x2F;&#x2F;动态规划的重要思想就是将整体问题划分为子问题 当s1的第i个字母与s2的第j个字母一样时,我们原本要求的s1中的前i个字母和s2中的前j个字母&#x2F;有多少个最长公共子序列的问题(即求dp&#x2F;[i]&#x2F;[j])便转化为了求dp&#x2F;[i-1]&#x2F;[j-1] 当它们不一样时,我们便可在dp&#x2F;[i-1]&#x2F;[j]和dp&#x2F;[i]&#x2F;[j-1]中取最大值 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e2 + 5;int dp[N][N];string s1,s2;void solve()&#123; while(cin&gt;&gt;s1&gt;&gt;s2)&#123; s1=&quot; &quot;+s1; s2=&quot; &quot;+s2; int len1=s1.length(); int len2=s2.length(); memset(dp, 0, sizeof(dp)); for(int i=1;i&lt;len1;i++)&#123; for(int j=1;j&lt;len2;j++)&#123; if(s1[i]==s2[j])&#123; dp[i][j] = dp[i-1][j-1] + 1; &#125;else&#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; cout&lt;&lt;dp[len1-1][len2-1]&lt;&lt;endl; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 12.差分P5026 Lycanthropy - 洛谷等差数列差分 [!NOTE] 1在arr[l]+=s,arr[l+1]+=(d-s),arr[r+1]-=(d+e),arr[r+2]+=e; 两轮叠加: 第一轮s d d d d d d -e 0 0 第二轮s s+d s+2d s+3d s+4d s+5d s+6d 0 0 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5,OFFSET=30005;//OFFSET解决了对下标可能为负数的讨论int arr[N+OFFSET*2];void setArr(int l,int r,int s,int d,int e)&#123; arr[l+OFFSET]+=s; arr[l+1+OFFSET]+=d-s; arr[r+1+OFFSET]-=(e+d); arr[r+2+OFFSET]+=e;&#125;void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; while(n--)&#123; int v,x; cin&gt;&gt;v&gt;&gt;x; setArr(x-3*v+1,x-2*v,1,1,v); setArr(x-2*v+1,x,v-1,-1,-v); setArr(x+1,x+2*v,-v+1,1,v); setArr(x+2*v+1,x+3*v,v-1,-1,0); &#125; //等差数列差分需进行二次叠加 for(int i=1;i&lt;=m+OFFSET;i++)&#123; arr[i]+=arr[i-1]; &#125; for(int i=1;i&lt;=m+OFFSET;i++)&#123; arr[i]+=arr[i-1]; &#125; for(int i=1+OFFSET;i&lt;=m+OFFSET;i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;&#x27; &#x27;; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 问题:123456789//为啥这样改不对 while(n--)&#123; int v,x; cin&gt;&gt;v&gt;&gt;x; setArr(x-3*v,x-2*v,0,1,v); setArr(x-2*v,x,v,-1,-v); setArr(x,x+2*v,-v,1,v); setArr(x+2*v,x+3*v,v,-1,0); &#125; 13.堆结构123456789101112131415161718192021//插入并构建大根堆(向上调整)void heapInsert(int i)&#123; while(arr[i]&gt;arr[(i-1)/2])&#123; swap(arr[i],arr[(i-1)/2]); i=(i-1)/2; &#125;&#125;//i位置的数变小了,需维持大根堆结构,向下调整大根堆(向下调整)//当前堆的大小为sizevoid heapify(int i,int size)&#123; int l=2*i+1; while(l&lt;size)&#123; int best=(l+1&lt;size&amp;&amp;arr[l+1]&gt;arr[l])?(l+1):l; best=arr[i]&gt;arr[best]?i:best; if(best==i)break; swap(arr[i],arr[best]); i=best; l=2*i+1; &#125;&#125; 堆排序1234567891011121314151617181920212223242526272829303132void heapInsert(int i)&#123; while(arr[i]&gt;arr[(i-1)/2])&#123; swap(arr[i],arr[(i-1)/2]); i=(i-1)/2; &#125;&#125;//i位置的数变小了,需维持大根堆结构,向下调整大根堆(向下调整)//当前堆的大小为sizevoid heapify(int i,int size)&#123; int l=2*i+1; while(l&lt;size)&#123; int best=(l+1&lt;size&amp;&amp;arr[l+1]&gt;arr[l])?(l+1):l; best=arr[i]&gt;arr[best]?i:best; if(best==i)break; swap(arr[i],arr[best]); i=best; l=2*i+1; &#125;&#125;void heapSort()&#123; int n=10;//堆的大小 for(int i=0;i&lt;n;i++)&#123; heapInsert(i); &#125; int size=n; while(size&gt;1)&#123; swap(arr[0],arr[--size]); heapify(0,size); &#125;&#125; 14.二叉树1.二叉树的层序遍历1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:TreeNode* q[2100];vector&lt;int&gt;arr; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(root!=nullptr)&#123; int l=0,r=0; q[r++]=root; while(l&lt;r)&#123; int size=r-l;//r-l while(size--)&#123; TreeNode* x=q[l++]; if(x==nullptr)continue; arr.push_back((x-&gt;val)); if(x-&gt;left!=nullptr)&#123; q[r++]=x-&gt;left; &#125; if(x-&gt;right!=nullptr)&#123; q[r++]=x-&gt;right; &#125; &#125; ans.push_back(arr); arr.clear(); &#125; &#125; return ans; &#125; &#125;; 2.二叉树的锯齿形层序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:TreeNode* q[2005];vector&lt;int&gt;arr; vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;ans; if(root!=nullptr)&#123; int l=0,r=0; q[r++]=root; bool flag=false; while(l&lt;r)&#123; int size=r-l,i; if(flag==false)i=l; else i=r-1; for(int k=1;k&lt;=size;k++)&#123; if(q[i]==nullptr)continue; arr.push_back(q[i]-&gt;val); if(flag)i--; else i++; &#125; while(size--)&#123; TreeNode* x=q[l++]; if(x==nullptr)continue; if(x-&gt;left!=nullptr)&#123; q[r++]=x-&gt;left; &#125; if(x-&gt;right!=nullptr)&#123; q[r++]=x-&gt;right; &#125; &#125; ans.push_back(arr); flag=!flag; arr.clear(); &#125; &#125; return ans; &#125;&#125;; 3.二叉树的最大宽度662. 二叉树最大宽度 - 力扣（LeetCode） 123456789101112131415161718192021222324252627282930313233343536373839404142//可能出现很多null值导致下标极大,故用unsigned long long/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:TreeNode* nq[3005];unsigned long long q[3005]; int widthOfBinaryTree(TreeNode* root) &#123; unsigned long long ans=0; if(root==nullptr)return ans; unsigned long long l=0,r=0; nq[r]=root; q[r++]=1; while(l&lt;r)&#123; unsigned long long size=r-l; ans=max(ans,q[r-1]-q[l]+1); while(size--)&#123; TreeNode* x=nq[l]; unsigned long long iq=q[l++]; if(x==nullptr)continue; if(x-&gt;left!=nullptr)&#123; nq[r]=x-&gt;left; q[r++]=iq*2; &#125; if(x-&gt;right!=nullptr)&#123; nq[r]=x-&gt;right; q[r++]=iq*2+1; &#125; &#125; &#125; return (int)ans; &#125;&#125;; 4.二叉树的最大深度104. 二叉树的最大深度 - 力扣（LeetCode） 123int maxDepth(TreeNode* root)&#123; return (root==nullptr?0:max(maxSolve(root-&gt;left),maxSolve(root-&gt;right))+1);&#125; 5.二叉树的最小深度111. 二叉树的最小深度 - 力扣（LeetCode） 123456789101112int minDepth(TreeNode* root)&#123; if(root==nullptr)return 0; if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)return 1; int leftDepth=inf,rightDepth=inf; if(root-&gt;left!=nullptr)&#123; leftDepth=minDepth(root-&gt;left); &#125; if(root-&gt;right!=nullptr)&#123; rightDepth=minDepth(root-&gt;right); &#125; return min(leftDepth,rightDepth)+1;&#125; 6.知前中序遍历求后序12345678910111213void tree(string front,string mid)&#123; if(front.empty())return; char root=front[0]; int k=mid.find(root); front.erase(front.begin()); string leftfront=front.substr(0,k); string rightfront=front.substr(k); string leftmid=mid.substr(0,k); string rightmid=mid.substr(k+1); tree(leftfront,leftmid); tree(rightfront,rightmid); cout&lt;&lt;root;&#125; 7.知后中序遍历写前序1234567891011121314void work(string mid,string back)&#123; if(back.empty())return ; char root=back[back.size()-1]; int k=mid.find(root); back.erase(back.end()-1); string leftmid=mid.substr(0,k); string rightmid=mid.substr(k+1); string leftback=back.substr(0,k); string rightback=back.substr(k); cout&lt;&lt;root; work(leftmid,leftback); work(rightmid,rightback);&#125; 8.计算二叉树的节点个数222. 完全二叉树的节点个数 - 力扣（LeetCode） 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(root==nullptr)return 0; return f(root,1,findDepth(root,1)); &#125; int f(TreeNode* root,int level,int h)&#123; if(level==h)return 1; if(findDepth(root-&gt;right,level+1)==h)&#123; return (1&lt;&lt;(h-level))+f(root-&gt;right,level+1,h); &#125;else&#123; return (1&lt;&lt;(h-level-1))+f(root-&gt;left,level+1,h); &#125; &#125; int findDepth(TreeNode* root,int level)&#123; while(root)&#123; level++; root=root-&gt;left; &#125; return level-1; &#125;&#125;; 9.二叉树的最近公共祖先123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==nullptr||root==p||root==q)return root; TreeNode* l=lowestCommonAncestor(root-&gt;left,p,q); TreeNode* r=lowestCommonAncestor(root-&gt;right,p,q); if(l!=nullptr&amp;&amp;r!=nullptr)&#123; return root; &#125; if(l==nullptr&amp;&amp;r==nullptr)&#123; return nullptr; &#125; return l==nullptr?r:l; &#125;&#125;;//二叉搜索数的最近公共祖先//p,q都在root这个节点之下TreeNode* solve(TreeNode* root ,TreeNode* p,TreeNode* q)&#123; while(root!=p&amp;&amp;root!=q)&#123; if(min(p-&gt;val,q-&gt;val)&lt;root-&gt;val&amp;&amp;max(p-&gt;val,q-&gt;val)&gt;root-&gt;val)&#123; break; &#125; root=root-&gt;val&lt;min(p-&gt;val,q-&gt;val)?root-&gt;right:root-&gt;left; &#125; return root;&#125; 10.路径总和113. 路径总和 II - 力扣（LeetCode） &#x2F;&#x2F;注意回溯 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;ans;deque&lt;int&gt;q; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; if(root==nullptr)return ans; solve(root,targetSum,0); return ans; &#125; void solve(TreeNode* root,int targetSum,int curSum)&#123; if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)&#123; if(root-&gt;val+curSum==targetSum)&#123; q.push_back(root-&gt;val); copy(); q.pop_back(); &#125; &#125;else&#123; q.push_back(root-&gt;val); if(root-&gt;left!=nullptr)&#123; solve(root-&gt;left,targetSum,curSum+root-&gt;val); &#125; if(root-&gt;right!=nullptr)&#123; solve(root-&gt;right,targetSum,curSum+root-&gt;val); &#125; q.pop_back(); &#125; &#125; void copy()&#123; vector&lt;int&gt;arr; for(auto it:q)&#123; arr.push_back(it); &#125; ans.push_back(arr); &#125;&#125;; 11.验证平衡二叉树&#x2F;&#x2F;flag的重要性 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:bool ans; bool isBalanced(TreeNode* root) &#123; ans=true; height(root); return ans; &#125; int height(TreeNode* root)&#123; if(!ans||root==nullptr)&#123; return 0; &#125; int lh=height(root-&gt;left); int rh=height(root-&gt;right); if(abs(lh-rh)&gt;1)&#123; ans=false; &#125; return max(lh,rh)+1; &#125;&#125;; 12.验证二叉搜索树(涉及中序遍历的非递归实现)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(root==nullptr)return true; stack&lt;TreeNode*&gt;st; TreeNode* pre=nullptr; while(!st.empty()||root!=nullptr)&#123; if(root!=nullptr)&#123; st.push(root); root=root-&gt;left; &#125;else&#123; root=st.top(); st.pop(); if(pre!=nullptr&amp;&amp;pre-&gt;val&gt;=root-&gt;val)&#123; return false; &#125; pre=root; root=root-&gt;right; &#125; &#125; return true; &#125;&#125;;//记录左子树的最大最小值和右子树的最大最小值,中间的值要大于左子树的最大值,要小于右子树的最小值/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:long long Max,Min;const long long MMAX=3000000000,MMIN=-3000000000; bool isValidBST(TreeNode* root) &#123; if(root==nullptr)&#123; Max=MMIN; Min=MMAX; return true; &#125; bool lok=isValidBST(root-&gt;left); long long lmax=Max; long long lmin=Min; bool rok=isValidBST(root-&gt;right); long long rmax=Max; long long rmin=Min; Max=max(max(lmax,rmax),(long long)(root-&gt;val)); Min=min(min(lmin,rmin),(long long)(root-&gt;val)); return lok&amp;&amp;rok&amp;&amp;(lmax&lt;(long long)(root-&gt;val))&amp;&amp;((long long)(root-&gt;val)&lt;rmin); &#125;&#125;; 13.修剪搜索二叉树（递归)669. 修剪二叉搜索树 - 力扣（LeetCode） 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; if(root==nullptr)return nullptr; if(root-&gt;val&lt;low)&#123; return trimBST(root-&gt;right,low,high); &#125; if(root-&gt;val&gt;high)&#123; return trimBST(root-&gt;left,low,high); &#125; root-&gt;left=trimBST(root-&gt;left,low,high); root-&gt;right=trimBST(root-&gt;right,low,high); return root; &#125;&#125;; 14.打家劫舍iii337. 打家劫舍 III - 力扣（LeetCode） &#x2F;&#x2F;yes代表偷子节点,no代表不投子节点 &#x2F;&#x2F;y代表偷当前子节点,n代表不投当前子节点 &#x2F;&#x2F;很像dp了 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:int yes,no; int rob(TreeNode* root) &#123; f(root); return max(yes,no); &#125; void f(TreeNode* root)&#123; if(root==nullptr)&#123; yes=0; no=0; &#125;else&#123; int y=root-&gt;val; int n=0; f(root-&gt;left); y+=no; n+=max(yes,no); f(root-&gt;right); y+=no; n+=max(yes,no); yes=y; no=n; &#125; &#125;&#125;; 15.树状数组[P3605 USACO17JAN] Promotion Counting P - 洛谷未解决 应用:(可求逆序对数) 每个下标a管的范围:其二进制最右侧的1变为0,然后加1,变为b [b,a]; &#x2F;&#x2F;[前缀树状数组]单点增加,范围查询(前缀)&#x2F;&#x2F;t[i]代表具有一定规律的某一范围的和 123456789101112int lowbit(int x) &#123; return x &amp; -x;&#125;void update(int k, int x) &#123; for(int i = k; i &lt;= n; i += lowbit(i)) t[i] += x;&#125;//1~k范围求和int getprefix(int k) &#123; int res = 0; for(int i = k; i &gt; 0; i -= lowbit(i)) res += t[i]; return res;&#125; 1.[P1966 NOIP 2013 提高组] 火柴排队 - 洛谷 第一次错是因为结果忘记取模 &#x2F;&#x2F;疑问如果高度有相同的会不会影响结果,样例是没有这部分测试的或许 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5,mod=1e8-3;struct node&#123; int val,id;&#125; a[N],b[N];bool cmp(node x,node y)&#123; return x.val&lt;y.val;&#125;int c1[N];int c2[N];int c3[N];int t[N],n;//树状数组模版int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int x,int y)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))&#123; t[i]+=y; &#125;&#125;int query(int x)&#123; int res = 0; for(int i=x;i&gt;0;i-=lowbit(i))&#123; res=(res%mod+t[i]%mod)%mod; &#125; return res;&#125;void solve()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i].val; a[i].id=i; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;b[i].val; b[i].id=i; &#125; sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); //1342 //1234(开始时从1到n,上下两列都是) //1724 //转换参照物 //1423(排序后) //1342(排序后)(1234) //上列查1得1,查2得3,查3得4,查4得2 //1342 //1423 //得到原排序顺序 //1423对应1234,查1342所对应的 //1342(1423) //1423(1234) //得到1423 //相对于1234 //求1423的逆序对即可 //证明略,猜的 for(int i=1;i&lt;=n;i++)&#123; c1[a[i].id]=i; c2[b[i].id]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; c3[c2[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; c2[i]=c3[c1[i]]; &#125; int res=0; for(int i=1;i&lt;=n;i++)&#123; update(c2[i],1); res=((res%mod+query(n)%mod)%mod+(-query(c2[i])%mod+mod)%mod)%mod; &#125; cout&lt;&lt;res&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; &#x2F;&#x2F;[差分树状数组]范围增加,单点查询,利用差分数组(差分)&#x2F;&#x2F;t[i]代表某一范围的差分和 &#x2F;&#x2F;求和可得某一位置的数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n,t[N],arr[N];int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int x,int val)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))t[i]+=val;&#125;int query(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=lowbit(i))ans+=t[i]; return ans;&#125;void solve()&#123; int m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;arr[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; update(i,arr[i]-arr[i-1]); &#125; while(m--)&#123; int op,x,y,k; cin&gt;&gt;op; if(op==1)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; update(x,k); update(y+1,-k); &#125; else&#123; cin&gt;&gt;x; cout&lt;&lt;query(x)&lt;&lt;endl; &#125; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; &#x2F;&#x2F;范围增加,范围查询线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344void build(int s, int t, int p) &#123; if (s == t) &#123; d[p] = a[s]; return; &#125; int m = s + ((t - s) &gt;&gt; 1); build(s, m, p * 2), build(m + 1, t, p * 2 + 1); d[p] = d[p * 2] + d[(p * 2) + 1];&#125;void pushdown(int s, int e, int o) &#123; if (lz[o]) &#123; int mid = (s + e) / 2; t[o * 2] += (mid - s + 1) * lz[o]; t[o * 2 + 1] += (e - mid) * lz[o]; lz[o * 2] += lz[o]; lz[o * 2 + 1] += lz[o]; lz[o] = 0; &#125;&#125;void update(int l, int r, int v, int s, int e, int o) &#123; if (l &lt;= s &amp;&amp; r &gt;= e) &#123; t[o] += (e - s + 1) * v; lz[o] += v; return; &#125; pushdown(s, e, o); int mid = (s + e) / 2; if (l &lt;= mid) update(l, r, v, s, mid, o * 2); if (r &gt; mid) update(l, r, v, mid + 1, e, o * 2 + 1); pushup(o);&#125;int getsum(int l, int r, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; t &lt;= r) return d[p]; pushdown(s,t,p); int m = s + ((t - s) &gt;&gt; 1), sum = 0; if (l &lt;= m) sum += getsum(l, r, s, m, p * 2); if (r &gt; m) sum += getsum(l, r, m + 1, t, p * 2 + 1); return sum;&#125; 可持久化线段树12345678910111213141516171819202122232425262728293031void build(int&amp; x, int l, int r)&#123; x = ++idx; if (l == r)return; int mid = (l + r) &gt;&gt; 1; build(lc(x), l, mid); build(rc(x), mid + 1, r);&#125;void update(int pre, int&amp; o, int l, int r, int v)&#123; o = ++idx; t[o] = t[pre]; t[o].val++; if (l == r)return; int mid = (l + r) &gt;&gt; 1; if (v &lt;= mid) update(lc(pre), lc(o), l, mid, v); else update(rc(pre), rc(o), mid + 1, r, v);&#125;int query(int x, int y, int l, int r, int k)&#123; if (l == r)return l; int mid = (l + r) &gt;&gt; 1; int s = t[lc(y)].val - t[lc(x)].val; if (k &lt;= s) return query(lc(x), lc(y), l, mid, k); else return query(rc(x), rc(y), mid + 1, r, k - s);&#125; 欧拉筛如果能让每个合数都只被标记一次，那么时间复杂度就可以降到 𝑂(𝑛) 1234567891011121314151617181920void euler(int n) &#123; vector&lt;int&gt; primes; bool vis[n + 1] = &#123;false&#125;; // 初始化vis数组，默认所有数都是质数候选 vis[0] = vis[1] = true; // 0和1不是质数 for (int i = 2; i &lt;= n; ++i) &#123; // 如果i没有被筛除，说明i是质数，存入vector中 if (!vis[i]) &#123; primes.push_back(i); &#125; // 注意枚举条件，i * primes[j]表示要被筛除的数字（一定不是质数） for (int j = 0; j &lt; primes.size() &amp;&amp; i * primes[j] &lt;= n; ++j) &#123; vis[i * primes[j]] = true; // 如果i能被primes[j]整除，说明primes[j+1]已经不是i * primes[j+1]的最小质因子了 if (i % primes[j] == 0) &#123; break; &#125; &#125; &#125;&#125; Kruskal算法123456789101112131415161718192021222324252627282930struct Edge &#123; int x, y, c; bool operator&lt; (const Edge &amp;u) const &#123; return c &lt; u.c; &#125;&#125;;int pre[N];int root(int x) &#123; return pre[x] == x ? x : root(pre[x]);&#125;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;Edge&gt; es; for(int i = 1; i &lt;= m; ++ i) &#123; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; es.push_back(&#123;x, y, c&#125;); &#125; sort(es.begin(), es.end()); for(int i = 1; i &lt;= n; ++ i) pre[i] = i; int ans = 0; for(const auto&amp; [x, y, c] : es) &#123; if(root(x) == root(y)) continue; ans = max(ans, c); pre[root(x)] = root(y); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; Prim算法12345678910111213141516171819202122232425262728293031323334struct Edge &#123; ll x, c; bool operator&lt; (const Edge &amp;u) const &#123; return c == u.c ? x &gt; u.x : c &lt; u.c; &#125;&#125;;vector&lt;Edge&gt; g[N];ll d[N];int n, m;int prim() &#123; priority_queue&lt;Edge&gt; pq; bitset&lt;N&gt; vis; d[1] = 0; pq.push(&#123;1, d[1]&#125;); ll res = 0; while(pq.size()) &#123; int x = pq.top().x; pq.pop(); if(vis[x]) continue; vis[x] = true; res = max(res, d[x]); for(const auto &amp;[y, w] : g[x]) &#123; if(!vis[y]) &#123; d[y] = min(d[y], w); pq.push(&#123;y, d[y]&#125;); &#125; &#125; &#125; return res;&#125; 16.链表 [!NOTE] 写链表的题是要特别注意非空判断,避免空指针异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//https://www.luogu.com.cn/problem/P1996#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; &#125;;void solve()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; ListNode* head=new ListNode(1); ListNode* p=head; for(int i=2;i&lt;=n;i++)&#123; p-&gt;next=new ListNode(i); p=p-&gt;next; &#125; p-&gt;next=head;//成环 int num=n;//记录总共的节点个数 p=head; ListNode* pre=p;//记录前一个节点,用于删除节点 while(num)&#123; //保证p要不为空 for(int i=1;i&lt;=m-1&amp;&amp;p!=nullptr;i++)&#123; pre=p; p=p-&gt;next; &#125; if(p==nullptr) break; cout&lt;&lt;p-&gt;val&lt;&lt;&quot; &quot;; pre-&gt;next=p-&gt;next; delete p;//删除节点 p=pre-&gt;next;//把p指向下一个节点 num--; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; &#x2F;&#x2F;双重循环会超时(1e5*1e5),但一般看到这个我们还会想到一种方法,那就是对应数值索引 &#x2F;&#x2F;这道题的思路很简单,就是的注意非空判断,以及更改的先后顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;struct ListNode&#123; int val; ListNode *next,*pre; ListNode():val(0),next(nullptr)&#123;&#125; ListNode(int x):val(x),next(nullptr)&#123;&#125;&#125;arr[N];void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; arr[i].val=i; &#125; for(int i=2;i&lt;=n;i++)&#123; int k,p; cin&gt;&gt;k&gt;&gt;p; if(p==1)&#123; //arr[k].next依赖与arr[k],故需要将arr[k].next保存起来,才可修改arr[k].next-&gt;pre //插后面,先管后,再管前 arr[i].next=arr[k].next; if(arr[k].next!=nullptr)arr[k].next-&gt;pre=&amp;(arr[i]); arr[k].next=&amp;(arr[i]); arr[i].pre=&amp;(arr[k]); &#125;else&#123; //插前面,先管前,再管后 arr[i].pre=arr[k].pre; if(arr[k].pre!=nullptr)arr[k].pre-&gt;next=&amp;(arr[i]); arr[i].next=&amp;(arr[k]); arr[k].pre=&amp;(arr[i]); &#125; &#125; int m; cin&gt;&gt;m; while(m--)&#123; int x; cin&gt;&gt;x; if(arr[x].val==0)continue; arr[x].val=0; if(arr[x].pre!=nullptr)arr[x].pre-&gt;next=arr[x].next; if(arr[x].next!=nullptr)arr[x].next-&gt;pre=arr[x].pre; arr[x].pre=nullptr; arr[x].next=nullptr; &#125; int mark=0; for(int i=1;i&lt;=n;i++)&#123; if(arr[i].pre==nullptr&amp;&amp;arr[i].next!=nullptr)&#123; mark=i; break; &#125; &#125; ListNode *head=&amp;(arr[mark]); while(head)&#123; cout&lt;&lt;head-&gt;val&lt;&lt;&quot; &quot;; head=head-&gt;next; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 17.打表构造题就打表 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n;int vis[N];deque&lt;int&gt;ans;int cnt;//通过cnt使得答案只输出一次void dfs(int dep,int sum)&#123; if(dep==n&amp;&amp;cnt==0)&#123;//设置结束条件 cnt++; for(auto x:ans)&#123; cout&lt;&lt;x&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return ; &#125; for(int i=0;i&lt;=n-1;i++)&#123; if(vis[i])continue; if(!(sum^i))continue; vis[i]=1; ans.push_back(i); dfs(dep+1,sum^i); vis[i]=0; ans.pop_back();//回退vis以及ans &#125;&#125;void solve()&#123; cnt=0; cin&gt;&gt;n; dfs(0,0);&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//https://codeforces.com/gym/105386/problem/G#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int a[N];void solve()&#123; int n; cin&gt;&gt;n; if(n%4==0||n==1)&#123; cout&lt;&lt;&quot;impossible\\n&quot;; return ; &#125; if(n==2)&#123; cout&lt;&lt;&quot;1 0\\n&quot;; return; &#125; if(n==3)&#123; cout&lt;&lt;&quot;1 0 2\\n&quot;; return ; &#125; a[0]=1; a[1]=0; a[2]=2; for(int i=3;i&lt;n;i++)&#123; a[i]=i; if(i%4==0)&#123; swap(a[i-1],a[i]); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 18.唯一分解定理1234567891011121314151617181920212223242526for (int i = 2; i &lt;= x / i; ++i) &#123; // 如果不能整除直接跳过 if (x % i) continue; // 如果可以整除，那么必然是一个质因子（从小到大枚举的特性决定） int cnt = 0; // 一直除，直到除干净 while (x % i == 0) cnt++, x /= i; v.push_back(&#123;i, cnt&#125;); &#125; // 如果x大于1，说明x本身就是一个质数 if (x &gt; 1) v.push_back(&#123;x, 1&#125;); // 输出所有质因数及其对应的指数 for (const auto&amp; i : v) cout &lt;&lt; i.first &lt;&lt; &#x27; &#x27; &lt;&lt; i.second &lt;&lt; &#x27;\\n&#x27;; 因数个数的寻找与一些数学谜题息息相关。现在小编为大家分享一下自我研究出的通过分解质因数寻找因数个数的方法。首先讲一个数分解质因数，如果有相同的质因数就整理成幂次方的形式。将结果的指数加一，再将此结果相乘得到其因数个数。举例：72，用列举法不易找出其因数个数。而72＝2×2×2×3×3＝2³×3²，分别将指数3,2加一变成4,3，4×3＝12个。列举证明1,2,3,4,6,8,9,12,18,24,36,72共12个因数。 19.搜索[P1219 USACO1.5] 八皇后 Checker Challenge - 洛谷 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//无敌暴力,遗憾超时//用brr来辅助进行对角线是否有相同元素的查询//第一次brr辅助查询右下角是否有重叠//第二次brr辅助查询左下角是否有重叠#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int arr[15][15],brr[15][15],n,ans;deque&lt;int&gt;st;bool check()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; brr[i][j]=arr[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int sum=0; for(int j=1;j&lt;=n;j++)&#123; sum+=brr[j][i]; &#125; if(sum!=1)return false; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(brr[i][j]==1)&#123; if(i+1&gt;n||j+1&gt;n)&#123;continue;&#125; if(brr[i+1][j+1]==1)&#123; return false; &#125; brr[i+1][j+1]=1; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; brr[i][j]=arr[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(brr[i][j]==1)&#123; if(i+1&gt;n||j-1&lt;1)&#123;continue;&#125; if(brr[i+1][j-1]==1)&#123; return false; &#125; brr[i+1][j-1]=1; &#125; &#125; &#125; return true;&#125;void dfs(int x, int y)&#123; if(x==n)&#123; if(check())&#123; ans++; if(ans&gt;3)return ; for(auto it:st)&#123; cout&lt;&lt;it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&#x27;\\n&#x27;; &#125; return ; &#125; for(int i=1;i&lt;=n;i++)&#123; arr[x+1][i]=1; st.push_back(i); dfs(x+1,i); arr[x+1][i]=0; st.pop_back(); &#125;&#125;void solve()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; arr[1][i]=1; st.push_back(i); dfs(1,i); arr[1][i]=0; st.pop_back(); &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 直接用vis1和vis2对斜对角线上的元素是否有重叠进行标记 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int arr[15][15],brr[15][15],n,ans;deque&lt;int&gt;st;int vis[15],vis1[35],vis2[35];void dfs(int x, int y)&#123; if(x==n)&#123; ans++; if(ans&gt;3)return ; for(auto it:st)&#123; cout&lt;&lt;it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&#x27;\\n&#x27;; return ; &#125; for(int i=1;i&lt;=n;i++)&#123; if(vis[i])&#123;continue;&#125; if(vis1[i-(x+1)+n])&#123;continue;&#125; if(vis2[i+x+1])&#123;continue;&#125; arr[x+1][i]=1; vis[i]=1; vis1[i-(x+1)+n]=1; vis2[i+x+1]=1; st.push_back(i); dfs(x+1,i); arr[x+1][i]=0; vis[i]=0; st.pop_back(); vis1[i-(x+1)+n]=0; vis2[i+x+1]=0; &#125;&#125;void solve()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; arr[1][i]=1; vis[i]=1; st.push_back(i); vis1[i-1+n]=1; vis2[i+1]=1; dfs(1,i); arr[1][i]=0; st.pop_back(); vis[i]=0; vis1[i-1+n]=0; vis2[i+1]=0; &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; math位运算[P5657 CSP-S2019] 格雷码 - 洛谷打表找规律 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;vector&lt;string&gt; digui(int n)&#123; if(n==1)&#123; vector&lt;string&gt;ans; ans.push_back(&quot;0&quot;); ans.push_back(&quot;1&quot;); return ans; &#125; vector&lt;string&gt;temp; temp=digui(n-1); vector&lt;string&gt;res; for(int i=0;i&lt;temp.size();i++)&#123; res.push_back(&quot;0&quot;+temp[i]); &#125; for(int i=temp.size()-1;i&gt;=0;i--)&#123; res.push_back(&quot;1&quot;+temp[i]); &#125; return res;&#125;void solve()&#123; int n; cin&gt;&gt;n; vector&lt;string&gt;ans=digui(n); for(int i=0;i&lt;ans.size();i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 这道题很明显是有蹊跷的,数据范围过大。 但是让我找规律我未必能发现 但仔细思考一下,位数高达64位,我们不可能生成所有数再查询,所以只可能是每一个数的每位是0还是1有规律可寻,所以我们自然而然的去关注打表后每一个数的每一位是否呈现某种规律 规律: 倒数第n位就是 2^(n−1) 个 0 , 2^(n−1) 个 1 , 2^(n−1) 个 1 , 2^(n−1) 个 0 循环 位数高达64,得用unsigned long long 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;#define int unsigned long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int ans[64];int num[]=&#123;0,1,1,0&#125;;void solve()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=n-1;i&gt;0;i--)&#123; cout&lt;&lt;num[(k/((int)(1)&lt;&lt;i))%4]; &#125; cout&lt;&lt;num[k%4]&lt;&lt;endl;//最后要单独输出，否则会出现inf //若这里不单独输出,当i等于0时,进行i--操作后,i会变成unsigned long long 所能表示的最大整数(18446744073709551615),使得循环无法结束,故需特殊处理&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 第k个格雷码&#x3D;k^(k&gt;&gt;1) 我们再输出每一位即可 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;#define int unsigned long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int num[]=&#123;0,1,1,0&#125;;void solve()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; k=k^(k&gt;&gt;1); while(n)&#123; n--; if(k==-1) break; cout&lt;&lt;((k&gt;&gt;n)&amp;1); &#125;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; [P5514 MtOI2019] 永夜的报应 - 洛谷a最大可达1e9则我们设置a的二进制最大有32位,统计每一个a的每一位是否为1, cnt[i]代表i位为1的a的个数,若该位的1为奇数个,则无论如何组合该位都会留下,其他位同理,我们最后只需对留下的1乘以他们所对应的位权即可 从以上推出更简单的结果所得公式ans&#x3D;0;ans^&#x3D;a;cout&lt;&lt;ans; 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int cnt[35];void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int a; cin&gt;&gt;a; for(int j=31;j&gt;=0;j--)&#123; cnt[j]+=((a&gt;&gt;j)&amp;1); &#125; &#125; int ans=0; for(int i=31;i&gt;=0;i--)&#123; if(cnt[i]%2==1) ans+=(1&lt;&lt;i); &#125; cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; P5539 【XR-3】Unknown Mother-Goose - 洛谷(bitset优化)题目要求的是把 S 集合中所有的数的倍数标记之后，连续 3 个都被标记的位置的数量(这步采用位运算,非常巧妙。) bs 数组：用二进制位标记数字是否被选中。unsigned long long 是 64 位，因此 bs[k] 对应数字 k*64 ~ (k+1)*64-1，其中第 b 位（0≤b&lt;64）为 1 表示数字 k*64 + b 被标记。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define N 1000000003#define reg registerusing namespace std;unsigned long long bs[(N&gt;&gt;6)+10];unsigned long long tmp[65];int n,m,s,l,ans;//统计1的个数,即连续3个都被标记的位置的数量inline int count(unsigned long long x)&#123; reg int res = 0; while(x)&#123; res += x&amp;1; x &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s; m = (n&gt;&gt;6)+1; while(s--)&#123; cin&gt;&gt;l; if(l&lt;64)&#123; //两种情况判一下,保证加入的复杂度是 n/w memset(tmp,0,sizeof(tmp)); for(reg int i=0;i&lt;(l&lt;&lt;6);i+=l) tmp[i&gt;&gt;6] |= 1ull&lt;&lt;(i&amp;63); //加入的数比较小,开另一个数组,作为重复单元,i&amp;63相当于i%64 for(reg int i=0;i&lt;=m;i+=l) for(reg int j=0;j&lt;l;++j) bs[i+j] |= tmp[j]; &#125;else&#123; for(reg int i=0;i&lt;=n;i+=l) bs[i&gt;&gt;6] |= 1ull&lt;&lt;(i&amp;63); &#125; &#125; --m; if((n&amp;63)!=63) bs[m] &amp;= (1ull&lt;&lt;(n+1-(m&lt;&lt;6)))-1; //特判一下最后一块 bs[0] &amp;= -2ull; //除去第 0 项,-2的补码为11111111110 //连续的出现在同一块中 for(reg int i=0;i&lt;=m;++i) ans += count(bs[i]&amp;(bs[i]&lt;&lt;1)&amp;(bs[i]&lt;&lt;2)); //连续的出现在不同块中,有两种情况 //x = (i-1)*64 + 62，x+1 = (i-1)*64 + 63，x+2 = i*64 + 0 //x = (i-1)*64 + 63，x+1 = i*64 + 0，x+2 = i*64 + 1 for(reg int i=1;i&lt;=m;++i) ans += count(bs[i]&amp;(bs[i-1]&gt;&gt;62)&amp;((bs[i-1]&gt;&gt;63)|(bs[i]&lt;&lt;1))); cout&lt;&lt;ans; return 0;&#125; 素数Miller Rabin(高精度素数判定)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061bool millerRabin(int n) &#123; if (n &lt; 3 || n % 2 == 0) return n == 2; if (n % 3 == 0) return n == 3; int u = n - 1, t = 0; while (u % 2 == 0) u /= 2, ++t; // test_time 为测试次数，建议设为不小于 8 // 的整数以保证正确率，但也不宜过大，否则会影响效率 for (int i = 0; i &lt; test_time; ++i) &#123; // 0, 1, n-1 可以直接通过测试, a 取值范围 [2, n-2] int a = rand() % (n - 3) + 2, v = quickPow(a, u, n); if (v == 1) continue; int s; for (s = 0; s &lt; t; ++s) &#123; if (v == n - 1) break; // 得到平凡平方根 n-1，通过此轮测试 v = (long long)v * v % n; &#125; // 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t // 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1 if (s == t) return 0; &#125; return 1;&#125;完整版:ll bmul(ll a, ll b, ll m) &#123; // 快速乘 ull c = (ull)a * (ull)b - (ull)((long double)a / m * b + 0.5L) * (ull)m; if (c &lt; (ull)m) return c; return c + m;&#125;ll qpow(ll x, ll p, ll mod) &#123; // 快速幂 ll ans = 1; while (p) &#123; if (p &amp; 1) ans = bmul(ans, x, mod); x = bmul(x, x, mod); p &gt;&gt;= 1; &#125; return ans;&#125;bool Miller_Rabin(ll p) &#123; // 判断素数 if (p &lt; 2) return false; if (p == 2) return true; if (p == 3) return true; ll d = p - 1, r = 0; while (!(d &amp; 1)) ++r, d &gt;&gt;= 1; // 将d处理为奇数 for (ll k = 0; k &lt; 10; ++k) &#123; ll a = rand() % (p - 2) + 2; ll x = qpow(a, d, p); if (x == 1 || x == p - 1) continue; for (int i = 0; i &lt; r - 1; ++i) &#123; x = bmul(x, x, p); if (x == p - 1) break; &#125; if (x != p - 1) return false; &#125; return true;&#125; P5535 【XR-3】小道消息 - 洛谷 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;using ll =long long;using ull=unsigned long long;const int inf=0x3f3f3f3f,N = 1e6 + 5;ll bmul(ll a, ll b, ll m) &#123; // 快速乘 ull c = (ull)a * (ull)b - (ull)((long double)a / m * b + 0.5L) * (ull)m; if (c &lt; (ull)m) return c; return c + m;&#125;ll qpow(ll x, ll p, ll mod) &#123; // 快速幂 ll ans = 1; while (p) &#123; if (p &amp; 1) ans = bmul(ans, x, mod); x = bmul(x, x, mod); p &gt;&gt;= 1; &#125; return ans;&#125;bool Miller_Rabin(ll p) &#123; // 判断素数 if (p &lt; 2) return false; if (p == 2) return true; if (p == 3) return true; ll d = p - 1, r = 0; while (!(d &amp; 1)) ++r, d &gt;&gt;= 1; // 将d处理为奇数 for (ll k = 0; k &lt; 10; ++k) &#123; ll a = rand() % (p - 2) + 2; ll x = qpow(a, d, p); if (x == 1 || x == p - 1) continue; for (int i = 0; i &lt; r - 1; ++i) &#123; x = bmul(x, x, p); if (x == p - 1) break; &#125; if (x != p - 1) return false; &#125; return true;&#125;void solve()&#123; ll n,k; cin&gt;&gt;n&gt;&gt;k; n=n+1; k=k+1; //对n和k进行处理,使得n变成最大标号,k变成其对应的标号 if(Miller_Rabin(k))&#123; //若k为质数 //对于存在其倍数的,需第二天其他质数标记 if(n/k&gt;1)&#123; cout&lt;&lt;&quot;2\\n&quot;; &#125;else&#123; //对于不存在其倍数的,因其是质数,与其他的剩余的数均是互质的 cout&lt;&lt;&quot;1\\n&quot;; &#125; &#125;else&#123; //如果k是合数,则其很明显不能标记它的质因子,需第二天其他质数来标记 cout&lt;&lt;&quot;2\\n&quot;; &#125; &#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; 质因数分解(最朴素的算法)123456789101112vector&lt;int&gt; result;void breakdown(int n)&#123; for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; while(n%i==0)n/=i; result.push_back(i); &#125; &#125; if(n!=1)&#123; result.push_back(n); &#125;&#125; Pollard_Rho算法(找到数x的一个平凡因子)以下配合找到数x的最大质因子1234567891011121314151617181920212223ll max_factor, n;ll gcd(ll a, ll b) &#123; if (b == 0) return a; return gcd(b, a % b);&#125;ll Pollard_Rho(ll x) &#123; ll s = 0, t = 0; ll c = (ll)rand() % (x - 1) + 1; int step = 0, goal = 1; ll val = 1; for (goal = 1;; goal *= 2, s = t, val = 1) &#123; // 倍增优化 for (step = 1; step &lt;= goal; ++step) &#123; t = (bmul(t, t, x) + c) % x; val = bmul(val, abs(t - s), x); if ((step % 127) == 0) &#123; ll d = gcd(val, x); if (d &gt; 1) return d; &#125; &#125; ll d = gcd(val, x); if (d &gt; 1) return d; &#125;&#125; 数学期望[P8774 蓝桥杯 2022 省 A] 爬树的甲壳虫 - 洛谷 期望题 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5,mod=998244353;int f[N];int quick(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res%mod;&#125;void solve()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; f[i]=((f[i-1]+1)%mod*((y%mod)*quick(y-x,mod-2)%mod)%mod)%mod; &#125; cout&lt;&lt;f[n]&lt;&lt;endl;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; AtCoder Link AT_abc360_e Random Swaps of Balls - 洛谷 注意减法的同余原理 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5,mod=998244353;int f[N];int quick(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res%mod;&#125;void solve()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; f[0]=1; for(int i=1;i&lt;=k;i++)&#123; f[i]=(f[i-1]*((n-1)*(n-1)%mod+1)%mod*quick(n*n%mod,mod-2)%mod+(2*quick(n*n%mod,mod-2)*(n*(n+1)/2%mod-f[i-1]%mod+mod)%mod)%mod)%mod; &#125; cout&lt;&lt;f[k]&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t=1; // cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"个人网站搭建","slug":"个人网站搭建","date":"2025-10-26T11:21:18.000Z","updated":"2025-10-28T06:23:46.793Z","comments":true,"path":"post/66fa05f8.html","permalink":"https://sunjing-coder.github.io/second/post/66fa05f8.html","excerpt":"","text":"欢迎来到我的博客这是我用 Hexo + GitHub 搭建的第一个博客文章 【2023最新版】Hexo+github搭建个人博客并绑定个人域名_github搭建hexo博客绑定域名-CSDN博客 网页美化: hexo博客搭建&amp;美化教程 | 深白色的赛博产房 (20 封私信 &#x2F; 33 条消息) Hexo 博客美化合集（不断更新） - 知乎 安装nodejs后进行测试显示如下错误:12345nvm-desktop: command not found: &quot;node&quot;解决:因为是用nvm-desktop对nodejs进行管理所以与大部分的错误不同,我需要在nvm-desktop下载对应的版本以及应用才可显示对应的版本。 express出现在node_cache中:1对node_cache和node_global的命令处理不一样,我把他们的命令弄相同了。 Permission denied (publickey).12345我在密钥那一步显示的是$ ssh -T git@github.comgit@github.com: Permission denied (publickey).请问该怎么解决呢手动把id_rsa.pub里的内容复制到github设置里的SSHkey中 在文档 | Hexo此处安装hexo1以管理员的身份使用命令行安装 hexo init 提示不是安装命令1换成npx hexo init 输入npx hexo init报错123INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git fatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: Recv failure: Connection was reset WARN git clone failed. Copying data instead FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Error: EPERM: operation not permitted, mkdir &#x27;D:\\&#x27; at async Object.mkdir (node:internal/fs/promises:860:10)可能是因为github防火墙问题,重新再试一遍 接着报错Please run ‘npm install’ in “D:\\Blog” folder.123456789INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesWARN Failed to install dependencies. Please run &#x27;npm install&#x27; in &quot;D:\\Blog&quot; folder.发现了一个大问题，居然说找不到npm命令。检查一遍没有错啊，软件安装了啊，用Windows下DOS命令npm -v ,没有发现什么问题。没办法了只有百度，得知安装完nodejs之后配置windows环境变量只能保证在命令行工具中可以使用npm，如果想在git bash中使用需要再安装一遍。 git clone --recursive git://github.com/isaacs/npm.git 接着报错 errno&#x3D;Connection timed out123456789$ git clone --recursive git://[github.com/isaacs.npm.git](https://github.com/isaacs.npm.git) Cloning into &#x27;isaacs.npm&#x27;... fatal: unable to connect to [github.com](https://github.com/): [github.com](https://github.com/)[0: 20.205.243.166]: errno=Connection timed out克隆仓库时遇到了连接超时问题，这通常是网络连接或访问方式的问题。GitHub 支持 `git://`、`https://`、`ssh` 三种协议，`git://` 协议可能被部分网络屏蔽，建议换成 `https://` 协议重试：git clone --recursive https://github.com/isaacs/npm.git 接着报错Please run ‘npm install’ in “D:\\Blog” folder.1已操作以上步骤 直接在git bash(还是之前的路径)输入npm install 启动本地服务器预览博客 12在项目目录（`D:\\Blog`）下执行以下命令，启动 Hexo 本地服务：npx hexo server unable to access ‘https://github.com/sunjing-coder/second.git/‘: Failed to connect to github.com port 443 after 21152 ms: Could not connect to server FATAL Something’s wrong.123456789网络原因打开 `D:\\Blog\\_config.yml`，找到 `deploy` 配置，将 `repo` 改为 SSH 格式：deploy: type: git repo: git@github.com:sunjing-coder/second.git # 注意是 SSH 格式，不是 https branch: main # 确保分支是 main（GitHub 默认分支） github加速访问123在终端以管理员的身份:&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot; --host-rules=&quot;MAP github.com octocaptcha.com, MAP github.githubassets.com yelp.com, MAP *.githubusercontent.com githubusercontent.com&quot; --host-resolver-rules=&quot;MAP octocaptcha.com 20.27.177.113, MAP yelp.com 199.232.240.116, MAP githubusercontent.com 199.232.176.133&quot; hexo部署到github上但是无法显示样式123456D:\\Blog\\_config.yml在这个文件中:url: https://用户名.github.io/仓库名 # 例如 https://abc.github.io/blogroot: /仓库名/ # 必须和仓库名一致，前后都带斜杠，例如 /blog/这块得改 12345再重新部署hexo clean # 清除旧缓存hexo g # 重新生成静态文件（此时资源路径会自动加上 /second/ 前缀）hexo d # 重新部署到 GitHub 撰写文章1234567npx hexo new &quot;文章标题&quot;然后直接用typora打开该文档编辑即可npx hexo cl npx hexo g npx hexo s # 清除缓存 → 生成静态文件 → 启动本地服务器 123npx hexo cl npx hexo g npx hexo d # 清除缓存 → 生成静态文件 → 部署到github上","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2025-10-26T06:02:09.096Z","updated":"2025-10-26T11:09:36.404Z","comments":true,"path":"post/4a17b156.html","permalink":"https://sunjing-coder.github.io/second/post/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}