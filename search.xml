<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/second/post/4a17b156.html</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
  <entry>
    <title>个人网站搭建</title>
    <url>/second/post/66fa05f8.html</url>
    <content><![CDATA[欢迎来到我的博客这是我用 Hexo + GitHub 搭建的第一个博客文章
【2023最新版】Hexo+github搭建个人博客并绑定个人域名_github搭建hexo博客绑定域名-CSDN博客
网页美化:
hexo博客搭建&amp;美化教程 | 深白色的赛博产房
(20 封私信 &#x2F; 33 条消息) Hexo 博客美化合集（不断更新） - 知乎

安装nodejs后进行测试显示如下错误:nvm-desktop: command not found: &quot;node&quot;解决:因为是用nvm-desktop对nodejs进行管理所以与大部分的错误不同,我需要在nvm-desktop下载对应的版本以及应用才可显示对应的版本。




express出现在node_cache中:对node_cache和node_global的命令处理不一样,我把他们的命令弄相同了。




Permission denied (publickey).我在密钥那一步显示的是$ ssh -T git@github.comgit@github.com: Permission denied (publickey).请问该怎么解决呢手动把id_rsa.pub里的内容复制到github设置里的SSHkey中




在文档 | Hexo此处安装hexo以管理员的身份使用命令行安装




hexo init 提示不是安装命令换成npx hexo init




输入npx hexo init报错INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git fatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: Recv failure: Connection was reset WARN  git clone failed. Copying data instead FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Error: EPERM: operation not permitted, mkdir &#x27;D:\&#x27;    at async Object.mkdir (node:internal/fs/promises:860:10)可能是因为github防火墙问题,重新再试一遍




接着报错Please run ‘npm install’ in “D:\Blog” folder.INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependenciesWARN  Failed to install dependencies. Please run &#x27;npm install&#x27; in &quot;D:\Blog&quot; folder.发现了一个大问题，居然说找不到npm命令。检查一遍没有错啊，软件安装了啊，用Windows下DOS命令npm -v ,没有发现什么问题。没办法了只有百度，得知安装完nodejs之后配置windows环境变量只能保证在命令行工具中可以使用npm，如果想在git bash中使用需要再安装一遍。 git clone --recursive git://github.com/isaacs/npm.git




接着报错 errno&#x3D;Connection timed out$ git clone --recursive git://[github.com/isaacs.npm.git](https://github.com/isaacs.npm.git) Cloning into &#x27;isaacs.npm&#x27;... fatal: unable to connect to [github.com](https://github.com/): [github.com](https://github.com/)[0: 20.205.243.166]: errno=Connection timed out克隆仓库时遇到了连接超时问题，这通常是网络连接或访问方式的问题。GitHub 支持 `git://`、`https://`、`ssh` 三种协议，`git://` 协议可能被部分网络屏蔽，建议换成 `https://` 协议重试：git clone --recursive https://github.com/isaacs/npm.git




接着报错Please run ‘npm install’ in “D:\Blog” folder.已操作以上步骤     直接在git bash(还是之前的路径)输入npm install




启动本地服务器预览博客
在项目目录（`D:\Blog`）下执行以下命令，启动 Hexo 本地服务：npx hexo server




unable to access ‘https://github.com/sunjing-coder/second.git/‘: Failed to connect to github.com port 443 after 21152 ms: Could not connect to server FATAL Something’s wrong.网络原因打开 `D:\Blog\_config.yml`，找到 `deploy` 配置，将 `repo` 改为 SSH 格式：deploy:  type: git  repo: git@github.com:sunjing-coder/second.git  # 注意是 SSH 格式，不是 https  branch: main  # 确保分支是 main（GitHub 默认分支）




github加速访问在终端以管理员的身份:&quot;C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe&quot; --host-rules=&quot;MAP github.com octocaptcha.com, MAP github.githubassets.com yelp.com, MAP *.githubusercontent.com githubusercontent.com&quot; --host-resolver-rules=&quot;MAP octocaptcha.com 20.27.177.113, MAP yelp.com 199.232.240.116, MAP githubusercontent.com 199.232.176.133&quot;




hexo部署到github上但是无法显示样式D:\Blog\_config.yml在这个文件中:url: https://用户名.github.io/仓库名  # 例如 https://abc.github.io/blogroot: /仓库名/  # 必须和仓库名一致，前后都带斜杠，例如 /blog/这块得改

再重新部署hexo clean  # 清除旧缓存hexo g      # 重新生成静态文件（此时资源路径会自动加上 /second/ 前缀）hexo d      # 重新部署到 GitHub




撰写文章npx hexo new &quot;文章标题&quot;然后直接用typora打开该文档编辑即可npx hexo cl npx hexo g npx hexo s  # 清除缓存 → 生成静态文件 → 启动本地服务器

npx hexo cl npx hexo g npx hexo d  # 清除缓存 → 生成静态文件 → 部署到github上

]]></content>
  </entry>
  <entry>
    <title>补题</title>
    <url>/second/post/b8f1496f.html</url>
    <content><![CDATA[2025.9.28D-小红的好数对_牛客周赛 Round 111
解题思路:
巧妙枚举
a*10^len(b)+b%11&#x3D;0;
-&gt;
b%11&#x3D;-a*10^len(b);

[!IMPORTANT]
&#x2F;&#x2F;减法取模(A - B) % mod &#x3D;((A % mod) - (B % mod) +mod) % mod

#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;int a[N],sz[N];int p[15];int f[15][11];void init()&#123;    p[0]=1;    for(int i=1;i&lt;=11;i++)&#123;        p[i]=(p[i-1]*10)%11;    &#125;&#125;void solve()&#123;    int n,sum=0;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        sz[i]=to_string(a[i]).size();        f[sz[i]][a[i]%11]++;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=11;j++)&#123;            int t=(-a[i]*p[j]%11+11)%11;            sum+=f[j][t];        &#125;        if((-a[i]*p[sz[i]]%11+11)%11==a[i]%11)sum--;    &#125;    cout&lt;&lt;sum&lt;&lt;&#x27;\n&#x27;;    &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    init();    while(t--)&#123;        solve();    &#125;	return 0;&#125;



E-小芳的排列构造_牛客周赛 Round 111
当时我的难点是不知道如何凑k&#x3D;k-3*n-1,(我采用的是从小到大凑,但在大脑中进行模拟时出现了混乱)
答案给出的是从大往小的凑,通过标记对进行凑k的数进行标记

[!CAUTION]

大数优先的优势：
较大的 i 能提供更多的逆序对贡献（一次选择可减少更多 k 值）
先选大数可以避免 “小数占用位置导致大数无法选择” 的问题
能确保在 k 值较大时，用最少的选择次数凑够目标值




#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;int vis[N];void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    if(n==1&amp;&amp;k==2)&#123;        cout&lt;&lt;1&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    k-=(3*n-1);    vector&lt;int&gt;vec;    for(int i=n-2;i&gt;=1;i--)&#123;        if(k&gt;=i)&#123;            k-=i;            vis[i]=1;            vec.push_back(i);        &#125;        if(k&lt;=0)break;    &#125;    if(k!=0)&#123;        cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    for(int i=vec.size()-1;i&gt;=0;i--)&#123;        cout&lt;&lt;vec[i]&lt;&lt;&#x27; &#x27;;    &#125;    cout&lt;&lt;n-1&lt;&lt;&#x27; &#x27;;    for(int i=1;i&lt;=n-2;i++)&#123;        if(!vis[i])cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;    &#125;    cout&lt;&lt;n&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;//     cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

F-小红的排列构造_牛客周赛 Round 111
&#x2F;&#x2F;构造题
&#x2F;&#x2F;先a[i]和a[n-i+1]交换
&#x2F;&#x2F;在从a[i]依次往后交换
&#x2F;&#x2F;因为发现了实施这种方案的最多交换次数是n-1,再交换一次会使得其中一个数归为
&#x2F;&#x2F;题解使用位运算
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e5 + 5;int a[N];void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    if((n+1)/2&gt;k||k&gt;n-1)&#123;        cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    for(int i=1;i&lt;=n;i++)a[i]=i;    for(int i=1;i&lt;=n/2;i++)&#123;        int t=a[i];        a[i]=a[n-i+1];        a[n-i+1]=t;    &#125;    if(n%2!=0)&#123;        int t=a[n/2];        a[n/2]=a[n/2+1];        a[n/2+1]=t;        k--;    &#125;    k-=n/2;    int i=1,flag=1;    while(k--)&#123;        if(i+1&gt;n)&#123;            flag=0;            break;        &#125;        int t=a[i];        a[i]=a[i+1];        a[i+1]=t;        i++;    &#125;    if(flag==0)&#123;        cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;//     cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



2025.10.7D-Digital Pairing_牛客周赛 Round 112
&#x2F;&#x2F;在保留前面结果的同时,进行假设如果,假设成立则该位有1
&#x2F;&#x2F;新知识:如何在某数的某一位置1
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 4e5 + 5;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;int&gt;vec(2*n+1);    for(int i=1;i&lt;=2*n;i++)&#123;        cin&gt;&gt;vec[i];    &#125;    int ans=0;    for(int i=31;i&gt;=0;i--)&#123;        int cnt=0,cand=ans|(1&lt;&lt;i);        for(int j=1;j&lt;=2*n;j++)&#123;            if((cand&amp;vec[j])==cand)cnt++;        &#125;        if(cnt&gt;=n)ans=cand;    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



E-Beautiful Sequence_牛客周赛 Round 112
&#x2F;&#x2F;感觉的数学很好才能做,组合数学功底厚实,找规律的功底厚实
&#x2F;&#x2F;1 1 3 4
2^3+2^2&#x3D;(c(2,0)+c(2,1)+c(2,2))*3
&#x2F;&#x2F;根据答案改错之后一直错误很可能的原因就是超时
&#x2F;&#x2F;对2的幂进行预处理
&#x2F;&#x2F;不用i64也行,long long也行
#include &lt;bits/stdc++.h&gt;using namespace std;using i64 = int64_t;const i64 inf=0x3f3f3f3f,N = 2e5 + 1,mod=998244353;i64 cnt[N];i64 pw[N];void solve()&#123;    int n;    cin&gt;&gt;n;    memset(cnt,0,sizeof(cnt));    for(int i=1;i&lt;=n;i++)&#123;        int a;        cin&gt;&gt;a;        cnt[a]++;    &#125;    i64 ans=(pw[n]%mod-1%mod+mod)%mod;    for(int i=1;i&lt;=N;i++)&#123;        if(cnt[i])&#123;            int len=cnt[i];            int st=cnt[i];            for(int j=i+i;j&lt;=N;j+=i)&#123;                len+=cnt[j];            &#125;            for(int j=1;j&lt;=st;j++)&#123;                ans =((ans % mod) - (pw[len-j] % mod) +mod) % mod;            &#125;        &#125;    &#125;    cout&lt;&lt;ans%mod&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    pw[0]=1;    for(int i=1;i&lt;=N;i++)&#123;        pw[i]=(pw[i-1]*2)%mod;    &#125;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

F-Bracket Counting_牛客周赛 Round 112
&#x2F;&#x2F;dp题
没做

2025.10.13Dashboard - 2022年中国大学生程序设计竞赛女生专场 - Codeforces
//https://codeforces.com/gym/104081/problem/G#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 5e5 + 5;struct node&#123;    int t,x;&#125;arr[N];bool cmp(node a,node b)&#123;    return a.t&lt;b.t;&#125;void solve()&#123;    int t,n,m,k;    cin&gt;&gt;t&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;arr[i].t&gt;&gt;arr[i].x;    &#125;    arr[m+1].t=t;    arr[m+1].x=0;    sort(arr+1,arr+1+m+1,cmp);    int ans=inf,mark=0,s=0,people=0,gap;    for(int i=1;i&lt;=m+1;i++)&#123;//没考虑gap,导致之前的代码结果一致错误        gap=arr[i].t-s-1;        people=people-gap*k;        people=max(people,0ll);        // cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;people&lt;&lt;&#x27; &#x27;;        if(arr[i].x==0&amp;&amp;people!=n)&#123;            cout&lt;&lt;&quot;Wrong Record\n&quot;;            return;        &#125;        people+=arr[i].x;        if(arr[i].x!=0&amp;&amp;arr[i].t&gt;=t)&#123;            int t=(people+1)/k+((people+1)%k!=0);            if(t&lt;=ans)&#123;                mark=arr[i].t;                ans=t;            &#125;        &#125;        people=max(people-k,0ll);        s=arr[i].t;    &#125;    cout&lt;&lt;mark&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



再次把题目理解错了,wi的i并不是经过节点的下标,我所需要加入的wi是我所经过的节点个数k的w(i从1到k-1)的和
用dis[i] [j]表示从1到 i 不包括1所经过的检点个数。

[!NOTE]
vector v(5); &#x2F;&#x2F; 5个元素，默认值为0 vector v(5, 10); &#x2F;&#x2F; 5个元素，每个元素的值为10
vector&lt;vector&gt; vv(3, vector(4, 1));

vector&lt;vector&gt;dis(n+1,vector(n+1,inf));  vector双重循环inf可达1e18,但是如果开数组使用memset(dis,inf,sizeof(dis))会出现我目前不知的错误
//https://codeforces.com/gym/104081/problem/H#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=1e18,N = 500 + 5;int dis[N][N];int W[N];void solve()&#123;    memset(dis,0x3f3f3f3f,sizeof(dis));    int n,m;    cin&gt;&gt;n&gt;&gt;m;    vector&lt;vector&lt;pair&lt;int,int&gt;&gt; &gt;arr(n+1);    for(int i=0;i&lt;m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        arr[u].push_back(&#123;v,w&#125;);        arr[v].push_back(&#123;u,w&#125;);    &#125;    dis[1][0]=0;    for(int k=0;k&lt;n-1;k++)&#123;        for(int i=1;i&lt;=n;i++)&#123;            for(auto [v,w]:arr[i])&#123;                // cout&lt;&lt;dis[v][k+1]&lt;&lt;&quot; &quot;&lt;&lt;dis[i][k]+w&lt;&lt;endl;                dis[v][k+1]=min(dis[v][k+1],dis[i][k]+w);                            &#125;        &#125;    &#125;    int q;    cin&gt;&gt;q;    while(q--)&#123;        int t;        cin&gt;&gt;t;        memset(W,0,sizeof(W));        for(int i=1;i&lt;=n-1;i++)&#123;            int a;            cin&gt;&gt;a;            W[i]=a+W[i-1];        &#125;        int ans=inf;        for(int i=1;i&lt;=n-1;i++)&#123;            ans=min(ans,W[i]+dis[t][i]);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

2025.10.16//https://codeforces.com/gym/105386/problem/A#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 4e5 + 5;struct node&#123;    int r;    vector&lt;int&gt;vec;    int sum=0;    int id;    bool mark=false;//标记一下是否出现-1,减一下枝&#125;;bool cmp(node a,node b)&#123;    return a.r&lt;b.r;&#125;bool cmp1(node a,node b)&#123;    return a.id&lt;b.id;&#125;void solve()&#123;    int n,m,k;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    vector&lt;node&gt;arr(n+5);    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i].r;        arr[i].id=i;        for(int j=1;j&lt;=m;j++)&#123;            int x;            cin&gt;&gt;x;            arr[i].vec.push_back(x);            if(x!=-1)arr[i].sum+=x;            else arr[i].mark=true;        &#125;    &#125;    int las=-1;//这里非常关键    //当第一次碰到遇到有-1的时候,如果设las=0,则t=0+1    sort(arr.begin()+1,arr.begin()+1+n,cmp);    for(int i=1;i&lt;=n;i++)&#123;        int j=i;        while(j+1&lt;=n&amp;&amp;arr[j+1].r==arr[j].r)j++;        //具有相同星级的队伍,不更新las        for(int u=i;u&lt;=j;u++)&#123;            if(arr[u].mark==false)&#123;                if(arr[u].sum&lt;=las)&#123;                    cout&lt;&lt;&quot;No\n&quot;;                    return ;                &#125;                continue;            &#125;            int t=max(las+1-arr[u].sum,0ll);            for(int o=0;o&lt;m;o++)&#123;                if(arr[u].vec[o]==-1)&#123;                    int temp=min(k,t);                    arr[u].vec[o]=temp;                    arr[u].sum+=temp;                    t-=temp;                &#125;            &#125;            if(t&gt;0)&#123;                cout&lt;&lt;&quot;No\n&quot;;                return;            &#125;        &#125;        for(int u=i;u&lt;=j;u++)las=max(las,arr[u].sum);        i=j;    &#125;        cout&lt;&lt;&quot;Yes\n&quot;;        sort(arr.begin()+1,arr.begin()+1+n,cmp1);        for(int i=1;i&lt;=n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                cout&lt;&lt;arr[i].vec[j]&lt;&lt;&quot; &quot;;            &#125;            cout&lt;&lt;&quot;\n&quot;;        &#125;    &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

2025.10.182023年ns
//对于上下叠加//一块运动的处理https://codeforces.com/gym/104725/problem/A#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123;    int n=12;    vector&lt;int&gt;v[10];    v[2].push_back(1);    v[3].push_back(2);    v[4].push_back(3);    int mp[4];    mp[1]=2;    mp[2]=3;    mp[3]=4;    while(n--)&#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        int now=mp[a];        int nex=mp[a]+b;        int len=v[now].size();        int pos;        for(int j=0;j&lt;len;j++)&#123;            if(v[now][j]==a)&#123;pos=j;break;&#125;        &#125;        for(int j=pos;j&lt;len;j++)&#123;            mp[v[now][j]]=nex;            v[nex].push_back(v[now][j]);        &#125;        for(int j=pos;j&lt;len;j++)&#123;            v[now].pop_back();        &#125;    &#125;    if(v[9].size()==3)&#123;        cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;&quot;N&quot;&lt;&lt;endl;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



从1开始,依次将Lis长度相同为i的序号存入cnt[i],
//https://codeforces.com/gym/104725/problem/F#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n;vector&lt;int&gt;cnt[N],ans(N+1),arr(N+1);void solve()&#123;    int Max=0;    cin&gt;&gt;n;    bool flag=false;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        if(arr[i]&gt;Max+1)&#123;            flag=true;        &#125;else&#123;           Max=max(Max,arr[i]);        &#125;         cnt[arr[i]].push_back(i);    &#125;    if(flag)&#123;        cout&lt;&lt;&quot;-1\n&quot;;        return;    &#125;    int num=1;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=cnt[i].size()-1;j&gt;=0;j--)&#123;            ans[cnt[i][j]]=num++;        &#125;        if(cnt[i].empty())&#123;            break;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



2025.10.19Problem - F - Codeforces
以短竖线为讨论的基点
字母只可能为’a’,’b’
原因:短竖线两侧只可能是两个相同的字母或是不同的字母,
若以未知字母作为讨论基点则情况可能更加复杂,易出错
逻辑:若i处是’|’,box[i]&gt;1则说明’|’两侧字母相同,box[i]&lt;&#x3D;1则说明’|’两侧字母不相同
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e6 + 10;char arr[N];int box[N];void solve()&#123;    int n;    cin&gt;&gt;n;    arr[0]=&#x27;&amp;&#x27;;    arr[2]=&#x27;a&#x27;;    for(int i=0;i&lt;2*n+2;i++)cin&gt;&gt;box[i];    for(int i=1;i&lt;2*n+2;i++)&#123;        if(i%2==1)&#123;            arr[i]=&#x27;|&#x27;;            if(box[i]&gt;1)&#123;                arr[i+1]=arr[i-1];            &#125;else&#123;                if(arr[i-1]==&#x27;a&#x27;)&#123;                    arr[i+1]=&#x27;b&#x27;;                &#125;else&#123;                    arr[i+1]=&#x27;a&#x27;;                &#125;            &#125;        &#125;    &#125;    string s=&quot;&quot;;    for(int i=0;i&lt;2*n+2;i++)&#123;        if(arr[i]==&#x27;a&#x27;||arr[i]==&#x27;b&#x27;)s+=arr[i];    &#125;    cout&lt;&lt;s&lt;&lt;endl;    &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

Problem - K - Codeforces
除1以外的人,胜利的概率是一样的,以2号为例
若1掷出x,则2一次性胜利的概率为(m-x)&#x2F;m;
若前i-1次都掷出x,则第i次胜利的概率为1&#x2F;m^(i-1)*(m-x)&#x2F;m;
则2胜利的概率为求和i从1到无穷大(m-x)&#x2F;m^i;
转化为对1&#x2F;m^i   i趋近于无穷的极限,得1&#x2F;(m-1);
又因为其他(n-1)个人和2一样故1输的概率就为()(m-x)&#x2F;(m-1))^n;
#include &lt;bits/stdc++.h&gt;using namespace std;using LL=long long;const int inf=0x3f3f3f3f,N = 1e6 + 5;LL mod=998244353;LL qkpow(LL a,LL p)&#123;	LL t=1,tt=a%mod;	while(p)	&#123;		if(p&amp;1)t=t*tt%mod;		tt=tt*tt%mod;		p&gt;&gt;=1;	&#125;	return t;&#125;LL getInv(LL a)&#123;	return qkpow(a,mod-2);&#125;void solve()&#123;    int n,m;	cin&gt;&gt;n&gt;&gt;m;	for(int i=1;i&lt;=m;i++)&#123;		cout&lt;&lt;((qkpow((m-i),n)%mod*getInv(qkpow((m-1),n)%mod)%mod)%mod)&lt;&lt;&#x27; &#x27;;	&#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

2025.10.24Problem - J - Codeforces
这道题的关键是要理解同构
如果我们每次的操作对象是叶子结点,得到的新图实际上与上个图是同构的,这个我们很容易想明白。
也就是说我们要得到一个与上一个图不同构的图我们需要操作非叶子节点,然后把它变成叶子节点,显然新得到的图与上一个图不同构,并且我们每次操作只能使得一个非叶子结点变成叶子结点。
所以最后的赢家与非叶子节点的数量的奇偶性有关,(n&lt;&#x3D;3是永远是Bob赢)为奇数则Bob,为偶数则Alice
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int arr[55];void solve()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n-1;i++)    &#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        arr[a]++;        arr[b]++;    &#125;    if(n&lt;=3)&#123;        cout&lt;&lt;&quot;Bob\n&quot;;        return ;    &#125;    int cnt=0;    for(int i=1;i&lt;=n;i++)&#123;        if(arr[i]&gt;1)cnt++;    &#125;    cout&lt;&lt;(cnt%2==0?&quot;Alice&quot;:&quot;Bob&quot;)&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

2025.10.27Problem - E - Codeforces
一开始就想到要用前缀这方面的内容,虽然想法并不完善
我这道题没意识到的点:

x,y可以分别处理,每处理一次都只是一次单方向处理,最后对结果直接*2输出

如果对x,y一起处理就会麻烦很多,前缀和和后缀和很可能都不会派上太大的用处

ans+&#x3D;points[i].first*i- pre[i-1];   前缀加了几个数就用几个points[i].first减


#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int pre[N*N];void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    map&lt;int,vector&lt; pair&lt;int,int&gt;&gt;&gt; mp;       for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            int x;            cin&gt;&gt;x;            mp[x].push_back(&#123;i,j&#125;);        &#125;    &#125;    int ans=0;    for(auto [val,points]:mp)&#123;        int len=points.size();        if(len&lt;=1)continue;        pre[0]=points[0].first;        for(int i=1;i&lt;len;i++)&#123;            pre[i]=pre[i-1]+points[i].first;            ans+=points[i].first*i- pre[i-1];        &#125;        sort(points.begin(),points.end(),[&amp;](auto a,auto b)&#123;return a.second&lt;b.second;&#125;);        pre[0]=points[0].second;        for(int i=1;i&lt;len;i++)&#123;            pre[i]=pre[i-1]+points[i].second;            ans+=points[i].second*i- pre[i-1];        &#125;    &#125;    cout&lt;&lt;ans*2&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

Problem - J - Codeforces
思想:枚举
目标:最大和次大的权值和最小
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=2e18,N = 3e5 + 5,M = 1e6+5;struct node&#123;    int u,v,w;&#125; arr[M];//记录原始数据struct edge&#123;    int to,next,w;&#125;e[M&lt;&lt;1];//记录边,e[i]  i-&gt;to 从i点到to点,用next记录下一个节点,采用的是头插法,最初的head[i]值为0void add(int u,int v,int w)&#123;    e[++tot]=&#123;v,head[u],w&#125;;    head[u]=tot;&#125;int n,m,head[N],tot,vis[N];void dijkstra(int s,int *dis)&#123;    priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt;q;//小根堆    q.push(&#123;0,s&#125;);    for(int i=1;i&lt;=n;i++)&#123;dis[i]=inf;vis[i]=0;&#125;    dis[s]=0;    while(!q.empty())&#123;        auto [d,u]=q.top();        q.pop();        if(vis[u])continue;        vis[u]=1;        for(int i=head[u];i;i=e[i].next)&#123;            int v=e[i].to;            int w=max(d,e[i].w);            //s-&gt;u-&gt;v  w为这两段中最大的            if(dis[v]&gt;w)&#123;//我们寻找到s-&gt;v中最小的                dis[v]=w;                q.push(&#123;w,v&#125;);            &#125;        &#125;    &#125;&#125;int dis1[N],dis2[N];void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)head[i]=0;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;arr[i].u&gt;&gt;arr[i].v&gt;&gt;arr[i].w;        add(arr[i].u,arr[i].v,arr[i].w);        add(arr[i].v,arr[i].u,arr[i].w);    &#125;    dijkstra(1,dis1);    dijkstra(n,dis2);    //方便后续将路径分为 1-&gt;u-&gt;v-&gt;n    //1-&gt;v-&gt;u-&gt;n;    int ans=inf;    for(int i=1;i&lt;=m;i++)&#123;        int u=arr[i].u,v=arr[i].v,w=arr[i].w;        int temp=min(max(dis1[u],dis2[v]),max(dis1[v],dis2[u]));        if(temp&lt;=w)&#123;//若w作为最大值则进入,枚举了每个w能不能作为最大值            ans=min(ans,w+temp);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

]]></content>
  </entry>
  <entry>
    <title>ACM成长</title>
    <url>/second/post/a03e0b58.html</url>
    <content><![CDATA[答应我都来打ACM好吗?模版#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123;    &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



对浮点的处理const double pi&#x3D;acos(-1,0)&#x2F;&#x2F;或者2*acos(0);
[!CAUTION]
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf = 0x3f3f3f3f;const double EPS = 1e-8; const int MAX_DEPTH = 20;double jie(double x) &#123; if (x &lt;= 0 || fabs(x - round(x)) &gt; EPS) &#123;     return -1;  &#125; int n = (int)round(x); if (x &gt; 20) return -1; int res = 1; for (int i = n; i &gt;= 1; i--) &#123;     res *= i; &#125; return res;&#125;stack&lt;string&gt; st; bool found = false; bool equals(double a, double b) &#123; return fabs(a - b) &lt; EPS;&#125;void dfs(double x, int depth) &#123; if (found || depth &gt; MAX_DEPTH) &#123;     return; &#125; if (equals(x, 3.0)) &#123;     found = true;     cout &lt;&lt; &quot;YES\n&quot;;     cout &lt;&lt; &quot;操作路径: &quot;;     vector&lt;string&gt; path;     while (!st.empty()) &#123;         path.push_back(st.top());         st.pop();     &#125;     reverse(path.begin(), path.end());     for (const auto&amp; op : path) &#123;         cout &lt;&lt; op &lt;&lt; &quot; -&gt; &quot;;     &#125;     cout &lt;&lt; &quot;3\n&quot;;     return; &#125; double next = sqrt(x); if (next &gt; 0) &#123;     st.push(&quot;sqrt(&quot; + to_string((int)round(x)) + &quot;)&quot;);     dfs(next, depth + 1);     if (!found) st.pop();     else return; &#125; next = ceil(x); if (next != x) &#123;      st.push(&quot;ceil(&quot; + to_string(x) + &quot;)&quot;);     dfs(next, depth + 1);     if (!found) st.pop();     else return; &#125; // 尝试阶乘操作 next = jie(x); if (next != -1) &#123;     st.push(&quot;jie(&quot; + to_string((int)round(x)) + &quot;)&quot;);     dfs(next, depth + 1);     if (!found) st.pop();     else return; &#125;&#125;void solve() &#123; dfs(4.0, 0);&#125;signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; // cin &gt;&gt; t; while (t--) &#123;     solve(); &#125; return 0;&#125;#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5,MAX_Depth=20;const double eps=1e-8;bool equal(double a,double b)&#123; return fabs(a-b)&lt;eps;&#125;stack&lt;string&gt;st;double jie(double x)&#123; if(x&lt;=0||fabs(x-round(x)&gt;eps))return -1; int n=(int)round(x); if(x&gt;20)return -1; int res=1; for(int i=n;i&gt;=1;i--)&#123;     res*=i; &#125; return res;&#125;void dfs(double x,int dep)&#123; if(dep&gt;MAX_Depth)return; if(equal(x,3.0))&#123;     queue&lt;string&gt;q;     while(!st.empty())&#123;         q.push(st.top());         st.pop();     &#125;     cout&lt;&lt;&quot;3 :&quot;;     while(!q.empty())&#123;         cout&lt;&lt;q.front()&lt;&lt;&quot;--&gt;&quot;;         q.pop();     &#125;		exit(0); &#125; double next=sqrt(x); if(next&gt;0)&#123;     st.push(&quot;sqrt&quot;);     dfs(next,dep+1);     st.pop(); &#125; next=ceil(x); if(next!=x)&#123;     st.push(&quot;ceil&quot;);     dfs(next,dep+1);     st.pop(); &#125; next=jie(x); if(next!=-1)&#123;     st.push(&quot;jie&quot;);     dfs(next,dep+1);     st.pop(); &#125;&#125;void solve()&#123; dfs(4.0,0);&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1; // cin&gt;&gt;t; while(t--)&#123;     solve(); &#125;	return 0;&#125;


取模&#x2F;同余原理&#x2F;求逆元(A + B) % mod = ((A % mod) + (B % mod)) % mod(A * B) % mod = ((A % mod) * (B % mod)) % mod//减法取模    (A - B) % mod =((A % mod) - (B % mod) +mod) % mod//除法取模(A / B) % mod = ((A % mod) * (inv(B) % mod)) % mod    LL qkpow(LL a,LL p,LL mod)&#123;	LL t=1,tt=a%mod;	while(p)	&#123;		if(p&amp;1)t=t*tt%mod;		tt=tt*tt%mod;		p&gt;&gt;=1;	&#125;	return t;&#125;LL getInv(LL a,LL mod)&#123;	return qkpow(a,mod-2,mod);&#125;

878. 第 N 个神奇数字 - 力扣（LeetCode）
//二分答案-&gt;检验答案好统计//简单的容斥原理class Solution &#123;public:long long mod=1e9+7;    int nthMagicalNumber(int n, int a, int b) &#123;        long long mid;        long long l=0,r=(long long)n*min(a,b);        long long gcd=__gcd(a,b);        long long lcm=a/gcd*b;        while(l&lt;=r)&#123;            mid=(l+r)&gt;&gt;1;            if((mid/a+mid/b-mid/lcm)&gt;=n)&#123;//容斥原理                r=mid-1;            &#125;else&#123;                l=mid+1;            &#125;        &#125;        return (int)(l%mod);    &#125;&#125;;



异或运算1.袋子里一共a个白球,b个黑球,每次从袋子里拿2个求,每个球每次被拿出的机会均等,如果拿出的是2个白球或者2个黑球,那么就往袋子里重新放入1个白球,如果拿出的是1个白球和1个黑球,那么就往袋子里重新放入一个黑球,那么最终袋子里只会剩下一个球,请问最终的球是黑的概率是多少?    黑球:1    白球:0    最终球的颜色取决于:黑球数量为奇数概率100%        黑球数量为偶数概率0%                2.异或运算:数值交换    在数组中保证a,b为两个下标不同的数  a=a^b;  b=a^b;  a=a^b;3.一个数异或上它的相反数:可以得到它仅保留最右侧1的数字状态    4.找在一个数组中出现奇数次数的a和奇数次数的b 先所有异或:得到a^b这个结果 (a^b)^(~(a^b)) 这个结果必然存在某个x数位上为1,故我们再次将数组分为x数位上为1和不为1的,遍历数位x上为1的数最后的结果即为a,b=a^b^a;

位运算201. 数字范围按位与 - 力扣（LeetCode）
//主要思想是关注保留下来的1class Solution &#123;public:    int rangeBitwiseAnd(int left, int right) &#123;        while(left&lt;right)&#123;            right-=(right&amp;-right);        &#125;        return right;    &#125;&#125;;

190. 颠倒二进制位 - 力扣（LeetCode）
//采用分治思想//abcdefgh//两个为一组,交换组内元素的位置badcfehg//四个为一组,大组内在两个为一小组,交换两个小组dcbahgfe//同理hgfedcba//第一个操作中:&amp;上10101010右移class Solution &#123;public:    uint32_t reverseBits(uint32_t n) &#123;  // 使用uint32_t确保无符号性        n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1);        n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2);        n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4);        n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8);        n = (n &gt;&gt; 16) | (n &lt;&lt; 16);        return n;    &#125;&#125;;

461. 汉明距离 - 力扣（LeetCode）
//统计一个数的二进制有多少个1//一位中统计1的个数,二位中统计1的个数,四位中统计1的个数,八位中统计1的个数,16位中统计1的个数,最后返回32位中1的个数class Solution &#123;public:    int hammingDistance(int x, int y) &#123;        return solve(x^y);    &#125;    int solve(int x)&#123;        x=(x&amp;0x55555555)+((x&gt;&gt;1)&amp;0x55555555);        x=(x&amp;0x33333333)+((x&gt;&gt;2)&amp;0x33333333);        x=(x&amp;0x0f0f0f0f)+((x&gt;&gt;4)&amp;0x0f0f0f0f);        x=(x&amp;0x00ff00ff)+((x&gt;&gt;8)&amp;0x00ff00ff);        x=(x&amp;0x0000ffff)+((x&gt;&gt;16)&amp;0x0000ffff);        return x;    &#125;&#125;;



1.贪心////骑士的工作//// //每位骑士只能杀一个头//// //贪心策略:尽量雇花费少的//// #include &lt;bits/stdc++.h&gt;//// using namespace std;//// #define asd(i,a,b) for(int i=a;i&lt;=b;i++)//// #define int long long//// const int inf=0x3f3f3f3f,N = 2e4 + 5;//// int Size[N];//// int v[N];//// void solve()&#123;////     int n,m;////     cin&gt;&gt;n&gt;&gt;m;////     for(int i=1; i&lt;=n; i++)&#123;////         cin&gt;&gt;Size[i];////     &#125;////     for(int i=1; i&lt;=m; i++)&#123;////         cin&gt;&gt;v[i];////     &#125;////     sort(v+1,v+m+1);////     sort(Size+1,Size+n+1);////     int l=1,ans=0,i;////     for(i=1;i&lt;=n;i++)&#123;////         while(l&lt;=m&amp;&amp;Size[i]&gt;v[l])&#123;////             l++;////         &#125;////         if(l&gt;m) break;////         ans+=v[l];////         l++;////     &#125;////     if(i!=n+1)&#123;////         cout&lt;&lt;&quot;you died!&quot;&lt;&lt;endl;////     &#125;////     else cout&lt;&lt;ans&lt;&lt;endl;//// &#125;//// signed main()//// &#123;//// 	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);//// 	int t=1;////     // cin&gt;&gt;t;////     while(t--)&#123;////         solve();////     &#125;//// 	return 0;//// &#125;////////#include &lt;bits/stdc++.h&gt;//using namespace std;//#define asd(i,a,b) for(int i=a;i&lt;=b;i++)//#define int long long//const int inf=0x3f3f3f3f,N = 1e6 + 5;//int a[N];//void solve()&#123;//    int n;//    cin&gt;&gt;n;//    for(int i=1;i&lt;=n;i++)&#123;//        cin&gt;&gt;a[i];//    &#125;//    int ans=0,l=1;//    while(l&lt;=n)&#123;//        if(ans%2==0)&#123;//            while(a[l]==0&amp;&amp;l&lt;=n)l++;//        &#125;else&#123;//            while(a[l]==1&amp;&amp;l&lt;=n)l++;//        &#125;//        ans++;//    &#125;//    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;//&#125;//signed main()//&#123;//	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);//	int t=1;//    // cin&gt;&gt;t;//    while(t--)&#123;//        solve();//    &#125;//	return 0;//&#125;//一个人可能与多个人说话(1),但不一定会和周围的人说话(2)//若用两两标记则与(1)相悖,标记被打乱,若只要标记就认为他们一定会说话则与(2) 相悖 //#include &lt;bits/stdc++.h&gt;//using namespace std;//#define asd(i,a,b) for(int i=a;i&lt;=b;i++)//#define int long long//const int inf=0x3f3f3f3f,N = 1e3+ 5;//int mark[N][N];//struct B&#123;//    int num;//    int cnt=0;//&#125;r[2005],c[2005];//bool cmp(B a,B b)&#123;//    return a.cnt&gt;b.cnt;//&#125;//bool cmp1(B a,B b)&#123;//    return a.num&lt;b.num;//&#125;//void solve()&#123;//    int m,n,k,l,d;//    cin&gt;&gt;m&gt;&gt;n&gt;&gt;k&gt;&gt;l&gt;&gt;d;//    for(int i=1;i&lt;=d;i++)&#123;//        int x,y,x1,y1;//        cin&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1;//        if(x==x1)&#123;//            c[min(y,y1)].num=min(y,y1);//            c[min(y,y1)].cnt++;//        &#125;//        if(y==y1)&#123;//            r[min(x,x1)].num=min(x,x1);//            r[min(x,x1)].cnt++;//        &#125;//    &#125;//    sort(r+1,r+m+1,cmp);//    sort(c+1,c+n+1,cmp);//    sort(r+1,r+k+1,cmp1);//    sort(c+1,c+l+1,cmp1);//    for(int i=1;i&lt;=k-1;i++)&#123;//        cout&lt;&lt;r[i].num&lt;&lt;&quot; &quot;;//    &#125;//    cout&lt;&lt;r[k].num&lt;&lt;&#x27;\n&#x27;;//    for(int i=1;i&lt;=l-1;i++)&#123;//        cout&lt;&lt;c[i].num&lt;&lt;&quot; &quot;;//    &#125;//    cout&lt;&lt;c[l].num&lt;&lt;endl;//&#125;////signed main()//&#123;//	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);//	int t=1;//    // cin&gt;&gt;t;//    while(t--)&#123;//        solve();//    &#125;//	return 0;//&#125;//P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e4 + 5;void solve()&#123;    int n,a;    cin&gt;&gt;n;   //创建优先队列从小到大排序    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a;        pq.push(a);    &#125;    int ans=0;    while(pq.size()&gt;1)&#123;        int x=pq.top();        pq.pop();        int y=pq.top();        pq.pop();        ans+=x+y;        pq.push(x+y);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1106 删数问题#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123;    string s;    int k;    cin&gt;&gt;s&gt;&gt;k;    stack&lt;char&gt; st;    char x;    for(int i=0;i&lt;s.size();i++)&#123;        if(!st.empty())x=st.top();        else&#123;        	st.push(s[i]);        	continue;		&#125;		        if(s[i]&lt;x&amp;&amp;k&gt;0)&#123;            st.pop();            k--;            i--;            //i--是因为此处的i值还应与st中的top()进行比较            //从而让st中的数值呈现递减的状态        &#125;        else st.push(s[i]);    &#125;    while(k--)&#123;        st.pop();        //删完k个数    &#125;    stack&lt;char&gt; st1;    while(!st.empty())&#123;    	st1.push(st.top());    	st.pop();        //将st中的数值倒序存入st1中,以便删除前导零    &#125;	while(!st1.empty()&amp;&amp;st1.top()==&#x27;0&#x27;)&#123;		st1.pop();        //删除前导零	&#125;	string ans=&quot;&quot;;    if(st1.empty())&#123;        cout&lt;&lt;0&lt;&lt;endl;        return;    &#125;    while(!st1.empty())&#123;    	ans+=st1.top();    	st1.pop();	&#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//最完全的替换//找到t中第一个出现1的位置//贪心策略:从高位到低位遍历#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;void solve()&#123;    int n,m,first=0;	cin&gt;&gt;n&gt;&gt;m;	string s,t;	cin&gt;&gt;s&gt;&gt;t;	for(int i=0;i&lt;m;i++)&#123;		if(t[i]==&#x27;1&#x27;)&#123;			first=i;			break;		&#125;	&#125;	int len = m-first-1;	int ans=0;	for(int i=0;i&lt;n;i++)&#123;		if(s[i]==&#x27;1&#x27;&amp;&amp;i+len&lt;n)&#123;			ans++;			for(int j=first;j&lt;m;j++)&#123;				if(t[j]==s[i+j-first])&#123;					s[i+j-first]=&#x27;0&#x27;;				&#125;else s[i+j-first]=&#x27;1&#x27;;			&#125;		&#125;	&#125;	for(int i=0;i&lt;n;i++)&#123;		if(s[i]==&#x27;1&#x27;)&#123;			cout&lt;&lt;&quot;-1\n&quot;;			return ;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//子序列//保持区间最大,减去杂数#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e6 + 5;int a[N], pos[N];void solve()&#123;    int n;    cin&gt;&gt;n;	for(int i=1;i&lt;=n;i++)&#123;		cin&gt;&gt;a[i];		pos[a[i]]=i;	&#125;	int ans=1,mn=pos[n],mx=pos[n];	for(int i=n-1;i&gt;=1;i--)&#123;		mn=min(mn,pos[i]),mx=max(mx,pos[i]);		ans=max(ans,mx-mn+1-(n-i-1));	&#125;	cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1843 奶牛晒衣服//为什么会想到二分答案:求的是晒每件衣服中所花费时间中最大时间的最小值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 5e5 + 5;int n,a,b;int w[N];bool check(int x)&#123;    //x即是最大的花费时间,也是烘干能使用的最大次数    //那些地方必须的用烘干才用,若用超了这说明不行    int cnt=0;    for(int i=1;i&lt;=n;i++)&#123;        int re=max(0ll,w[i]-x*a);        if(re==0)continue;        cnt+=re/b+(re%b==0?0:1);        if(cnt&gt;x)return false;    &#125;    return true;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];    int l=0,r=5e5+1;    while(l&lt;=r)&#123;        int mid=l+(r-l)/2;        if(check(mid))&#123;            r=mid-1;        &#125;        else&#123;            l=mid+1;        &#125;    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



2.01背包  搞清楚谁是容积谁是价值//P1048 [NOIP 2005 普及组] 采药#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e2 + 5;int ttime[N],val[N],dp[1005];void solve()&#123;    int t,m;    cin&gt;&gt;t&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;ttime[i]&gt;&gt;val[i];    &#125;    for(int i=1;i&lt;=m;i++)&#123;        for(int j=t;j&gt;=ttime[i];j--)&#123;            dp[j]=max(dp[j],dp[j-ttime[i]]+val[i]);        &#125;    &#125;    cout&lt;&lt;dp[t]&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1060 [NOIP 2006 普及组] 开心的金明#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 3e4 + 5;int w[30],v[30],dp[N];//w是价格,v代表价格和重要度的乘积void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;w[i]&gt;&gt;v[i];        v[i]=w[i]*v[i];    &#125;    for(int i=1;i&lt;=m;i++)&#123;        for(int j=n;j&gt;=w[i];j--)&#123;            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[n]&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1164 小A点菜//计数背包#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int a[N],dp[10005];//dp表是花费i元时的点菜总方案数void solve()&#123;    int n,m,p;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    dp[0]=1;    //我们不进行任何操作时,便可知结果的(隐藏条件告知),花费0元时的总方案为1    //当dp[4]=dp[4]+dp[4-4]时,故可知dp[0]=1;	for(int i=1;i&lt;=n;i++)&#123;		for(int j=m;j&gt;=a[i];j--)&#123;			dp[j]=dp[j]+dp[j-a[i]];		&#125;	&#125;	cout&lt;&lt;dp[m]&lt;&lt;&quot;\n&quot;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1734 最大约数和//s是容积,每个数是体积,每个数约数和是价值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int a[1005],dp[1005];//dp[i]i表示选的这几个数的和在i以内,dp[i]表示选的这几个数的约数和的最大值void solve()&#123;    int s;    cin&gt;&gt;s;    for(int i=1;i&lt;=s;i++)&#123;        for(int j=1;j&lt;i;j++)&#123;            if(i%j==0)&#123;                a[i]+=j;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=s;i++)&#123;        for(int j=s;j&gt;=i;j--)&#123;            dp[j]=max(dp[j],dp[j-i]+a[i]);        &#125;    &#125;    cout&lt;&lt;dp[s]&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1507 NASA的食物计划#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 400 + 5;int dp[N][N];struct node&#123;    int h,t,k;&#125;a[55];void solve()&#123;    int H,T,n;    cin&gt;&gt;H&gt;&gt;T&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i].h&gt;&gt;a[i].t&gt;&gt;a[i].k;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=H;j&gt;=a[i].h;j--)&#123;            for(int x=T;x&gt;=a[i].t;x--)&#123;                dp[j][x]=max(dp[j][x],dp[j-a[i].h][x-a[i].t]+a[i].k);            &#125;        &#125;    &#125;    cout&lt;&lt;dp[H][T]&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



3.最短路//dijkstraint dis[N],vis[N],f[N][N];//dis用于记录从起点到i的最短路,vis标记是否用过,f用于存储前驱到后驱的权值//n为n个点void dijkstra() &#123;	//初始化	memset(dis,inf,sizeof(dis));	dis[s]=0;//起点到自己当然是0	for(int i=1; i&lt;=n; i++) &#123;		int t=-1;//用于找第一个未被标记的点		for(int j=1; j&lt;=n; j++)			if(!vis[j] &amp;&amp; (t==-1 || dis[j]&lt;dis[t])) t=j;//未标记或找到更近的		vis[t]=1;//标记，防止再次计算		for(int j=1; j&lt;=n; j++) &#123;			dis[j] = min(dis[j],dis[t]+f[t][j]);		&#125;	&#125;&#125;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt;&gt; g[N]; struct Node &#123;    int x, w; // x表示点编号，w表示源点到x的最短距离    bool operator&lt;(const Node&amp; u) const &#123;        return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶    &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123;    // 初始化距离数组为无穷大    memset(dis, inf, sizeof(dis));    // 初始化访问标记数组为false    memset(vis, 0, sizeof(vis));    pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0    while (!pq.empty()) &#123; // 只要队列不为空        auto [x, w] = pq.top(); pq.pop(); // 取出队头元素        if (vis[x]) continue; // 如果走过直接跳过        vis[x] = 1; // 标记为走过        for (const auto &amp;[y, dw] : g[x]) &#123; // x-&gt;y, 边权为dw的边            if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键                dis[y] = dis[x] + dw;                pq.push(&#123;y, dis[y]&#125;);            &#125;        &#125;    &#125;&#125;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt; &gt; g[N]; struct Node &#123;    int x, w; // x表示点编号，w表示源点到x的最短距离    bool operator&lt;(const Node&amp; u) const &#123;        return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶    &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123;    // 初始化距离数组为无穷大    memset(dis, inf, sizeof(dis));    // 初始化访问标记数组为false    memset(vis, 0, sizeof(vis));    pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0    while (!pq.empty()) &#123; // 只要队列不为空        int x= pq.top().x; pq.pop(); // 取出队头元素        if (vis[x]) continue; // 如果走过直接跳过        vis[x] = 1; // 标记为走过        for (int i=0;i&lt;g[x].size();i++) &#123; // x-&gt;y, 边权为dw的边        	int y=g[x][i].first;        	int dw=g[x][i].second;            if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键                dis[y] = dis[x] + dw;                pq.push(&#123;y, dis[y]&#125;);            &#125;        &#125;    &#125;&#125;//P1359 租用游艇#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int dis[10005],vis[10005],f[10001][10001];int n,s=1;void dijkstra() &#123;	//初始化	memset(dis,inf,sizeof(dis));	dis[s]=0;//起点到自己当然是0	for(int i=1; i&lt;=n; i++) &#123;		int t=-1;//用于找第一个未被标记的点		for(int j=1; j&lt;=n; j++)			if(!vis[j] &amp;&amp; (t==-1 || dis[j]&lt;dis[t])) t=j;//未标记或找到更近的		vis[t]=1;//标记，防止再次计算		for(int j=1; j&lt;=n; j++) &#123;			dis[j] = min(dis[j],dis[t]+f[t][j]);		&#125;	&#125;&#125;void solve()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(i==j) f[i][j]=0;            else f[i][j]=inf;        &#125;    &#125;    for(int i=1;i&lt;=n-1;i++)&#123;        for(int j=i+1;j&lt;=n;j++)&#123;            cin&gt;&gt;f[i][j];        &#125;    &#125;    dijkstra();    cout&lt;&lt;dis[n]&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//堆优化之后,此题是有向图,即从站点1出发不可在站点1停靠#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e2 + 5;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt;&gt; g[N]; struct Node &#123;    int x, w; // x表示点编号，w表示源点到x的最短距离    bool operator&lt;(const Node&amp; u) const &#123;        return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶    &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123;    // 初始化距离数组为无穷大    memset(dis, inf, sizeof(dis));    // 初始化访问标记数组为false    memset(vis, 0, sizeof(vis));    pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0    while (!pq.empty()) &#123; // 只要队列不为空        auto [x, w] = pq.top(); pq.pop(); // 取出队头元素        if (vis[x]) continue; // 如果走过直接跳过        vis[x] = 1; // 标记为走过        for (const auto &amp;[y, dw] : g[x]) &#123; // x-&gt;y, 边权为dw的边            if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键                dis[y] = dis[x] + dw;                pq.push(&#123;y, dis[y]&#125;);            &#125;        &#125;    &#125;&#125;void solve()&#123;    int n,w;    cin&gt;&gt;n;    for(int i=1;i&lt;=n-1;i++)&#123;        for(int j=i+1;j&lt;=n;j++)&#123;            cin&gt;&gt;w;            g[i].push_back(&#123;j,w&#125;);        &#125;    &#125;    dijkstra(1);    cout&lt;&lt;dis[n]&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1629 邮递员送信#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;int dis[N],vis[N];vector&lt;pair&lt;int, int&gt;&gt; g[N]; struct Node &#123;    int x, w; // x表示点编号，w表示源点到x的最短距离    bool operator&lt;(const Node&amp; u) const &#123;        return w == u.w ? x &lt; u.x : w &gt; u.w; // 按照w降序，在优先队列中w最小的作为堆顶    &#125;&#125;;priority_queue&lt;Node&gt; pq;void dijkstra(int st) &#123;    // 初始化距离数组为无穷大    memset(dis, inf, sizeof(dis));    // 初始化访问标记数组为false    memset(vis, 0, sizeof(vis));    pq.push(&#123;st, dis[st] = 0&#125;); // 源点到源点的距离为0    while (!pq.empty()) &#123; // 只要队列不为空        auto [x, w] = pq.top(); pq.pop(); // 取出队头元素        if (vis[x]) continue; // 如果走过直接跳过        vis[x] = 1; // 标记为走过        for (const auto &amp;[y, dw] : g[x]) &#123; // x-&gt;y, 边权为dw的边            if (dis[x] + dw &lt; dis[y]) &#123; // 这一步十分关键                dis[y] = dis[x] + dw;                pq.push(&#123;y, dis[y]&#125;);            &#125;        &#125;    &#125;&#125;void solve()&#123;    int n,m,u,v,w;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        g[u].push_back(&#123;v,w&#125;);    &#125;    dijkstra(1);    int ans=0;    for(int i=2;i&lt;=n;i++)&#123;        ans+=dis[i];    &#125;    for(int i=2;i&lt;=n;i++)&#123;        dijkstra(i);        ans+=dis[1];    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



4.区间求中位数:前缀和+哈希表#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e3 + 5;int a[N],sum[N],s[2*N];void solve()&#123;    int n,ans=0;	cin&gt;&gt;n;	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];	for(int i=1;i&lt;=n;i++)&#123;		memset(s,0,sizeof(s));		for(int j=1;j&lt;=n;j++)&#123;			if(a[j]&lt;a[i])&#123;				sum[j]=sum[j-1]+(-1);			&#125;else if(a[j]&gt;a[i])&#123;				sum[j]=sum[j-1]+1;			&#125;else &#123;				sum[j]=sum[j-1];			&#125;		&#125;		sum[0]=0;		for(int j=0;j&lt;i;j++)&#123;			s[sum[j]+2001]+=j+1;		&#125;		for(int j=i;j&lt;=n;j++)&#123;			ans+=j*s[sum[j]+2001]*a[i];		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



5.二分最大值最小化,最小值最大化
//找到数xint binary_search(int l,int r,int x)&#123;    while(l&lt;=r)&#123;        int mid=(l+r)/2;        if(a[mid]==x)&#123;            return mid;        &#125;        else if(a[mid]&gt;x)&#123;            r=mid-1;        &#125;        else&#123;            l=mid+1;        &#125;    &#125;    return -1;&#125;//找到第一个x的位置,尽量往左找int binary_search(int l,int r,int x)&#123;	while(l&lt;r)&#123;		int mid=l+(r-l)/2;		if(check(mid))&#123;			r=mid;		&#125;else &#123;			l=mid+1;		&#125;	&#125;	if(a[l]==x)return l;	return -1;&#125;//尽量往右找int binary_search(int l,int r,int x)&#123;	while(l&lt;r)&#123;		int mid=l+(r-l)/2;		if(check(mid))&#123;			l=mid;		&#125;else &#123;			r=mid-1;		&#125;	&#125;	if(a[l]==x)return l;	return -1;&#125;//浮点二分double bsearch(double l, double r)&#123;    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)  // 两种写法：此时是用精度控制循环次数，直接控制循环100次也是OK的！    &#123;        double mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    &#125;    return l;&#125;                         //二分答案int l=0,r=100000000;//把左端与右端定义，这个地方有些题范围不能开太大，有一定的要求，不过这里就OK了while(l&lt;=r)&#123;	int mid=(l+r)/2;	if(judge(mid))//判断步骤 		l=mid+1;	else		r=mid-1;//有些题这里有微调……不过不影响 &#125; cout&lt;&lt;r; //P1577 切绳子#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6+ 5;int a[N];int n,k;bool judge(int x)&#123;    int ans=0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=a[i]/x;    &#125;    if(ans&gt;=k) return true;    else return false;&#125;int binary_search(int l,int r)&#123;    while(l&lt;=r)&#123;	int mid=(l+r)/2;	if(mid==0) break;	if(judge(mid))		l=mid+1;	else		r=mid-1;    &#125;     return r;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    double b;    for(int i=1;i&lt;=n;i++) &#123;        cin&gt;&gt;b;        a[i]=(int)(b*100);    &#125;    int ans=binary_search(0,10000000);    printf(&quot;%0.2f&quot;,ans/100.0);&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1182	数列分段 Section II#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int a[N];int n,m;bool check(int x)&#123;    int sum=0,cnt=1;    for(int i=1;i&lt;=n;i++)&#123;        if(a[i]+sum&gt;x)&#123;            sum=a[i];            cnt++;        &#125;else &#123;            sum+=a[i];        &#125;    &#125;    if(cnt&gt;m) return true;    return false;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    int r=0,l=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        r+=a[i];        l=max(l,a[i]);    &#125;    while(l&lt;=r)&#123;        int mid=l+(r-l)/2;        if(check(mid))&#123;            l=mid+1;        &#125;else&#123;            r=mid-1;        &#125;    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1281 [CERC1998] 书的复制//与上一题的思路基本一致,只是最后从后往前遍历,保证越往前抄的越少#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;int a[N];int m,k;bool check(int x)&#123;    int sum=0,cnt=1;    for(int i=1;i&lt;=m;i++)&#123;        if(a[i]+sum&gt;x)&#123;            sum=a[i];            cnt++;        &#125;else &#123;            sum+=a[i];        &#125;    &#125;    if(cnt&gt;k) return true;    return false;&#125;void solve()&#123;    cin&gt;&gt;m&gt;&gt;k;    int r=0,l=0;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;a[i];        r+=a[i];        l=max(l,a[i]);    &#125;    while(l&lt;=r)&#123;        int mid=l+(r-l)/2;        if(check(mid))&#123;            l=mid+1;        &#125;else&#123;            r=mid-1;        &#125;    &#125;    stack&lt;pair&lt;int,int&gt; &gt;st;    int sum=0,ansr=m;    for(int i=m;i&gt;=1;i--)&#123;        if(a[i]+sum==l)&#123;            sum=0;            st.push(&#123;i,ansr&#125;);            ansr=i-1;        &#125;else if(a[i]+sum&gt;l)&#123;            sum=a[i];            st.push(&#123;i+1,ansr&#125;);            ansr=i;        &#125;else &#123;            sum+=a[i];            if(i==1)&#123;                st.push(&#123;i,ansr&#125;);            &#125;        &#125;    &#125;    while(!st.empty())&#123;        auto [l,r]=st.top();        st.pop();        cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;    &#125;    &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1396 营救#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e4+5;//N一开始开大了导致MLEint n,m,s,t;int vis[N];//一开始没开vis数组导致TLEvector&lt;pair&lt;int,int&gt;&gt;g[N];bool check(int x)&#123;    //bfs    memset(vis,0,sizeof(vis));    queue&lt;int&gt;q;    q.push(s);    vis[s]=1;    while(!q.empty())&#123;        int u=q.front();        if(u==t)return true;        q.pop();        for(auto [v,w]:g[u])&#123;            if(vis[v])continue;            if(w&gt;x)continue;            q.push(v);vis[v]=1;        &#125;    &#125;    return false;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;    int l=0,r=0;    for(int i=1;i&lt;=m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        r=max(r,w);        //无向图        g[u].push_back(&#123;v,w&#125;);        g[v].push_back(&#123;u,w&#125;);    &#125;    while(l&lt;=r)&#123;        int mid = (l+r)&gt;&gt;1;        if(check(mid))&#123;            r=mid-1;        &#125;        else &#123;            l=mid+1;        &#125;    &#125;    cout&lt;&lt;l&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1570 KC 喝咖啡//难点:公式变形,变形之后如何往二分答案上靠//∑(1,m)c*x-∑(1,m)*v=0,我们只需尽可能的让式子的左侧尽可能的靠近0//也就是说我们选择的c[i]*x-v[i]要尽可能的小,所以贪心排序,选择前m个较小的c[i]*x-v[i]#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 2e2 + 5;int n,m;struct node&#123;    int v,c;    double val;    bool operator&lt;(const node &amp;a)const&#123;        return val&lt;a.val;    &#125;&#125;a[N];bool check(double x)&#123;    for(int i=1;i&lt;=n;i++)a[i].val=x*a[i].c-a[i].v;    sort(a+1,a+1+n);    double sum=0;    for(int i=1;i&lt;=m;i++)&#123;        sum+=a[i].val;    &#125;    return sum&lt;=0;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].v;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].c;    //浮点二分模版    double l=0,r=1000;    while(r-l&gt;1e-6)&#123;        double mid=(l+r)/2;        if(check(mid))&#123;            l=mid;        &#125;else&#123;            r=mid;        &#125;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1661 扩散//为什么用二分答案:这道题求得是两点之间花费时间的最大值中的最小值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 50 + 5;int n;int bseach[N];vector&lt;pair&lt;int,int&gt;&gt;v(N);//判断是否连通:并查集int find(int x)&#123;    if(bseach[x]==x)return x;    return bseach[x]=find(bseach[x]);&#125;bool check(int x)&#123;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            int a=abs(v[i].first - v[j].first);            int b=abs(v[i].second - v[j].second);            //a+b为两点之间的连通所花费时间的两倍(两个点都可以扩散)            if(a+b&lt;=2*x)&#123;                int fa=find(i),fb=find(j);                if(fa!=fb)&#123;                    bseach[fa]=fb;                &#125;            &#125;        &#125;    &#125;    int cnt=0;    for(int i=0;i&lt;n;i++)&#123;        if(bseach[i]==i)&#123;            cnt++;        &#125;    &#125;    //当x很大时,所有点都连通    if(cnt==1)&#123;        return true;    &#125;else &#123;        return false;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;v[i].first&gt;&gt;v[i].second;    &#125;    //二分答案模版    int l=0,r=1e9+10;    while(l&lt;=r)&#123;        int mid=l+(r-l)/2;        for(int i=0;i&lt;n;i++)&#123;            bseach[i]=i;        &#125;        if(check(mid))&#123;            r=mid-1;        &#125;else &#123;            l=mid+1;        &#125;    &#125;        cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;//P1843 奶牛晒衣服//为什么会想到二分答案:求的是晒每件衣服中所花费时间中最大时间的最小值#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 5e5 + 5;int n,a,b;int w[N];bool check(int x)&#123;    //哪些地方必须得用烘干才用,若用超了这说明不行    //x既代表了花费的最大时间,也代表了最多可使用的烘干次数    int cnt=0;    for(int i=1;i&lt;=n;i++)&#123;        int re=max(0ll,w[i]-x*a);        //在x的时间内若可直接晒干,则直接跳过        if(re==0)continue;        //记录烘干次数        cnt+=re/b+(re%b==0?0:1);        if(cnt&gt;x)return false;    &#125;    return true;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];    int l=0,r=5e5+1;    while(l&lt;=r)&#123;        int mid=l+(r-l)/2;        if(check(mid))&#123;            r=mid-1;        &#125;        else&#123;            l=mid+1;        &#125;    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



6.双指针+模拟//P1638 逛画展#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int a[N],b[2005],cnt;void in(int x)&#123;    if(b[x]==0)cnt++;    b[x]++;&#125;void d(int x)&#123;    if(b[x]==1)cnt--;    b[x]--;&#125;void solve()&#123;     int n,m;      cin&gt;&gt;n&gt;&gt;m;      for(int i=1;i&lt;=n;i++)&#123;          cin&gt;&gt;a[i];      &#125;    int l=1,ans=inf,ansl=1,ansr=n;      for(int i=1;i&lt;=n;i++)&#123;        in(a[i]);        while(true)&#123;            d(a[l]);            if(cnt==m)l++;            else &#123;                in(a[l]);                break;            &#125;        &#125;        if(cnt==m&amp;&amp;i-l+1&lt;ans)ans=i-l+1,ansl=l,ansr=i;    &#125;    cout&lt;&lt;ansl&lt;&lt;&quot; &quot;&lt;&lt;ansr&lt;&lt;endl; &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



7.最小生成树Kruskal算法struct Edge &#123;    int x, y, c;    bool operator&lt; (const Edge &amp;u) const &#123;        return c &lt; u.c;    &#125;&#125;;int pre[N];int root(int x) &#123;    return pre[x] == x ? x : root(pre[x]);&#125;void solve() &#123;    int n, m; cin &gt;&gt; n &gt;&gt; m;    vector&lt;Edge&gt; es;    for(int i = 1; i &lt;= m; ++ i) &#123;        int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;        es.push_back(&#123;x, y, c&#125;);    &#125;    sort(es.begin(), es.end());    for(int i = 1; i &lt;= n; ++ i) pre[i] = i;    int ans = 0;    for(const auto&amp; [x, y, c] : es) &#123;        if(root(x) == root(y)) continue;        ans = max(ans, c);        pre[root(x)] = root(y);    &#125;    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;&#125;//P1661 扩散//点之间的最短时间是确定的,我们要找出最短时间的最大值//连通且最短时间确定,故用最小生成树#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;struct Edge &#123;    int x, y, c;    bool operator&lt; (const Edge &amp;u) const &#123;        return c &lt; u.c;    &#125;&#125;;int pre[N];int root(int x) &#123;    return pre[x] == x ? x : root(pre[x]);&#125;void solve() &#123;    int n; cin &gt;&gt; n ;    vector&lt;Edge&gt; es;    vector&lt;pair&lt;int,int&gt;&gt;d;    for(int i = 0; i &lt; n; ++ i) &#123;        int x, y; cin &gt;&gt; x &gt;&gt; y;        d.push_back(&#123;x,y&#125;);    &#125;    //kruskal模版    for(int i = 0; i &lt; n; ++ i) &#123;        for(int j=i+1;j&lt;n;++j)&#123;            int c = (abs(d[i].first - d[j].first)+abs(d[i].second - d[j].second)+1)/2;//计算时间            //曼哈顿距离为奇数时:c=dis/2+1=(dis+1)/2            es.push_back(&#123;i, j, c&#125;);        &#125;    &#125;    sort(es.begin(), es.end());    for(int i = 0; i &lt; n; ++ i) pre[i] = i;    int ans = 0;    for(const auto&amp; [x, y, c] : es) &#123;        if(root(x) == root(y)) continue;        ans = max(ans, c);        pre[root(x)] = root(y);    &#125;    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

Prim算法struct Edge &#123;    ll x, c;    bool operator&lt; (const Edge &amp;u) const &#123;        return c == u.c ? x &gt; u.x : c &lt; u.c;    &#125;&#125;;vector&lt;Edge&gt; g[N];ll d[N];int n, m;int prim() &#123;    priority_queue&lt;Edge&gt; pq;    bitset&lt;N&gt; vis;    d[1] = 0;    pq.push(&#123;1, d[1]&#125;);    ll res = 0;    while(pq.size()) &#123;        int x = pq.top().x; pq.pop();        if(vis[x]) continue;        vis[x] = true;        res = max(res, d[x]);        for(const auto &amp;[y, w] : g[x]) &#123;            if(!vis[y]) &#123;                d[y] = min(d[y], w);                pq.push(&#123;y, d[y]&#125;);            &#125;        &#125;    &#125;    return res;&#125;



8.并查集int root(int x) &#123;    if (pre[x] == x) return x; // 如果当前节点是自身的父节点，则它是根节点    return root(pre[x]); // 否则，递归地查找父节点的根&#125;

路径压缩优化int root(int x) &#123;    return pre[x] = (pre[x] == x ? x : root(pre[x])); // 路径压缩，将沿途节点直接指向根节点&#125;

合并操作void merge(int x, int y) &#123;    int rx = root(x), ry = root(y); // 找到两个节点的根节点    if (rx == ry) return; // 如果两个根节点相同，则无需合并    // 如果rx所在集合更大，则交换rx和ry，以保证rx所在集合的大小不超过ry所在集合    if (siz[rx] &gt; siz[ry]) swap(rx, ry);    // 将rx所在集合合并到ry所在集合中    pre[rx] = ry; // 将rx的根节点指向ry    siz[ry] += siz[rx]; // 更新ry所在集合的大小    // 合并完成后，rx将不再作为根节点，其大小信息也失去了意义&#125;



947. 移除最多的同行或同列石头 - 力扣（LeetCode）//从边缘到中心逐渐消减石头//最后发现属于一个集合的只会剩下一块石头class Solution &#123;public:int father[1001];int siz[1001];int mpx[10001];int mpy[10001];    int root(int x) &#123;        return father[x] = (father[x] == x ? x : root(father[x]));     &#125;    void merge(int x,int y)&#123;        int rx=root(x),ry=root(y);        if(rx==ry)return ;        if(siz[rx]&gt;siz[ry])swap(rx,ry);        father[rx]=ry;        siz[ry]+=siz[rx];    &#125;    int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) &#123;        int n=stones.size();        for(int i=1;i&lt;=n;i++)&#123;            father[i]=i;        &#125;        for(int i=0;i&lt;n;i++)&#123;            int x=stones[i][0];            int y=stones[i][1];            if(mpx[x]==0)&#123;                mpx[x]=i+1;            &#125;else&#123;                merge(mpx[x],i+1);            &#125;            if(mpy[y]==0)&#123;                mpy[y]=i+1;            &#125;else&#123;                merge(mpy[y],i+1);            &#125;        &#125;        int ans=0;        for(int i=1;i&lt;=n;i++)&#123;            if(father[i]==i)ans++;        &#125;        return n-ans;    &#125;&#125;;



P1111 修复公路 - 洛谷&#x2F;&#x2F;需要在合并的时候判断:
若两个集合的father相同那么就判一下他们father的siz集合个数是否达到n,
若两个集合的father不同,那么就一定没有实现所有元素在一个集合,故对他们进行合并.合并后在判断是否集合个数达到n,即所有元素在同一个集合
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;struct node&#123;    int x,y,t;&#125;arr[N];bool cmp(node a,node b)&#123;    return a.t&lt;b.t;&#125;int father[1005],siz[1005],n,m;;int root(int x)&#123;    if(x==father[x])return x;    return father[x]=root(father[x]);&#125;bool merge(int x,int y)&#123;    int fx=root(x),fy=root(y);    if(fx==fy)&#123;//father相同        if(siz[fx]==n)&#123;            return true;        &#125;        return false;    &#125;    //father不同    if(siz[fx]&gt;siz[fy])&#123;        swap(fx,fy);    &#125;    father[fx]=fy;    siz[fy]+=siz[fx];    if(siz[fy]==n)&#123;        return true;    &#125;    return false;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;arr[i].x&gt;&gt;arr[i].y&gt;&gt;arr[i].t;    &#125;    sort(arr+1,arr+m+1,cmp);    for(int i=1;i&lt;=n;i++)&#123;        father[i]=i;        siz[i]=1;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        if(merge(arr[i].x,arr[i].y))&#123;            cout&lt;&lt;arr[i].t&lt;&lt;endl;            return;        &#125;    &#125;    cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



[P3958 NOIP 2017 提高组] 奶酪 - 洛谷&#x2F;&#x2F;思路就是:将能够相交的划分为一组,然后将存放坐标的数组依据z值从小到大排序,l从小到大跑,rr从大到小跑,如果满足arr[l].z-r&lt;&#x3D;0并且arr[rr].z+r&gt;&#x3D;h则说明上下连通,接着判断二者是否连通即可。
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e3 + 5;struct node&#123;    int x,y,z,id;&#125; arr[N];bool cmp(node a,node b)&#123;    return a.z&lt;b.z;&#125;int father[N],siz[N];int root(int x)&#123;    if(father[x]==x)return x;    return father[x]=root(father[x]);&#125;void merge(int x,int y)&#123;    int fx=root(x),fy=root(y);    if(fx==fy)return ;    if(siz[fx]&gt;siz[fy])&#123;        swap(fx,fy);    &#125;    father[fx]=fy;    siz[fy]+=siz[fx];&#125;void solve()&#123;    memset(father,0,sizeof(father));    memset(siz,0,sizeof(siz));    int n,h,r;    cin&gt;&gt;n&gt;&gt;h&gt;&gt;r;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i].x&gt;&gt;arr[i].y&gt;&gt;arr[i].z;        father[i]=i;        siz[i]=1;        arr[i].id=i;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=i+1;j&lt;=n;j++)&#123;            if(abs((arr[i].x-arr[j].x)*(arr[i].x-arr[j].x)+(arr[i].y-arr[j].y)*(arr[i].y-arr[j].y)+(arr[i].z-arr[j].z)*(arr[i].z-arr[j].z))&lt;=4*r*r)&#123;                merge(i,j);            &#125;        &#125;    &#125;    sort(arr+1,arr+1+n,cmp);    for(int l=1;l&lt;=n;l++)&#123;        for(int rr=n;rr&gt;=l;rr--)&#123;//一开始rr写成r,导致错误            if((arr[l].z-r)&lt;=0&amp;&amp;(arr[rr].z+r&gt;=h))&#123;                if(root(arr[l].id)==root(arr[rr].id))&#123;                    cout&lt;&lt;&quot;Yes\n&quot;;                    return;                &#125;            &#125;else&#123;                break;            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;No\n&quot;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



[P1525 NOIP 2010 提高组] 关押罪犯 - 洛谷&#x2F;&#x2F;这道题我忽略的点:
只有两所监狱
&#x2F;&#x2F;所以怨气值越大的肯定就越要分开,所以对怨气值进行从大到小的排序,
&#x2F;&#x2F;从大到小遍历怨气值,如果遍历到的两个犯人已经被分配到同一个监狱则输出二人的怨气值即可
&#x2F;&#x2F;若没有被分配到同一个监狱,他们互为敌人,则分别将他们敌人的敌人与他们自己合并(分配到同一个监狱),
&#x2F;&#x2F;用b[i]记录i的敌人代表(开始b[i]为0,则将第一个敌人赋给b[i])

[!CAUTION]
当m&#x3D;1时需进行特判,原因是因为它并没有机会在循环中输出

#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int f[20005],e[20005];struct node&#123;    int a,b,c;&#125;arr[100005];bool cmp(node a,node b)&#123;    return a.c&gt;b.c;&#125;int find(int x)&#123;    if(f[x]==x)return x;    return f[x]=find(f[x]);&#125;void merge(int x,int y)&#123;    int fx=find(x),fy=find(y);    if(fx==fy)return;    f[fx]=fy;&#125;void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;arr[i].a&gt;&gt;arr[i].b&gt;&gt;arr[i].c;    &#125;    if(m==1)&#123;        cout&lt;&lt;0&lt;&lt;&#x27;\n&#x27;;        return ;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        f[i]=i;    &#125;    sort(arr+1,arr+1+m,cmp);    for(int i=1;i&lt;=m;i++)&#123;        if(find(arr[i].a)==find(arr[i].b))&#123;            cout&lt;&lt;arr[i].c&lt;&lt;endl;            return;        &#125;else&#123;            if(!e[arr[i].a])&#123;                e[arr[i].a]=arr[i].b;            &#125;else&#123;                merge(arr[i].b,e[arr[i].a]);            &#125;            if(!e[arr[i].b])&#123;                e[arr[i].b]=arr[i].a;            &#125;else&#123;                merge(arr[i].a,e[arr[i].b]);            &#125;        &#125;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



[P4185 USACO18JAN] MooTube G - 洛谷&#x2F;&#x2F;这道题给我的教训是:
我的贪心的思维很差
&#x2F;&#x2F;贪心思路(+离线思路):
先把k值大的数量统计(该合并的合并),则k值小的包含k值大的答案
遍历r的思路是:
从大到小,则每次的r都是各点到其他点的最小可能r(其他比r大的R所关联的点已连接)
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;struct node1&#123;    int p,q,r;&#125;arr[N];struct node2&#123;    int k,v,id;&#125;brr[N];int ans[N];bool cmp1(node1 a,node1 b)&#123;    return a.r&gt;b.r;&#125;bool cmp2(node2 a,node2 b)&#123;    return a.k&gt;b.k;&#125;int pre[N],siz[N];int root(int x) &#123;    return pre[x] = (pre[x] == x ? x : root(pre[x])); // 路径压缩，将沿途节点直接指向根节点&#125;void merge(int x, int y) &#123;    int rx = root(x), ry = root(y); // 找到两个节点的根节点    if (rx == ry) return; // 如果两个根节点相同，则无需合并    // 如果rx所在集合更大，则交换rx和ry，以保证rx所在集合的大小不超过ry所在集合    if (siz[rx] &gt; siz[ry]) swap(rx, ry);    // 将rx所在集合合并到ry所在集合中    pre[rx] = ry; // 将rx的根节点指向ry    siz[ry] += siz[rx]; // 更新ry所在集合的大小    // 合并完成后，rx将不再作为根节点，其大小信息也失去了意义&#125;void solve()&#123;    int N,Q;    cin&gt;&gt;N&gt;&gt;Q;    for(int i=1;i&lt;N;i++)&#123;        cin&gt;&gt;arr[i].p&gt;&gt;arr[i].q&gt;&gt;arr[i].r;    &#125;    for(int i=1;i&lt;=Q;i++)&#123;        cin&gt;&gt;brr[i].k&gt;&gt;brr[i].v;        brr[i].id=i;    &#125;    for(int i=1;i&lt;=N;i++)&#123;        pre[i]=i;        siz[i]=1;    &#125;    sort(arr+1,arr+1+N,cmp1);    sort(brr+1,brr+1+Q,cmp2);    int j=1;    for(int i=1;i&lt;=Q;i++)&#123;        while(j&lt;N&amp;&amp;arr[j].r&gt;=brr[i].k)&#123;            merge(arr[j].p,arr[j].q);            j++;        &#125;        ans[brr[i].id]=siz[root(brr[i].v)];    &#125;    for(int i=1;i&lt;=Q;i++)&#123;        cout&lt;&lt;ans[i]-1&lt;&lt;&quot;\n&quot;;    &#125;    &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



[P2024 NOI2001] 食物链 - 洛谷
//种类并查集#include &lt;cstdio&gt;inline int read() &#123;	char c = getchar(); int n = 0;	while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; c = getchar(); &#125;	while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + (c &amp; 15); c = getchar(); &#125;	return n;&#125;const int maxN = 100005;int n, m, ans, fa[maxN * 3];int find(int u) &#123; return fa[u] == u ? u : fa[u] = find(fa[u]); &#125;/* * 主函数，处理输入数据并执行集合操作 * 使用并查集实现关系判断和合并 * 处理两种操作：opt=1 表示同类关系，opt=2 表示捕食关系 */int main() &#123;	n = read(), m = read();	for (int i = 1; i &lt;= n * 3; i++) &#123; fa[i] = i; &#125;	for (; m; m--) &#123;		int opt = read(), u = read(), v = read();		if (u &gt; n || v &gt; n) &#123; ans++; continue; &#125;		if (opt == 1) &#123;			if (find(u + n) == find(v) || find(u) == find(v + n)) &#123; ans++; &#125;			else &#123;				fa[find(u)] = find(v);				fa[find(u + n)] = find(v + n);				fa[find(u + n + n)] = find(v + n + n);			&#125;		&#125; else &#123;			if (find(u) == find(v) || find(u) == find(v + n)) &#123; ans++; &#125;			else &#123;				fa[find(u + n)] = find(v);				fa[find(u + n + n)] = find(v + n);				fa[find(u)] = find(v + n + n);			&#125;		&#125;	&#125;	printf(&quot;%d\n&quot;, ans);	return 0;&#125;



9.思维题(1)//1292B - Aroma&#x27;s Search//越靠前点越密集,dis(xi,xi+1)的min值为xi,dis(xi,x0)=xi-x0,两式相减可得dis(xi,,xi+1)&gt;dis(xi,x0)(因为x0&gt;1),故捡数据点时,应先寻找点密集的那一侧,再返回点疏的那一侧#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n,x[100],y[100];int dis(int x1,int y1,int x2,int y2)&#123;    return abs(x1-x2)+abs(y1-y2);&#125;void solve()&#123;    int x0,y0,ax,ay,bx,by,xs,ys,t,ans=0;    cin&gt;&gt;x0&gt;&gt;y0&gt;&gt;ax&gt;&gt;ay&gt;&gt;bx&gt;&gt;by&gt;&gt;xs&gt;&gt;ys&gt;&gt;t;    x[0]=x0,y[0]=y0;    while(++n)&#123;        x[n]=ax*x[n-1]+bx;        y[n]=ay*y[n-1]+by;        if(x[n]&gt;xs&amp;&amp;y[n]&gt;ys&amp;&amp;dis(x[n],y[n],xs,ys)&gt;t)break;    &#125;    for(int i=0;i&lt;n;i++)&#123;        int tans=0,tt=t;        if(dis(x[i],y[i],xs,ys)&lt;=tt)tt-=(dis(x[i],y[i],xs,ys)),tans++;        else &#123;ans=max(ans,tans);continue;&#125;//大于则直接跳过以下步骤        for(int j=i;j;j--)&#123;            if(dis(x[j],y[j],x[j-1],y[j-1])&lt;=tt)tt-=(dis(x[j],y[j],x[j-1],y[j-1])),tans++;            else break;        &#125;        for(int j=0;j&lt;n-1;j++)&#123;//必须从0开始,因为这里不知计算数据点,还要对tt进行处理            if(dis(x[j],y[j],x[j+1],y[j+1])&lt;=tt)tt-=(dis(x[j],y[j],x[j+1],y[j+1])),tans+=j&gt;=i;            else break;        &#125;        ans=max(ans,tans);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

(2)//CF1304C Air Conditioner//维护区间//能够及时变温的条件是前后区间有交集//是否有交集可以通过sl是否大于sr判断#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;void solve()&#123;    int n,sl,sh,st=0;    cin&gt;&gt;n&gt;&gt;sl;    int t,l,h;    sh=sl;    bool flag=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;t&gt;&gt;l&gt;&gt;h;        sh=min(h,t-st+sh);        sl=max(l,sl-t+st);        st=t;        if(sl&gt;sh)flag=1;    &#125;    if(flag) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

(3)//CF1385D a-Good String//根据对称性想到了平衡树(二叉树),故直接遍历每种可能选出消耗最少得操作方法    //时间复杂度由master公式可知为nlogn; #include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 131072;int ans,num;void bfs(string l,string r,int len,char c)&#123;    if(len==0)&#123;        string zi=&quot;&quot;;        zi+=c;        if(r==zi)&#123;            ans=min(ans,num);        &#125;else&#123;            ans=min(ans,num+1);        &#125;        return;    &#125;    for(int i=0;i&lt;len;i++)&#123;        if(l[i]!=c)&#123;            num++;        &#125;    &#125;    bfs(r.substr(0,len/2),r.substr(len/2,len),len/2,(char)(c+1));    for(int i=0;i&lt;len;i++)&#123;        if(l[i]!=c)&#123;            num--;        &#125;    &#125;    for(int i=0;i&lt;len;i++)&#123;        if(r[i]!=c)&#123;            num++;        &#125;    &#125;    bfs(l.substr(0,len/2),l.substr(len/2,len),len/2,(char)(c+1));    for(int i=0;i&lt;len;i++)&#123;        if(r[i]!=c)&#123;            num--;        &#125;    &#125;&#125;void solve()&#123;    int n;    cin&gt;&gt;n;    string s;    cin&gt;&gt;s;    ans=inf,num=0;    if(n==1)&#123;        if(s==&quot;a&quot;)cout&lt;&lt;0&lt;&lt;&#x27;\n&#x27;;        else cout&lt;&lt;1&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    string l=s.substr(0,n/2),r=s.substr(n/2,n);    bfs(l,r,n/2,&#x27;a&#x27;);    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



10.排序希尔排序void shell_sort(int a[],int n)&#123;    int gap=n;    while(gap&gt;1)&#123;        gap=gap/3+1;        for(int i=1;i&lt;=gap;i++)&#123;//控制组数            for(int j=i;j&lt;=n-gap+1;j+=gap)&#123;//控制组内需插入的元素个数                int key=a[j];                int end=j-gap;                while(end&gt;=1&amp;&amp;a[end]&gt;key)&#123;                    a[end+gap]=a[end];                    end-=gap;                &#125;                a[end+gap]=key;            &#125;        &#125;    &#125;&#125;

归并排序int arr[N],help[N],n;void merge(int l,int mid,int r)&#123;    int i=l,a=l,b=mid+1;    while(a&lt;=mid&amp;&amp;b&lt;=r)&#123;        help[i++]=arr[a]&gt;arr[b]?arr[b++]:arr[a++];    &#125;    while(a&lt;=mid)&#123;        help[i++]=arr[a++];    &#125;    while(b&lt;=r)&#123;        help[i++]=arr[b++];    &#125;    for(int i=l;i&lt;=r;i++)&#123;        arr[i]=help[i];    &#125;&#125;void mergeSort1(int l,int r)&#123;    if(l==r)return ;    int mid=(l+r)&gt;&gt;1;    mergeSort1(l,mid);    mergeSort1(mid+1,r);    merge(l,mid,r);&#125;void mergeSort2(int l,int r)&#123;    for(int l,m,r,step=1;step&lt;=n;step&lt;&lt;=1)&#123;        l=0;        while(l&lt;=n)&#123;            m=l+step-1;            if(m+1&gt;n)break;            r=min(l+step*2-1,n);            merge(l,m,r);            l=r+1;        &#125;    &#125;&#125;

快速排序//最好通过随机数划分,的平均复杂度void quickSort(int l,int r)&#123;    if(l&gt;=r)return;    int i=l-1,j=r+1,x=arr[l+r&gt;&gt;1];    while(i&lt;j)&#123;        do&#123;i++;&#125;while(arr[i]&lt;x);        do&#123;j--;&#125;while(arr[j]&gt;x);        if(i&lt;j)swap(arr[i],arr[j]);    &#125;    quickSort(l,j),quickSort(j+1,r);&#125;int first,last;void partition(int l,int r,int x)&#123;    first=l,last=r;    int i=l;    while(i&lt;=last)&#123;        if(arr[i]&lt;x)&#123;            swap(arr[i++],arr[first++]);        &#125;else if(arr[i]==x)i++;        else&#123;            swap(arr[i],arr[last--]);        &#125;    &#125;&#125;void quickSort2(int l,int r)&#123;    if(l&gt;=r)return;    int x=arr[l+r&gt;&gt;1];    partition(l,r,x);    quickSort2(l,first-1);    quickSort2(last+1,r);&#125;



计数排序int cnt[N];void countSort(int l,int r)&#123;    int Max=arr[l],Min=arr[l];    for(int i=l;i&lt;=r;i++)&#123;        if(arr[i]&gt;Max)Max=arr[i];        if(arr[i]&lt;Min)Min=arr[i];    &#125;    int len=Max-Min+1;    for(int i=l;i&lt;=r;i++)&#123;        cnt[arr[i]-Min]++;    &#125;    int it=1;    for(int i=0;i&lt;len;i++)&#123;        while(cnt[i]&gt;0)&#123;            arr[it++]=i+Min;            cnt[i]--;        &#125;    &#125;&#125;

11.0递归11.01经典递归&#x2F;&#x2F;1.返回字符串的所有子序列O(2^n*n)
class Solution &#123;public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param s string字符串      * @return string字符串vector     */    set&lt;string&gt;st;    vector&lt;string&gt;ans;    int len;    vector&lt;string&gt; generatePermutation(string s) &#123;        len=s.length();        solve(&quot;&quot;,0,s);        for(auto it:st)&#123;            ans.push_back(it);        &#125;        return ans;    &#125;   void solve(string s,int i,string ss)&#123;        if(i==len)&#123;            st.insert(s);            return ;        &#125;        string s1=s;        solve(s1,i+1,ss);        s1=s+ss[i];        solve(s1,i+1,ss);        return;    &#125;&#125;;



&#x2F;&#x2F;2.  O(2^n*n)
&#x2F;&#x2F;1,1,1,2,2,4,4     
&#x2F;&#x2F;分组:只有0个1的时候,只有1个1的时候,只有2个1的时候,只有3个1的时候(同理只有0个2的时候,只有1个2的时候,只有2个2的时候)
90. 子集 II - 力扣（LeetCode）
class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;ans;    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;int&gt;vec;        fun(nums,0,vec);        return ans;    &#125;    void fun(vector&lt;int&gt;&amp; nums,int i,vector&lt;int&gt; vec)&#123;        if(i==nums.size())&#123;            ans.push_back(vec);            return ;        &#125;        int j=i+1;        while(j&lt;nums.size()&amp;&amp;nums[i]==nums[j])j++;        fun(nums,j,vec);        for(int t=i;t&lt;j;t++)&#123;            vec.push_back(nums[t]);            fun(nums,j,vec);        &#125;    &#125;&#125;;



&#x2F;&#x2F;输出n个数的所有排列(n*n!)
&#x2F;&#x2F;以原先给定的数组为基准,尝试将每个数交换到i位置,递归下去即可
46. 全排列 - 力扣（LeetCode）
class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;ans;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        fun(nums,0);        return ans;    &#125;    void fun(vector&lt;int&gt;&amp; nums,int i)&#123;        if(i==nums.size())&#123;            vector&lt;int&gt;temp;            for(auto it:nums)&#123;                temp.push_back(it);            &#125;            ans.push_back(temp);        &#125;        for(int j=i;j&lt;nums.size();j++)&#123;            swap(nums[i],nums[j]);            fun(nums,i+1);            swap(nums[i],nums[j]);        &#125;    &#125;&#125;;

&#x2F;&#x2F;汉罗塔
void hanluota(int size,char a,char b,char c)&#123;    if(size==0)&#123;        return;    &#125;    hanluota(size-1,a,c,b);    cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;    hanluota(size-1,c,b,a);&#125;

11.02嵌套类递归
[!IMPORTANT]

定义全局变量where,记录每次嵌套条件结束后i的值,以便后续对i进行更新
结束条件为总问题结结尾或是嵌套问题的结尾


&#x2F;&#x2F;计算含多层括号的表达式
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int where;void pushFun(deque&lt;int&gt;&amp;numbers,deque&lt;char&gt;&amp;ops,int num,char op)&#123;    int size=numbers.size();    if(size==0||ops.back()==&#x27;+&#x27;||ops.back()==&#x27;-&#x27;)&#123;        numbers.push_back(num);        ops.push_back(op);    &#125;else&#123;        int num1=numbers.back();        char op1=ops.back();        numbers.pop_back();        ops.pop_back();        if(op1==&#x27;*&#x27;)&#123;            numbers.push_back(num*num1);        &#125;else&#123;            numbers.push_back(num/num1);        &#125;        ops.push_back(op);    &#125;&#125;int final(deque&lt;int&gt;&amp;numbers,deque&lt;char&gt;&amp;ops)&#123;    int ans=numbers.front();    numbers.pop_front();    while(!numbers.empty())&#123;        ans+=(ops.front()==&#x27;+&#x27;?numbers.front():-numbers.front());        numbers.pop_front();        ops.pop_front();    &#125;    return ans;&#125;//i++,忘了几次 int calculate(string s,int i)&#123;    int cur=0;    deque&lt;int&gt;numbers;deque&lt;char&gt;ops;    while(i&lt;s.length()&amp;&amp;s[i]!=&#x27;)&#x27;)&#123;        if(s[i]&gt;=&#x27;0&#x27;&amp;&amp;s[i]&lt;=&#x27;9&#x27;)&#123;            cur=cur*10+s[i++]-&#x27;0&#x27;;        &#125;else if(s[i]!=&#x27;(&#x27;)&#123;            pushFun(numbers,ops,cur,s[i++]);            cur=0;        &#125;else&#123;            cur=calculate(s,i+1);            i=where+1;        &#125;    &#125;    pushFun(numbers,ops,cur,&#x27;+&#x27;);    where=i;    return final(numbers,ops);&#125;void solve()&#123;    string s;    cin&gt;&gt;s;    cout&lt;&lt;calculate(s,0)&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



11.动态规划983. 最低票价//递归class Solution &#123;public:    const int inf=0x3f3f3f3f;    int duration[3]=&#123;1,7,30&#125;,dp[366]=&#123;0&#125;;    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123;        return solve(days,costs,0);    &#125;    int solve(vector&lt;int&gt;&amp; days,vector&lt;int&gt;&amp; costs,int i)&#123;        if(i==days.size())return 0;        if(dp[i])return dp[i];        int ans=inf;        for(int k=0,j=i;k&lt;3;k++)&#123;            while(j&lt;days.size()&amp;&amp;days[i]+duration[k]&gt;days[j])j++;            ans=min(ans,costs[k]+solve(days,costs,j));        &#125;        dp[i]=ans;        return ans;    &#125;&#125;;//动态规划class Solution &#123;public:    const int inf=0x3f3f3f3f;    int duration[3]=&#123;1,7,30&#125;,dp[366];    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123;        return solve(days,costs,days.size());    &#125;    int solve(vector&lt;int&gt;&amp; days,vector&lt;int&gt;&amp; costs,int n)&#123;        for(int i=0;i&lt;366;i++)&#123;            dp[i]=inf;        &#125;        int ans=inf;        dp[n]=0;        for(int i=n-1;i&gt;=0;i--)&#123;            for(int k=0,j=i;k&lt;3;k++)&#123;                while(j&lt;n&amp;&amp;days[i]+duration[k]&gt;days[j])j++;                dp[i]=min(dp[i],costs[k]+dp[j]);            &#125;        &#125;        return dp[0];    &#125;&#125;;



91. 解码方法//记忆化搜索class Solution &#123;public:    int dp[105];    int numDecodings(string s) &#123;        return solve(s,0);    &#125;    int solve(string s,int i)&#123;        if(i==s.length())return 1;        if(dp[i])return dp[i];        int ans=0;        if(s[i]==&#x27;0&#x27;)&#123;            ans=0;        &#125;else&#123;            ans=solve(s,i+1);            if(i+1&lt;s.length()&amp;&amp;(s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;&lt;=26)&#123;                ans+=solve(s,i+2);            &#125;        &#125;        dp[i]=ans;        return ans;    &#125;&#125;;//动态规划class Solution &#123;public:    int dp[105];    int numDecodings(string s) &#123;        return solve(s,0);    &#125;    int solve(string s,int i)&#123;        dp[s.length()]=1;        for(int i=s.length()-1;i&gt;=0;i--)&#123;                    if(s[i]==&#x27;0&#x27;)&#123;                dp[i]=0;            &#125;else&#123;                dp[i]=dp[i+1];                if(i+1&lt;s.length()&amp;&amp;(s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;&lt;=26)&#123;                    dp[i]+=dp[i+2];                &#125;            &#125;        &#125;        return dp[0];    &#125;&#125;;//从动态规划得到解依赖于其后一个和后后一个数的解,故知道可通过记录后两个数的解即可得到这个数的解,这样节省了空间,从数组到两个变量class Solution &#123;public:    int numDecodings(string s) &#123;        return solve(s,0);    &#125;    int solve(string s,int i)&#123;        int n=1,nn=0,cnt;        for(int i=s.length()-1;i&gt;=0;i--)&#123;                    if(s[i]==&#x27;0&#x27;)&#123;                cnt=0;                nn=n;                n=cnt;            &#125;else&#123;                cnt=n;                if(i+1&lt;s.length()&amp;&amp;(s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;&lt;=26)&#123;                    cnt+=nn;                &#125;                nn=n;                n=cnt;            &#125;        &#125;        return n;    &#125;&#125;;

639. 解码方法 II//动态规划//注意超出类型范围,所以用longclass Solution &#123;public:const long mod=1e9+7;long dp[100005];    int numDecodings(string s) &#123;        return (int)fun(s);    &#125;    long fun(string s)&#123;        int n=s.length();        dp[n]=1;        for(int i=n-1;i&gt;=0;i--)&#123;            if(s[i]==&#x27;0&#x27;)continue;            dp[i]=dp[i+1]*(s[i]==&#x27;*&#x27;?9:1);            if(i+1&lt;n)&#123;                if(s[i]!=&#x27;*&#x27;)&#123;                    if(s[i+1]!=&#x27;*&#x27;)&#123;                        if(((s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;)&lt;=26)&#123;                            dp[i]+=dp[i+2];                        &#125;                    &#125;else&#123;                        if(s[i]==&#x27;1&#x27;)&#123;                            dp[i]+=dp[i+2]*9;                        &#125;else if(s[i]==&#x27;2&#x27;)&#123;                            dp[i]+=dp[i+2]*6;                        &#125;                    &#125;                &#125;else&#123;                    if(s[i+1]!=&#x27;*&#x27;)&#123;                        if(s[i+1]&lt;=&#x27;6&#x27;)dp[i]+=dp[i+2]*2;                        else dp[i]+=dp[i+2];                    &#125;else&#123;                        dp[i]+=dp[i+2]*15;                    &#125;                &#125;            &#125;            dp[i]=dp[i]%mod;        &#125;        return dp[0];    &#125;&#125;;//变量转移,节省空间class Solution &#123;public:const long mod=1e9+7;    int numDecodings(string s) &#123;        return (int)fun(s);    &#125;    long fun(string s)&#123;        int len=s.length();        long nn=0,n=1,cur;        for(int i=len-1;i&gt;=0;i--)&#123;            if(s[i]==&#x27;0&#x27;)&#123;                cur=0;                nn=n;                n=cur;                continue;            &#125;            cur=n*(s[i]==&#x27;*&#x27;?9:1);            if(i+1&lt;len)&#123;                if(s[i]!=&#x27;*&#x27;)&#123;                    if(s[i+1]!=&#x27;*&#x27;)&#123;                        if(((s[i]-&#x27;0&#x27;)*10+s[i+1]-&#x27;0&#x27;)&lt;=26)&#123;                            cur+=nn;                        &#125;                    &#125;else&#123;                        if(s[i]==&#x27;1&#x27;)&#123;                            cur+=nn*9;                        &#125;else if(s[i]==&#x27;2&#x27;)&#123;                            cur+=nn*6;                        &#125;                    &#125;                &#125;else&#123;                    if(s[i+1]!=&#x27;*&#x27;)&#123;                        if(s[i+1]&lt;=&#x27;6&#x27;)cur+=nn*2;                        else cur+=nn;                    &#125;else&#123;                        cur+=nn*15;                    &#125;                &#125;            &#125;            cur=cur%mod;            nn=n;            n=cur;        &#125;        return n;    &#125;&#125;;



32. 最长有效括号//得到一个字符后,以其为开始的点向左延伸,得到这个字符的最长子串//若遇&#x27;(&#x27;,则dp[i]=0;//若遇&#x27;)&#x27;,则dp[i]=(s[i-1-dp[i-1]]==&#x27;(&#x27;?dp[i-1]+2+dp[i-1-dp[i-1]-1]:0)class Solution &#123;public:    int dp[3*10000+5];   int longestValidParentheses(string s) &#123;        s=&quot; &quot;+s;        int n=s.length();        for(int i=1;i&lt;n;i++)&#123;            if(s[i]==&#x27;)&#x27;)&#123;                int j=i-1-dp[i-1];                if(s[j]==&#x27;(&#x27;)&#123;                    dp[i]=dp[i-1]+2+dp[j-1];                &#125;            &#125;        &#125;        int ans=0;        for(int i=1;i&lt;n;i++)&#123;            ans=max(ans,dp[i]);        &#125;        return ans;    &#125;&#125;;



12.差分P5026 Lycanthropy - 洛谷等差数列差分
[!NOTE]
在arr[l]+=s,arr[l+1]+=(d-s),arr[r+1]-=(d+e),arr[r+2]+=e;

两轮叠加:
第一轮s         d        d         d       d           d        d       -e       0       0
第二轮s      s+d    s+2d   s+3d  s+4d    s+5d  s+6d    0        0      0 

#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5,OFFSET=30005;//OFFSET解决了对下标可能为负数的讨论int arr[N+OFFSET*2];void setArr(int l,int r,int s,int d,int e)&#123;    arr[l+OFFSET]+=s;    arr[l+1+OFFSET]+=d-s;    arr[r+1+OFFSET]-=(e+d);    arr[r+2+OFFSET]+=e;&#125;void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    while(n--)&#123;        int v,x;        cin&gt;&gt;v&gt;&gt;x;        setArr(x-3*v+1,x-2*v,1,1,v);        setArr(x-2*v+1,x,v-1,-1,-v);        setArr(x+1,x+2*v,-v+1,1,v);        setArr(x+2*v+1,x+3*v,v-1,-1,0);    &#125;    //等差数列差分需进行二次叠加    for(int i=1;i&lt;=m+OFFSET;i++)&#123;        arr[i]+=arr[i-1];    &#125;    for(int i=1;i&lt;=m+OFFSET;i++)&#123;        arr[i]+=arr[i-1];    &#125;    for(int i=1+OFFSET;i&lt;=m+OFFSET;i++)&#123;        cout&lt;&lt;arr[i]&lt;&lt;&#x27; &#x27;;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

问题://为啥这样改不对    while(n--)&#123;        int v,x;        cin&gt;&gt;v&gt;&gt;x;        setArr(x-3*v,x-2*v,0,1,v);        setArr(x-2*v,x,v,-1,-v);        setArr(x,x+2*v,-v,1,v);        setArr(x+2*v,x+3*v,v,-1,0);    &#125;



13.堆结构//插入并构建大根堆(向上调整)void heapInsert(int i)&#123;    while(arr[i]&gt;arr[(i-1)/2])&#123;        swap(arr[i],arr[(i-1)/2]);        i=(i-1)/2;    &#125;&#125;//i位置的数变小了,需维持大根堆结构,向下调整大根堆(向下调整)//当前堆的大小为sizevoid heapify(int i,int size)&#123;    int l=2*i+1;    while(l&lt;size)&#123;        int best=(l+1&lt;size&amp;&amp;arr[l+1]&gt;arr[l])?(l+1):l;        best=arr[i]&gt;arr[best]?i:best;        if(best==i)break;        swap(arr[i],arr[best]);        i=best;        l=2*i+1;    &#125;&#125;

堆排序void heapInsert(int i)&#123;    while(arr[i]&gt;arr[(i-1)/2])&#123;        swap(arr[i],arr[(i-1)/2]);        i=(i-1)/2;    &#125;&#125;//i位置的数变小了,需维持大根堆结构,向下调整大根堆(向下调整)//当前堆的大小为sizevoid heapify(int i,int size)&#123;    int l=2*i+1;    while(l&lt;size)&#123;        int best=(l+1&lt;size&amp;&amp;arr[l+1]&gt;arr[l])?(l+1):l;        best=arr[i]&gt;arr[best]?i:best;        if(best==i)break;        swap(arr[i],arr[best]);        i=best;        l=2*i+1;    &#125;&#125;void heapSort()&#123;    int n=10;//堆的大小    for(int i=0;i&lt;n;i++)&#123;        heapInsert(i);    &#125;    int size=n;    while(size&gt;1)&#123;        swap(arr[0],arr[--size]);        heapify(0,size);    &#125;&#125;



14.二叉树1.二叉树的层序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:TreeNode* q[2100];vector&lt;int&gt;arr;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        if(root!=nullptr)&#123;            int l=0,r=0;            q[r++]=root;            while(l&lt;r)&#123;                int size=r-l;//r-l                while(size--)&#123;                    TreeNode* x=q[l++];                    if(x==nullptr)continue;                    arr.push_back((x-&gt;val));                    if(x-&gt;left!=nullptr)&#123;                        q[r++]=x-&gt;left;                    &#125;                    if(x-&gt;right!=nullptr)&#123;                        q[r++]=x-&gt;right;                    &#125;                &#125;                ans.push_back(arr);                arr.clear();            &#125;        &#125;        return ans;    &#125;    &#125;;



2.二叉树的锯齿形层序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:TreeNode* q[2005];vector&lt;int&gt;arr;    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt;ans;        if(root!=nullptr)&#123;            int l=0,r=0;            q[r++]=root;            bool flag=false;            while(l&lt;r)&#123;                int size=r-l,i;                if(flag==false)i=l;                else i=r-1;                for(int k=1;k&lt;=size;k++)&#123;                    if(q[i]==nullptr)continue;                    arr.push_back(q[i]-&gt;val);                    if(flag)i--;                    else i++;                &#125;                while(size--)&#123;                    TreeNode* x=q[l++];                    if(x==nullptr)continue;                    if(x-&gt;left!=nullptr)&#123;                        q[r++]=x-&gt;left;                    &#125;                    if(x-&gt;right!=nullptr)&#123;                        q[r++]=x-&gt;right;                    &#125;                &#125;                ans.push_back(arr);                flag=!flag;                arr.clear();            &#125;        &#125;        return ans;    &#125;&#125;;

3.二叉树的最大宽度662. 二叉树最大宽度 - 力扣（LeetCode）
//可能出现很多null值导致下标极大,故用unsigned long long/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:TreeNode* nq[3005];unsigned long long q[3005];    int widthOfBinaryTree(TreeNode* root) &#123;        unsigned long long ans=0;        if(root==nullptr)return ans;        unsigned long long l=0,r=0;        nq[r]=root;        q[r++]=1;        while(l&lt;r)&#123;            unsigned long long size=r-l;            ans=max(ans,q[r-1]-q[l]+1);            while(size--)&#123;                TreeNode* x=nq[l];                unsigned long long iq=q[l++];                if(x==nullptr)continue;                if(x-&gt;left!=nullptr)&#123;                    nq[r]=x-&gt;left;                    q[r++]=iq*2;                &#125;                if(x-&gt;right!=nullptr)&#123;                    nq[r]=x-&gt;right;                    q[r++]=iq*2+1;                &#125;            &#125;        &#125;        return (int)ans;    &#125;&#125;;



4.二叉树的最大深度104. 二叉树的最大深度 - 力扣（LeetCode）
int maxDepth(TreeNode* root)&#123;    return (root==nullptr?0:max(maxSolve(root-&gt;left),maxSolve(root-&gt;right))+1);&#125;

5.二叉树的最小深度111. 二叉树的最小深度 - 力扣（LeetCode）
int minDepth(TreeNode* root)&#123;    if(root==nullptr)return 0;    if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)return 1;    int leftDepth=inf,rightDepth=inf;    if(root-&gt;left!=nullptr)&#123;        leftDepth=minDepth(root-&gt;left);    &#125;    if(root-&gt;right!=nullptr)&#123;        rightDepth=minDepth(root-&gt;right);    &#125;    return min(leftDepth,rightDepth)+1;&#125;

6.知前中序遍历求后序void tree(string front,string mid)&#123;    if(front.empty())return;    char root=front[0];    int k=mid.find(root);    front.erase(front.begin());    string leftfront=front.substr(0,k);    string rightfront=front.substr(k);    string leftmid=mid.substr(0,k);    string rightmid=mid.substr(k+1);    tree(leftfront,leftmid);    tree(rightfront,rightmid);    cout&lt;&lt;root;&#125;

7.知后中序遍历写前序void work(string mid,string back)&#123;    if(back.empty())return ;    char root=back[back.size()-1];    int k=mid.find(root);    back.erase(back.end()-1);    string leftmid=mid.substr(0,k);    string rightmid=mid.substr(k+1);    string leftback=back.substr(0,k);    string rightback=back.substr(k);    cout&lt;&lt;root;    work(leftmid,leftback);    work(rightmid,rightback);&#125;

8.计算二叉树的节点个数222. 完全二叉树的节点个数 - 力扣（LeetCode）
/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int countNodes(TreeNode* root) &#123;        if(root==nullptr)return 0;        return f(root,1,findDepth(root,1));    &#125;    int f(TreeNode* root,int level,int h)&#123;        if(level==h)return 1;        if(findDepth(root-&gt;right,level+1)==h)&#123;            return (1&lt;&lt;(h-level))+f(root-&gt;right,level+1,h);        &#125;else&#123;            return (1&lt;&lt;(h-level-1))+f(root-&gt;left,level+1,h);        &#125;    &#125;    int findDepth(TreeNode* root,int level)&#123;        while(root)&#123;            level++;            root=root-&gt;left;        &#125;        return level-1;    &#125;&#125;;

9.二叉树的最近公共祖先/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if(root==nullptr||root==p||root==q)return root;        TreeNode* l=lowestCommonAncestor(root-&gt;left,p,q);        TreeNode* r=lowestCommonAncestor(root-&gt;right,p,q);        if(l!=nullptr&amp;&amp;r!=nullptr)&#123;            return root;        &#125;        if(l==nullptr&amp;&amp;r==nullptr)&#123;            return nullptr;        &#125;        return l==nullptr?r:l;    &#125;&#125;;//二叉搜索数的最近公共祖先//p,q都在root这个节点之下TreeNode* solve(TreeNode* root ,TreeNode* p,TreeNode* q)&#123;    while(root!=p&amp;&amp;root!=q)&#123;        if(min(p-&gt;val,q-&gt;val)&lt;root-&gt;val&amp;&amp;max(p-&gt;val,q-&gt;val)&gt;root-&gt;val)&#123;            break;        &#125;        root=root-&gt;val&lt;min(p-&gt;val,q-&gt;val)?root-&gt;right:root-&gt;left;    &#125;    return root;&#125;

10.路径总和113. 路径总和 II - 力扣（LeetCode）
&#x2F;&#x2F;注意回溯
/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;ans;deque&lt;int&gt;q;    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        if(root==nullptr)return ans;        solve(root,targetSum,0);        return ans;    &#125;    void solve(TreeNode* root,int targetSum,int curSum)&#123;        if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)&#123;            if(root-&gt;val+curSum==targetSum)&#123;                q.push_back(root-&gt;val);                copy();                q.pop_back();            &#125;        &#125;else&#123;            q.push_back(root-&gt;val);            if(root-&gt;left!=nullptr)&#123;                solve(root-&gt;left,targetSum,curSum+root-&gt;val);            &#125;            if(root-&gt;right!=nullptr)&#123;                solve(root-&gt;right,targetSum,curSum+root-&gt;val);            &#125;            q.pop_back();        &#125;    &#125;    void copy()&#123;        vector&lt;int&gt;arr;        for(auto it:q)&#123;            arr.push_back(it);        &#125;        ans.push_back(arr);    &#125;&#125;;

11.验证平衡二叉树&#x2F;&#x2F;flag的重要性
/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:bool ans;    bool isBalanced(TreeNode* root) &#123;        ans=true;        height(root);        return ans;    &#125;    int height(TreeNode* root)&#123;        if(!ans||root==nullptr)&#123;            return 0;        &#125;        int lh=height(root-&gt;left);        int rh=height(root-&gt;right);        if(abs(lh-rh)&gt;1)&#123;            ans=false;        &#125;        return max(lh,rh)+1;    &#125;&#125;;

12.验证二叉搜索树(涉及中序遍历的非递归实现)/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        if(root==nullptr)return true;        stack&lt;TreeNode*&gt;st;        TreeNode* pre=nullptr;        while(!st.empty()||root!=nullptr)&#123;            if(root!=nullptr)&#123;                st.push(root);                root=root-&gt;left;            &#125;else&#123;                root=st.top();                st.pop();                if(pre!=nullptr&amp;&amp;pre-&gt;val&gt;=root-&gt;val)&#123;                    return false;                &#125;                pre=root;                root=root-&gt;right;            &#125;        &#125;        return true;    &#125;&#125;;//记录左子树的最大最小值和右子树的最大最小值,中间的值要大于左子树的最大值,要小于右子树的最小值/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:long long Max,Min;const long long MMAX=3000000000,MMIN=-3000000000;    bool isValidBST(TreeNode* root) &#123;        if(root==nullptr)&#123;            Max=MMIN;            Min=MMAX;            return true;        &#125;        bool lok=isValidBST(root-&gt;left);        long long lmax=Max;        long long lmin=Min;        bool rok=isValidBST(root-&gt;right);        long long rmax=Max;        long long rmin=Min;        Max=max(max(lmax,rmax),(long long)(root-&gt;val));        Min=min(min(lmin,rmin),(long long)(root-&gt;val));        return lok&amp;&amp;rok&amp;&amp;(lmax&lt;(long long)(root-&gt;val))&amp;&amp;((long long)(root-&gt;val)&lt;rmin);    &#125;&#125;;

13.修剪搜索二叉树（递归)669. 修剪二叉搜索树 - 力扣（LeetCode）
/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;        if(root==nullptr)return nullptr;        if(root-&gt;val&lt;low)&#123;            return trimBST(root-&gt;right,low,high);        &#125;        if(root-&gt;val&gt;high)&#123;            return trimBST(root-&gt;left,low,high);        &#125;        root-&gt;left=trimBST(root-&gt;left,low,high);        root-&gt;right=trimBST(root-&gt;right,low,high);        return root;    &#125;&#125;;

14.打家劫舍iii337. 打家劫舍 III - 力扣（LeetCode）
&#x2F;&#x2F;yes代表偷子节点,no代表不投子节点
&#x2F;&#x2F;y代表偷当前子节点,n代表不投当前子节点
&#x2F;&#x2F;很像dp了
/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:int yes,no;    int rob(TreeNode* root) &#123;        f(root);        return max(yes,no);    &#125;    void f(TreeNode* root)&#123;        if(root==nullptr)&#123;            yes=0;            no=0;        &#125;else&#123;            int y=root-&gt;val;            int n=0;            f(root-&gt;left);            y+=no;            n+=max(yes,no);            f(root-&gt;right);            y+=no;            n+=max(yes,no);            yes=y;            no=n;        &#125;    &#125;&#125;;



15.树状数组[P3605 USACO17JAN] Promotion Counting P - 洛谷未解决
应用:(可求逆序对数)
每个下标a管的范围:其二进制最右侧的1变为0,然后加1,变为b
[b,a];
&#x2F;&#x2F;[前缀树状数组]单点增加,范围查询(前缀)&#x2F;&#x2F;t[i]代表具有一定规律的某一范围的和
int lowbit(int x) &#123;    return x &amp; -x;&#125;void update(int k, int x) &#123;    for(int i = k; i &lt;= n; i += lowbit(i)) t[i] += x;&#125;//1~k范围求和int getprefix(int k) &#123;    int res = 0;    for(int i = k; i &gt; 0; i -= lowbit(i)) res += t[i];    return res;&#125;

1.[P1966 NOIP 2013 提高组] 火柴排队 - 洛谷
第一次错是因为结果忘记取模
&#x2F;&#x2F;疑问如果高度有相同的会不会影响结果,样例是没有这部分测试的或许
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5,mod=1e8-3;struct node&#123;    int val,id;&#125; a[N],b[N];bool cmp(node x,node y)&#123;    return x.val&lt;y.val;&#125;int c1[N];int c2[N];int c3[N];int t[N],n;//树状数组模版int lowbit(int x)&#123;    return x&amp;(-x);&#125;void update(int x,int y)&#123;    for(int i=x;i&lt;=n;i+=lowbit(i))&#123;        t[i]+=y;    &#125;&#125;int query(int x)&#123;    int res = 0;    for(int i=x;i&gt;0;i-=lowbit(i))&#123;        res=(res%mod+t[i]%mod)%mod;    &#125;    return res;&#125;void solve()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i].val;        a[i].id=i;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;b[i].val;        b[i].id=i;    &#125;    sort(a+1,a+n+1,cmp);    sort(b+1,b+n+1,cmp);    //1342    //1234(开始时从1到n,上下两列都是)    //1724        //转换参照物    //1423(排序后)    //1342(排序后)(1234)        //上列查1得1,查2得3,查3得4,查4得2    //1342    //1423    //得到原排序顺序        //1423对应1234,查1342所对应的    //1342(1423)    //1423(1234)        //得到1423    //相对于1234        //求1423的逆序对即可    //证明略,猜的    for(int i=1;i&lt;=n;i++)&#123;        c1[a[i].id]=i;        c2[b[i].id]=i;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        c3[c2[i]]=i;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        c2[i]=c3[c1[i]];    &#125;        int res=0;    for(int i=1;i&lt;=n;i++)&#123;        update(c2[i],1);        res=((res%mod+query(n)%mod)%mod+(-query(c2[i])%mod+mod)%mod)%mod;    &#125;    cout&lt;&lt;res&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



&#x2F;&#x2F;[差分树状数组]范围增加,单点查询,利用差分数组(差分)&#x2F;&#x2F;t[i]代表某一范围的差分和
&#x2F;&#x2F;求和可得某一位置的数
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n,t[N],arr[N];int lowbit(int x)&#123;    return x&amp;(-x);&#125;void update(int x,int val)&#123;    for(int i=x;i&lt;=n;i+=lowbit(i))t[i]+=val;&#125;int query(int x)&#123;    int ans=0;    for(int i=x;i&gt;0;i-=lowbit(i))ans+=t[i];    return ans;&#125;void solve()&#123;    int m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        update(i,arr[i]-arr[i-1]);    &#125;    while(m--)&#123;        int op,x,y,k;        cin&gt;&gt;op;        if(op==1)&#123;            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            update(x,k);            update(y+1,-k);        &#125;        else&#123;            cin&gt;&gt;x;            cout&lt;&lt;query(x)&lt;&lt;endl;        &#125;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

&#x2F;&#x2F;范围增加,范围查询线段树void pushup(int o) &#123;    t[o] = t[o &lt;&lt; 1] + t[o &lt;&lt; 1 | 1];&#125;void build(int s = 1, int e = n, int o = 1) &#123;    if (s == e) &#123;        // 递归出口        t[o] = a[s];        return;    &#125;    int mid = (s + e) &gt;&gt; 1;    build(s, mid, o &lt;&lt; 1);    build(mid + 1, e, o &lt;&lt; 1 | 1);    pushup(o);&#125;void pushdown(int s, int e, int o) &#123;    if (lz[o]) &#123;        int mid = (s + e) / 2;        t[o * 2] += (mid - s + 1) * lz[o];        t[o * 2 + 1] += (e - mid) * lz[o];        lz[o * 2] += lz[o];        lz[o * 2 + 1] += lz[o];        lz[o] = 0;    &#125;&#125;void update(int l, int r, int v, int s, int e, int o) &#123;    if (l &lt;= s &amp;&amp; r &gt;= e) &#123;        t[o] += (e - s + 1) * v;        lz[o] += v;        return;    &#125;    pushdown(s, e, o);    int mid = (s + e) / 2;    if (l &lt;= mid) update(l, r, v, s, mid, o * 2);    if (r &gt; mid) update(l, r, v, mid + 1, e, o * 2 + 1);    pushup(o);&#125;int query(int l, int r, int s, int e, int o) &#123;    if (l &lt;= s &amp;&amp; e &lt;= r) &#123;        return t[o];    &#125;    pushdown(s, e, o);    int mid = (s + e) / 2;    int res = 0;    if (l &lt;= mid) res += query(l, r, s, mid, o * 2);    if (r &gt; mid) res += query(l, r, mid + 1, e, o * 2 + 1);    return res;&#125;

可持久化线段树void build(int&amp; x, int l, int r)&#123;    x = ++idx;    if (l == r)return;    int mid = (l + r) &gt;&gt; 1;    build(lc(x), l, mid);    build(rc(x), mid + 1, r);&#125;void update(int pre, int&amp; o, int l, int r, int v)&#123;    o = ++idx;    t[o] = t[pre];    t[o].val++;    if (l == r)return;    int mid = (l + r) &gt;&gt; 1;    if (v &lt;= mid)        update(lc(pre), lc(o), l, mid, v);    else        update(rc(pre), rc(o), mid + 1, r, v);&#125;int query(int x, int y, int l, int r, int k)&#123;    if (l == r)return l;    int mid = (l + r) &gt;&gt; 1;    int s = t[lc(y)].val - t[lc(x)].val;    if (k &lt;= s)        return query(lc(x), lc(y), l, mid, k);    else        return query(rc(x), rc(y), mid + 1, r, k - s);&#125;

欧拉筛如果能让每个合数都只被标记一次，那么时间复杂度就可以降到 𝑂(𝑛) 
void euler(int n) &#123;    vector&lt;int&gt; primes;    bool vis[n + 1] = &#123;false&#125;;  // 初始化vis数组，默认所有数都是质数候选    vis[0] = vis[1] = true;     // 0和1不是质数     for (int i = 2; i &lt;= n; ++i) &#123;        // 如果i没有被筛除，说明i是质数，存入vector中        if (!vis[i]) &#123;            primes.push_back(i);        &#125;        // 注意枚举条件，i * primes[j]表示要被筛除的数字（一定不是质数）        for (int j = 0; j &lt; primes.size() &amp;&amp; i * primes[j] &lt;= n; ++j) &#123;            vis[i * primes[j]] = true;            // 如果i能被primes[j]整除，说明primes[j+1]已经不是i * primes[j+1]的最小质因子了            if (i % primes[j] == 0) &#123;                break;            &#125;        &#125;    &#125;&#125;

Kruskal算法struct Edge &#123;    int x, y, c;    bool operator&lt; (const Edge &amp;u) const &#123;        return c &lt; u.c;    &#125;&#125;;int pre[N];int root(int x) &#123;    return pre[x] == x ? x : root(pre[x]);&#125;void solve() &#123;    int n, m; cin &gt;&gt; n &gt;&gt; m;    vector&lt;Edge&gt; es;    for(int i = 1; i &lt;= m; ++ i) &#123;        int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;        es.push_back(&#123;x, y, c&#125;);    &#125;    sort(es.begin(), es.end());    for(int i = 1; i &lt;= n; ++ i) pre[i] = i;    int ans = 0;    for(const auto&amp; [x, y, c] : es) &#123;        if(root(x) == root(y)) continue;        ans = max(ans, c);        pre[root(x)] = root(y);    &#125;    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;&#125;

Prim算法struct Edge &#123;    ll x, c;    bool operator&lt; (const Edge &amp;u) const &#123;        return c == u.c ? x &gt; u.x : c &lt; u.c;    &#125;&#125;;vector&lt;Edge&gt; g[N];ll d[N];int n, m;int prim() &#123;    priority_queue&lt;Edge&gt; pq;    bitset&lt;N&gt; vis;    d[1] = 0;    pq.push(&#123;1, d[1]&#125;);    ll res = 0;    while(pq.size()) &#123;        int x = pq.top().x; pq.pop();        if(vis[x]) continue;        vis[x] = true;        res = max(res, d[x]);        for(const auto &amp;[y, w] : g[x]) &#123;            if(!vis[y]) &#123;                d[y] = min(d[y], w);                pq.push(&#123;y, d[y]&#125;);            &#125;        &#125;    &#125;    return res;&#125;

16.链表
[!NOTE]
写链表的题是要特别注意非空判断,避免空指针异常

//https://www.luogu.com.cn/problem/P1996#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;struct ListNode &#123;      int val;      ListNode *next;      ListNode() : val(0), next(nullptr) &#123;&#125;      ListNode(int x) : val(x), next(nullptr) &#123;&#125;      ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; &#125;;void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    ListNode* head=new ListNode(1);    ListNode* p=head;    for(int i=2;i&lt;=n;i++)&#123;        p-&gt;next=new ListNode(i);        p=p-&gt;next;    &#125;    p-&gt;next=head;//成环    int num=n;//记录总共的节点个数    p=head;    ListNode* pre=p;//记录前一个节点,用于删除节点    while(num)&#123;        //保证p要不为空        for(int i=1;i&lt;=m-1&amp;&amp;p!=nullptr;i++)&#123;            pre=p;            p=p-&gt;next;        &#125;        if(p==nullptr) break;        cout&lt;&lt;p-&gt;val&lt;&lt;&quot; &quot;;        pre-&gt;next=p-&gt;next;        delete p;//删除节点        p=pre-&gt;next;//把p指向下一个节点        num--;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



&#x2F;&#x2F;双重循环会超时(1e5*1e5),但一般看到这个我们还会想到一种方法,那就是对应数值索引
&#x2F;&#x2F;这道题的思路很简单,就是的注意非空判断,以及更改的先后顺序
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e5 + 5;struct ListNode&#123;    int val;    ListNode *next,*pre;    ListNode():val(0),next(nullptr)&#123;&#125;    ListNode(int x):val(x),next(nullptr)&#123;&#125;&#125;arr[N];void solve()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        arr[i].val=i;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        int k,p;        cin&gt;&gt;k&gt;&gt;p;        if(p==1)&#123;            //arr[k].next依赖与arr[k],故需要将arr[k].next保存起来,才可修改arr[k].next-&gt;pre            //插后面,先管后,再管前            arr[i].next=arr[k].next;            if(arr[k].next!=nullptr)arr[k].next-&gt;pre=&amp;(arr[i]);            arr[k].next=&amp;(arr[i]);            arr[i].pre=&amp;(arr[k]);        &#125;else&#123;            //插前面,先管前,再管后            arr[i].pre=arr[k].pre;            if(arr[k].pre!=nullptr)arr[k].pre-&gt;next=&amp;(arr[i]);            arr[i].next=&amp;(arr[k]);            arr[k].pre=&amp;(arr[i]);        &#125;    &#125;    int m;    cin&gt;&gt;m;    while(m--)&#123;        int x;        cin&gt;&gt;x;        if(arr[x].val==0)continue;        arr[x].val=0;        if(arr[x].pre!=nullptr)arr[x].pre-&gt;next=arr[x].next;        if(arr[x].next!=nullptr)arr[x].next-&gt;pre=arr[x].pre;        arr[x].pre=nullptr;        arr[x].next=nullptr;    &#125;    int mark=0;    for(int i=1;i&lt;=n;i++)&#123;        if(arr[i].pre==nullptr&amp;&amp;arr[i].next!=nullptr)&#123;            mark=i;            break;        &#125;    &#125;    ListNode *head=&amp;(arr[mark]);    while(head)&#123;        cout&lt;&lt;head-&gt;val&lt;&lt;&quot; &quot;;        head=head-&gt;next;    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



17.打表构造题就打表
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int n;int vis[N];deque&lt;int&gt;ans;int cnt;//通过cnt使得答案只输出一次void dfs(int dep,int sum)&#123;    if(dep==n&amp;&amp;cnt==0)&#123;//设置结束条件        cnt++;        for(auto x:ans)&#123;            cout&lt;&lt;x&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;        return ;    &#125;    for(int i=0;i&lt;=n-1;i++)&#123;        if(vis[i])continue;        if(!(sum^i))continue;        vis[i]=1;        ans.push_back(i);        dfs(dep+1,sum^i);        vis[i]=0;        ans.pop_back();//回退vis以及ans    &#125;&#125;void solve()&#123;    cnt=0;    cin&gt;&gt;n;    dfs(0,0);&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

//https://codeforces.com/gym/105386/problem/G#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int a[N];void solve()&#123;    int n;    cin&gt;&gt;n;    if(n%4==0||n==1)&#123;        cout&lt;&lt;&quot;impossible\n&quot;;        return ;    &#125;    if(n==2)&#123;        cout&lt;&lt;&quot;1 0\n&quot;;        return;    &#125;    if(n==3)&#123;        cout&lt;&lt;&quot;1 0 2\n&quot;;        return ;    &#125;    a[0]=1;    a[1]=0;    a[2]=2;    for(int i=3;i&lt;n;i++)&#123;        a[i]=i;        if(i%4==0)&#123;            swap(a[i-1],a[i]);        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;    &#125;    cout&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

18.唯一分解定理for (int i = 2; i &lt;= x / i; ++i) &#123;        // 如果不能整除直接跳过        if (x % i) continue;                // 如果可以整除，那么必然是一个质因子（从小到大枚举的特性决定）        int cnt = 0;        // 一直除，直到除干净        while (x % i == 0) cnt++, x /= i;        v.push_back(&#123;i, cnt&#125;);    &#125;        // 如果x大于1，说明x本身就是一个质数    if (x &gt; 1) v.push_back(&#123;x, 1&#125;);        // 输出所有质因数及其对应的指数    for (const auto&amp; i : v) cout &lt;&lt; i.first &lt;&lt; &#x27; &#x27; &lt;&lt; i.second &lt;&lt; &#x27;\n&#x27;; 因数个数的寻找与一些数学谜题息息相关。现在小编为大家分享一下自我研究出的通过分解质因数寻找因数个数的方法。首先讲一个数分解质因数，如果有相同的质因数就整理成幂次方的形式。将结果的指数加一，再将此结果相乘得到其因数个数。举例：72，用列举法不易找出其因数个数。而72＝2×2×2×3×3＝2³×3²，分别将指数3,2加一变成4,3，4×3＝12个。列举证明1,2,3,4,6,8,9,12,18,24,36,72共12个因数。

math位运算[P5657 CSP-S2019] 格雷码 - 洛谷打表找规律
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;vector&lt;string&gt; digui(int n)&#123;    if(n==1)&#123;        vector&lt;string&gt;ans;        ans.push_back(&quot;0&quot;);        ans.push_back(&quot;1&quot;);        return ans;    &#125;    vector&lt;string&gt;temp;    temp=digui(n-1);    vector&lt;string&gt;res;    for(int i=0;i&lt;temp.size();i++)&#123;        res.push_back(&quot;0&quot;+temp[i]);    &#125;    for(int i=temp.size()-1;i&gt;=0;i--)&#123;        res.push_back(&quot;1&quot;+temp[i]);    &#125;    return res;&#125;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;string&gt;ans=digui(n);    for(int i=0;i&lt;ans.size();i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;;    &#125;    cout&lt;&lt;endl;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

这道题很明显是有蹊跷的,数据范围过大。
但是让我找规律我未必能发现
但仔细思考一下,位数高达64位,我们不可能生成所有数再查询,所以只可能是每一个数的每位是0还是1有规律可寻,所以我们自然而然的去关注打表后每一个数的每一位是否呈现某种规律
规律:
倒数第n位就是 2^(n−1) 个 0 , 2^(n−1) 个 1 , 2^(n−1) 个 1 , 2^(n−1) 个 0 循环
位数高达64,得用unsigned long long
#include &lt;bits/stdc++.h&gt;using namespace std;#define int unsigned long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int ans[64];int num[]=&#123;0,1,1,0&#125;;void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    for(int i=n-1;i&gt;0;i--)&#123;        cout&lt;&lt;num[(k/((int)(1)&lt;&lt;i))%4];    &#125;    cout&lt;&lt;num[k%4]&lt;&lt;endl;//最后要单独输出，否则会出现inf    //若这里不单独输出,当i等于0时,进行i--操作后,i会变成unsigned long long 所能表示的最大整数(18446744073709551615),使得循环无法结束,故需特殊处理&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

第k个格雷码&#x3D;k^(k&gt;&gt;1)
我们再输出每一位即可
#include &lt;bits/stdc++.h&gt;using namespace std;#define int unsigned long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int num[]=&#123;0,1,1,0&#125;;void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    k=k^(k&gt;&gt;1);    while(n)&#123;        n--;        if(k==-1) break;        cout&lt;&lt;((k&gt;&gt;n)&amp;1);    &#125;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



[P5514 MtOI2019] 永夜的报应 - 洛谷a最大可达1e9则我们设置a的二进制最大有32位,统计每一个a的每一位是否为1,
cnt[i]代表i位为1的a的个数,若该位的1为奇数个,则无论如何组合该位都会留下,其他位同理,我们最后只需对留下的1乘以他们所对应的位权即可
从以上推出更简单的结果所得公式ans&#x3D;0;ans^&#x3D;a;cout&lt;&lt;ans;
#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int inf=0x3f3f3f3f,N = 1e6 + 5;int cnt[35];void solve()&#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int a;        cin&gt;&gt;a;        for(int j=31;j&gt;=0;j--)&#123;            cnt[j]+=((a&gt;&gt;j)&amp;1);        &#125;    &#125;    int ans=0;    for(int i=31;i&gt;=0;i--)&#123;        if(cnt[i]%2==1)        ans+=(1&lt;&lt;i);    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;

P5539 【XR-3】Unknown Mother-Goose - 洛谷(bitset优化)题目要求的是把 S 集合中所有的数的倍数标记之后，连续 3 个都被标记的位置的数量(这步采用位运算,非常巧妙。)

bs 数组：用二进制位标记数字是否被选中。unsigned long long 是 64 位，因此 bs[k] 对应数字 k*64 ~ (k+1)*64-1，其中第 b 位（0≤b&lt;64）为 1 表示数字 k*64 + b 被标记。

#include&lt;bits/stdc++.h&gt;#define N 1000000003#define reg registerusing namespace std;unsigned long long bs[(N&gt;&gt;6)+10];unsigned long long tmp[65];int n,m,s,l,ans;//统计1的个数,即连续3个都被标记的位置的数量inline int count(unsigned long long x)&#123;    reg int res = 0;    while(x)&#123;        res += x&amp;1;        x &gt;&gt;= 1;    &#125;    return res;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;s;    m = (n&gt;&gt;6)+1;    while(s--)&#123;        cin&gt;&gt;l;        if(l&lt;64)&#123; //两种情况判一下,保证加入的复杂度是 n/w            memset(tmp,0,sizeof(tmp));            for(reg int i=0;i&lt;(l&lt;&lt;6);i+=l)                tmp[i&gt;&gt;6] |= 1ull&lt;&lt;(i&amp;63); //加入的数比较小,开另一个数组,作为重复单元,i&amp;63相当于i%64            for(reg int i=0;i&lt;=m;i+=l)            for(reg int j=0;j&lt;l;++j)                bs[i+j] |= tmp[j];            &#125;else&#123;            for(reg int i=0;i&lt;=n;i+=l)                bs[i&gt;&gt;6] |= 1ull&lt;&lt;(i&amp;63);        &#125;    &#125;    --m;    if((n&amp;63)!=63) bs[m] &amp;= (1ull&lt;&lt;(n+1-(m&lt;&lt;6)))-1; //特判一下最后一块    bs[0] &amp;= -2ull; //除去第 0 项,-2的补码为11111111110    //连续的出现在同一块中    for(reg int i=0;i&lt;=m;++i) ans += count(bs[i]&amp;(bs[i]&lt;&lt;1)&amp;(bs[i]&lt;&lt;2));    //连续的出现在不同块中,有两种情况    //x = (i-1)*64 + 62，x+1 = (i-1)*64 + 63，x+2 = i*64 + 0    //x = (i-1)*64 + 63，x+1 = i*64 + 0，x+2 = i*64 + 1    for(reg int i=1;i&lt;=m;++i) ans += count(bs[i]&amp;(bs[i-1]&gt;&gt;62)&amp;((bs[i-1]&gt;&gt;63)|(bs[i]&lt;&lt;1)));    cout&lt;&lt;ans;    return 0;&#125;

素数Miller Rabin(高精度素数判定)bool millerRabin(int n) &#123;  if (n &lt; 3 || n % 2 == 0) return n == 2;  if (n % 3 == 0) return n == 3;  int u = n - 1, t = 0;  while (u % 2 == 0) u /= 2, ++t;  // test_time 为测试次数，建议设为不小于 8  // 的整数以保证正确率，但也不宜过大，否则会影响效率  for (int i = 0; i &lt; test_time; ++i) &#123;    // 0, 1, n-1 可以直接通过测试, a 取值范围 [2, n-2]    int a = rand() % (n - 3) + 2, v = quickPow(a, u, n);    if (v == 1) continue;    int s;    for (s = 0; s &lt; t; ++s) &#123;      if (v == n - 1) break;  // 得到平凡平方根 n-1，通过此轮测试      v = (long long)v * v % n;    &#125;    // 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t    // 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1    if (s == t) return 0;  &#125;  return 1;&#125;完整版:ll bmul(ll a, ll b, ll m) &#123;  // 快速乘  ull c = (ull)a * (ull)b - (ull)((long double)a / m * b + 0.5L) * (ull)m;  if (c &lt; (ull)m) return c;  return c + m;&#125;ll qpow(ll x, ll p, ll mod) &#123;  // 快速幂  ll ans = 1;  while (p) &#123;    if (p &amp; 1) ans = bmul(ans, x, mod);    x = bmul(x, x, mod);    p &gt;&gt;= 1;  &#125;  return ans;&#125;bool Miller_Rabin(ll p) &#123;  // 判断素数  if (p &lt; 2) return false;  if (p == 2) return true;  if (p == 3) return true;  ll d = p - 1, r = 0;  while (!(d &amp; 1)) ++r, d &gt;&gt;= 1;  // 将d处理为奇数  for (ll k = 0; k &lt; 10; ++k) &#123;    ll a = rand() % (p - 2) + 2;    ll x = qpow(a, d, p);    if (x == 1 || x == p - 1) continue;    for (int i = 0; i &lt; r - 1; ++i) &#123;      x = bmul(x, x, p);      if (x == p - 1) break;    &#125;    if (x != p - 1) return false;  &#125;  return true;&#125;

P5535 【XR-3】小道消息 - 洛谷
#include &lt;bits/stdc++.h&gt;using namespace std;using ll =long long;using ull=unsigned long long;const int inf=0x3f3f3f3f,N = 1e6 + 5;ll bmul(ll a, ll b, ll m) &#123;  // 快速乘  ull c = (ull)a * (ull)b - (ull)((long double)a / m * b + 0.5L) * (ull)m;  if (c &lt; (ull)m) return c;  return c + m;&#125;ll qpow(ll x, ll p, ll mod) &#123;  // 快速幂  ll ans = 1;  while (p) &#123;    if (p &amp; 1) ans = bmul(ans, x, mod);    x = bmul(x, x, mod);    p &gt;&gt;= 1;  &#125;  return ans;&#125;bool Miller_Rabin(ll p) &#123;  // 判断素数  if (p &lt; 2) return false;  if (p == 2) return true;  if (p == 3) return true;  ll d = p - 1, r = 0;  while (!(d &amp; 1)) ++r, d &gt;&gt;= 1;  // 将d处理为奇数  for (ll k = 0; k &lt; 10; ++k) &#123;    ll a = rand() % (p - 2) + 2;    ll x = qpow(a, d, p);    if (x == 1 || x == p - 1) continue;    for (int i = 0; i &lt; r - 1; ++i) &#123;      x = bmul(x, x, p);      if (x == p - 1) break;    &#125;    if (x != p - 1) return false;  &#125;  return true;&#125;void solve()&#123;    ll n,k;    cin&gt;&gt;n&gt;&gt;k;    n=n+1;    k=k+1;    //对n和k进行处理,使得n变成最大标号,k变成其对应的标号    if(Miller_Rabin(k))&#123;        //若k为质数                //对于存在其倍数的,需第二天其他质数标记        if(n/k&gt;1)&#123;            cout&lt;&lt;&quot;2\n&quot;;        &#125;else&#123;        //对于不存在其倍数的,因其是质数,与其他的剩余的数均是互质的            cout&lt;&lt;&quot;1\n&quot;;        &#125;    &#125;else&#123;        //如果k是合数,则其很明显不能标记它的质因子,需第二天其他质数来标记        cout&lt;&lt;&quot;2\n&quot;;    &#125;           &#125;signed main()&#123;	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);	int t=1;    // cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;	return 0;&#125;



质因数分解(最朴素的算法)vector&lt;int&gt; result;void breakdown(int n)&#123;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n%i==0)&#123;            while(n%i==0)n/=i;            result.push_back(i);        &#125;    &#125;    if(n!=1)&#123;        result.push_back(n);    &#125;&#125;

Pollard_Rho算法(找到数x的一个平凡因子)以下配合找到数x的最大质因子ll max_factor, n;ll gcd(ll a, ll b) &#123;  if (b == 0) return a;  return gcd(b, a % b);&#125;ll Pollard_Rho(ll x) &#123;  ll s = 0, t = 0;  ll c = (ll)rand() % (x - 1) + 1;  int step = 0, goal = 1;  ll val = 1;  for (goal = 1;; goal *= 2, s = t, val = 1) &#123;  // 倍增优化    for (step = 1; step &lt;= goal; ++step) &#123;      t = (bmul(t, t, x) + c) % x;      val = bmul(val, abs(t - s), x);      if ((step % 127) == 0) &#123;        ll d = gcd(val, x);        if (d &gt; 1) return d;      &#125;    &#125;    ll d = gcd(val, x);    if (d &gt; 1) return d;  &#125;&#125;

]]></content>
  </entry>
</search>
